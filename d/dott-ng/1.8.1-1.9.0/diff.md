# Comparing `tmp/dott_ng-1.8.1-py3-none-any.whl.zip` & `tmp/dott_ng-1.9.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 56123 bytes, number of entries: 23
--rw-rw-rw-  2.0 fat        0 b- defN 23-May-29 12:27 dottmi/__init__.py
--rw-rw-rw-  2.0 fat    15481 b- defN 23-May-29 12:27 dottmi/breakpoint.py
--rw-rw-rw-  2.0 fat     2509 b- defN 23-May-29 12:27 dottmi/breakpointhandler.py
--rw-rw-rw-  2.0 fat     8158 b- defN 23-May-29 12:27 dottmi/dott.py
--rw-rw-rw-  2.0 fat    22402 b- defN 23-May-29 12:27 dottmi/dott_conf.py
--rw-rw-rw-  2.0 fat      924 b- defN 23-May-29 12:27 dottmi/dottexceptions.py
--rw-rw-rw-  2.0 fat    15638 b- defN 23-May-29 12:27 dottmi/fixtures.py
--rw-rw-rw-  2.0 fat    10377 b- defN 23-May-29 12:27 dottmi/gdb.py
--rw-rw-rw-  2.0 fat     8411 b- defN 23-May-29 12:27 dottmi/gdb_cmds.py
--rw-rw-rw-  2.0 fat    15965 b- defN 23-May-29 12:27 dottmi/gdb_mi.py
--rw-rw-rw-  2.0 fat     3312 b- defN 23-May-29 12:27 dottmi/gdb_shared.py
--rw-rw-rw-  2.0 fat     1643 b- defN 23-May-29 12:27 dottmi/gdbcontrollerdott.py
--rw-rw-rw-  2.0 fat     3980 b- defN 23-May-29 12:27 dottmi/monitor.py
--rw-rw-rw-  2.0 fat     4717 b- defN 23-May-29 12:27 dottmi/pylinkdott.py
--rw-rw-rw-  2.0 fat     1245 b- defN 23-May-29 12:27 dottmi/symbols.py
--rw-rw-rw-  2.0 fat    23743 b- defN 23-May-29 12:27 dottmi/target.py
--rw-rw-rw-  2.0 fat    32809 b- defN 23-May-29 12:27 dottmi/target_mem.py
--rw-rw-rw-  2.0 fat    18434 b- defN 23-May-29 12:27 dottmi/utils.py
--rw-rw-rw-  2.0 fat    11558 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat      890 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        7 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1758 b- defN 23-May-29 12:31 dott_ng-1.8.1.dist-info/RECORD
-23 files, 204053 bytes uncompressed, 53349 bytes compressed:  73.9%
+Zip file size: 57984 bytes, number of entries: 23
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-10 12:22 dottmi/__init__.py
+-rw-rw-rw-  2.0 fat    15481 b- defN 23-Jul-10 12:22 dottmi/breakpoint.py
+-rw-rw-rw-  2.0 fat     2509 b- defN 23-Jul-10 12:22 dottmi/breakpointhandler.py
+-rw-rw-rw-  2.0 fat     8552 b- defN 23-Jul-10 12:22 dottmi/dott.py
+-rw-rw-rw-  2.0 fat    24977 b- defN 23-Jul-10 12:22 dottmi/dott_conf.py
+-rw-rw-rw-  2.0 fat      924 b- defN 23-Jul-10 12:22 dottmi/dottexceptions.py
+-rw-rw-rw-  2.0 fat    15682 b- defN 23-Jul-10 12:22 dottmi/fixtures.py
+-rw-rw-rw-  2.0 fat    10920 b- defN 23-Jul-10 12:22 dottmi/gdb.py
+-rw-rw-rw-  2.0 fat     8411 b- defN 23-Jul-10 12:22 dottmi/gdb_cmds.py
+-rw-rw-rw-  2.0 fat    15965 b- defN 23-Jul-10 12:22 dottmi/gdb_mi.py
+-rw-rw-rw-  2.0 fat     3312 b- defN 23-Jul-10 12:22 dottmi/gdb_shared.py
+-rw-rw-rw-  2.0 fat     1643 b- defN 23-Jul-10 12:22 dottmi/gdbcontrollerdott.py
+-rw-rw-rw-  2.0 fat     6247 b- defN 23-Jul-10 12:22 dottmi/monitor.py
+-rw-rw-rw-  2.0 fat     4755 b- defN 23-Jul-10 12:22 dottmi/pylinkdott.py
+-rw-rw-rw-  2.0 fat     1245 b- defN 23-Jul-10 12:22 dottmi/symbols.py
+-rw-rw-rw-  2.0 fat    23959 b- defN 23-Jul-10 12:22 dottmi/target.py
+-rw-rw-rw-  2.0 fat    32809 b- defN 23-Jul-10 12:22 dottmi/target_mem.py
+-rw-rw-rw-  2.0 fat    20124 b- defN 23-Jul-10 12:22 dottmi/utils.py
+-rw-rw-rw-  2.0 fat    11558 b- defN 23-Jul-10 12:26 dott_ng-1.9.0.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat      890 b- defN 23-Jul-10 12:26 dott_ng-1.9.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-10 12:26 dott_ng-1.9.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        7 b- defN 23-Jul-10 12:26 dott_ng-1.9.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1758 b- defN 23-Jul-10 12:26 dott_ng-1.9.0.dist-info/RECORD
+23 files, 211820 bytes uncompressed, 55210 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -48,23 +48,23 @@
 
 Filename: dottmi/target_mem.py
 Comment: 
 
 Filename: dottmi/utils.py
 Comment: 
 
-Filename: dott_ng-1.8.1.dist-info/LICENSE.txt
+Filename: dott_ng-1.9.0.dist-info/LICENSE.txt
 Comment: 
 
-Filename: dott_ng-1.8.1.dist-info/METADATA
+Filename: dott_ng-1.9.0.dist-info/METADATA
 Comment: 
 
-Filename: dott_ng-1.8.1.dist-info/WHEEL
+Filename: dott_ng-1.9.0.dist-info/WHEEL
 Comment: 
 
-Filename: dott_ng-1.8.1.dist-info/top_level.txt
+Filename: dott_ng-1.9.0.dist-info/top_level.txt
 Comment: 
 
-Filename: dott_ng-1.8.1.dist-info/RECORD
+Filename: dott_ng-1.9.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dottmi/dott.py

```diff
@@ -16,184 +16,189 @@
 #   limitations under the License.
 ###############################################################################
 
 from __future__ import annotations  # available from Python 3.7 onwards, default from Python 3.11 onwards
 
 import typing
 
+from dottmi import utils
 from dottmi.dott_conf import DottConf
+from dottmi.gdb import GdbServer
 
 if typing.TYPE_CHECKING:
     from dottmi.target import Target
 
-import socket
 import types
 from typing import List
 
 from dottmi.dottexceptions import DottException
 from dottmi.monitor import MonitorJLink, Monitor, MonitorOpenOCD
 from dottmi.utils import log_setup, singleton
 
 
 class DottHooks(object):
     _pre_connect_hook: types.FunctionType = None
+    _gdb_pre_connect_hook: types.FunctionType = None
 
     @classmethod
     def set_pre_connect_hook(cls, pre_connect_hook: types.FunctionType) -> None:
+        """
+        This hook is called before the target instance is created. Neither a GDB server nor a GDB client instance exist at this point.
+
+        Args:
+            pre_connect_hook: Callback function.
+        """
         cls._pre_connect_hook = pre_connect_hook
 
     @classmethod
     def exec_pre_connect_hook(cls) -> None:
         if cls._pre_connect_hook is not None:
             cls._pre_connect_hook()
 
+    @classmethod
+    def set_gdb_pre_connect_hook(cls, gdb_pre_connect_hook: types.FunctionType) -> None:
+        """
+        This hook is called after the GDB client process is instantiated but before the connection to the GDB server is established.
+        This gives the possibility to adapt GDB client connection settings (e.g., "remotetimeout" or "tcp connect-timeout").
+
+        Args:
+            gdb_pre_connect_hook: Callback function.
+        """
+        cls._gdb_pre_connect_hook = gdb_pre_connect_hook
+
+    @classmethod
+    def exec_gdb_pre_connect_hook(cls) -> None:
+        if cls._gdb_pre_connect_hook is not None:
+            cls._gdb_pre_connect_hook()
+
 # ----------------------------------------------------------------------------------------------------------------------
 @singleton
 class Dott(object):
 
-    def __init__(self) -> None:
+    def __init__(self, create_default_target: bool = True) -> None:
+        """
+        Initialize the DOTT framework. Note: This class is a singleton. Hence, repetitive attempts to instantiate this
+        class will return the same singleton instance.
+
+        Args:
+            create_default_target: If True (default) the default target is generated automatically, otherwise this step
+                                   is skipped.
+        """
         self._default_target = None
         self._all_targets: List = []
 
         # initialize logging subsystem
         log_setup()
 
         # read and pre-process configuration file
         DottConf.parse_config()
 
         # the port number used by the internal auto port discovery; discovery starts at config's gdb server port
-        self._next_gdb_srv_port: int = int(DottConf.conf['gdb_server_port'])
+        self._next_gdb_srv_port: int = int(DottConf.get(DottConf.keys.gdb_server_port))
 
         # Hook called before the first debugger connection is made
         DottHooks.exec_pre_connect_hook()
 
-        self._default_target = self.create_target(DottConf.conf['device_name'], DottConf.conf['jlink_serial'])
+        if create_default_target:
+            self._default_target = self.create_target(DottConf())
 
-    def _get_next_srv_port(self, srv_addr: str) -> int:
+    def create_gdb_server(self, device_name: str, jlink_serial: str = None, srv_addr: str = None, srv_port: int = -1) -> 'GdbServer':
         """
-        Find the next triplet of free ("bind-able") TCP ports on the given server IP address.
-        Ports are automatically advanced until a free port triplet is found.
-
+        This method is DEPRECATED and will be removed with the next major release! The parameters passed to this method are already
+        ignored. Instead, the GDB server for the default target (according to the settings in DottConf) is (re-)created.
+        As create_gdb_server() will be deprecated, use dott().target.monitor.create_gdb_server() instead.
         Args:
-            srv_addr: IP address of the server.
+            device_name: Ingores. Taken from default DottDoncf().
+            jlink_serial: Ingored. Taken from default DottDoncf().
+            srv_addr: Ignored. Taken from default DottDoncf().
+            srv_port:  Ignored. Taken from default DottDoncf().
+
         Returns:
-            Returns the first port number of the discovered, free port triplet.
+            GdbServer instance.
         """
-        port = self._next_gdb_srv_port
-        sequentially_free_ports = 0
-        start_port = 0
-
-        while True:
-            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-            try:
-                s.bind((srv_addr, port))
-                sequentially_free_ports += 1
-                if sequentially_free_ports == 1:
-                    start_port = port
-            except socket.error:
-                # log.debug(f'Can not bind port {port} as it is already in use.')
-                sequentially_free_ports = 0
-            finally:
-                s.close()
-
-            if sequentially_free_ports > 2:
-                # JLINK GDB server needs 3 free ports in a row
-                break
-
-            port += 1
-            if port >= 65535:
-                raise DottException(f'Unable do find three (consecutive) free ports for IP {srv_addr}!')
-
-        self._next_gdb_srv_port = start_port + sequentially_free_ports
-        if self._next_gdb_srv_port > 65500:
-            self._next_gdb_srv_port = int(DottConf.conf['gdb_server_port'])
-        return start_port
+        from dottmi.utils import log
+        log.warn('create_gdb_server() will be deprecated in a forthcoming release. Port your code to used dott().target.monitor.create_gdb_server() instead!')
+        return dott().target.monitor.create_gdb_server(DottConf())
 
-    def create_gdb_server(self, device_name: str, jlink_serial: str = None, srv_addr: str = None, srv_port: int = -1) -> 'GdbServer':
+    def create_target(self, dconf: DottConf) -> Target:
         """
-        Factory method to create a new GDB server instance. The following parameters are defined via DottConfig:
-        gdb_server_binary, jlink_interface, device_endianess, jlink_speed, and jlink_server_addr.
+        Creates and retunrs a target object according to the settings of the provided DottConf instance.
 
         Args:
-            device_name: Device name as used by debug monitor to identify corresponding flash loader algorithm.
-            jlink_serial: JLINK serial number (None when only a single JLINK is connected).
-            srv_addr: Server address (None for default).
-            srv_port: Port the server shall listen on (-1 for default).
+            dconf: DottConf instance used to configure the target instance.
+
         Returns:
-            The created GdbServer instance.
+            Target instance configured according to dconf.
         """
-        from dottmi.gdb import GdbServerJLink
-
-        if srv_port == -1:
-            srv_port = int(DottConf.conf['gdb_server_port'])
-
-        if srv_addr is None:
-            srv_addr = DottConf.conf['gdb_server_addr']
-
-        if srv_addr is None:
-            # if gdb server is launched by DOTT, we determine the port ourselves
-            srv_port = self._get_next_srv_port('127.0.0.1')
-
-        gdb_server = GdbServerJLink(DottConf.conf['gdb_server_binary'],
-                                    srv_addr,
-                                    srv_port,
-                                    device_name,
-                                    DottConf.conf['jlink_interface'],
-                                    DottConf.conf['device_endianess'],
-                                    DottConf.conf['jlink_speed'],
-                                    jlink_serial,
-                                    DottConf.conf['jlink_server_addr'],
-                                    DottConf.conf['jlink_script'],
-                                    DottConf.conf['jlink_extconf'])
-
-        return gdb_server
-
-    def create_target(self, device_name: str, jlink_serial: str = None) -> Target:
         from dottmi import target
         from dottmi.gdb import GdbClient
 
-        srv_addr = DottConf.conf['gdb_server_addr']
-
-        gdb_server = self.create_gdb_server(device_name, jlink_serial, srv_addr=srv_addr)
-
-        # start GDB client
-        gdb_client = GdbClient(DottConf.conf['gdb_client_binary'])
-        gdb_client.connect()
+        monitor_type = dconf.get(dconf.keys.monitor_type)
 
-        if DottConf.get('monitor_type') == 'jlink':
+        if monitor_type == 'jlink':
             monitor: Monitor = MonitorJLink()
-        elif DottConf.get('monitor_type') == 'openocd':
+        elif monitor_type == 'openocd':
             monitor: Monitor = MonitorOpenOCD()
+        elif monitor_type == 'custom':
+            try:
+                import importlib
+                monitor_cls = getattr(importlib.import_module(dconf.get(dconf.keys.monitor_module)), dconf.get(dconf.keys.monitor_class))
+                monitor: Monitor = monitor_cls()
+            except:
+                raise DottException(f'Failed to instantiate {dconf.get(dconf.keys.monitor_module)}::{dconf.get(dconf.keys.monitor_class)}') from None
         else:
-            raise DottException(f'Unknown debug monitor type {DottConf.get("monitor_type")}.')
+            raise DottException(f'Unknown debug monitor type {dconf.get(dconf.keys.monitor_type)}.')
+
+        gdb_server: GdbServer = monitor.create_gdb_server(dconf)
+
+        # start GDB client
+        gdb_client = GdbClient(dconf.get(dconf.keys.gdb_client_binary))
+        # Hook called before connection to GDB server is established.
+        DottHooks.exec_gdb_pre_connect_hook()
+        gdb_client.connect()
 
         try:
             # create target instance and set GDB server address
-            target = target.Target(gdb_server, gdb_client, monitor, device_name,  DottConf.get('device_endianess'), DottConf.get('gdb_server_connect_timeout'))
+            target = target.Target(gdb_server, gdb_client, monitor, dconf)
 
         except TimeoutError:
             gdb_client.disconnect()
             gdb_server.shutdown()
             raise DottException('Connection attempt to GDB server timed out. Either GDB server is not running or GDB server is slow.'
                                 'In that case, try to increase DottConf[gdb_server_connect_timeout]') from None
 
         # add target to list of created targets to enable proper cleanup on shutdown
         if target:
             self._all_targets.append(target)
         return target
 
     @property
     def target(self) -> Target:
+        """
+        Returns the default target instances via the Dott singleton which is especially useful for single core systems.
+
+        Returns:
+            The default target instance.
+        """
         return self._default_target
 
     @target.setter
-    def target(self, target: object):
+    def target(self, target: object) -> None:
+        """
+        Allows to set (override) the default target for the Dott singleton.
+
+        Args:
+            target: Target instance to be set as default target.
+        """
         raise ValueError('Target can not be set directly.')
 
     def shutdown(self) -> None:
+        """
+        Calls the disconnect method of the default target and all other targets which were created via the create_target() method.
+        """
         for t in self._all_targets:
             t.disconnect()
         self._all_targets = []
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # For backwards compatibility reasons the Dott() singleton can also be accessed via the all lowercase dott function.
```

## dottmi/dott_conf.py

```diff
@@ -243,23 +243,36 @@
             self._conf["device_name"] = 'unknown'
         log.info(f'Device name:           {self._conf["device_name"]}')
 
         if 'device_endianess' not in self._conf:
             self._conf['device_endianess'] = 'little'
         else:
             if self._conf['device_endianess'] != 'little' and self._conf['device_endianess'] != 'big':
-                raise ValueError(f'device_endianess in {dott_ini} should be either "little" or "big".')
+                raise ValueError(f'device_endianess should be either "little" or "big".')
         log.info(f'Device endianess:      {self._conf["device_endianess"]}')
 
         if 'monitor_type' not in self._conf:
             self._conf['monitor_type'] = 'jlink'
         else:
-            self._conf['monitor_type'] = self._conf['monitor_type'].strip().lower()
             if self._conf['monitor_type'].strip().lower() not in ('jlink', 'openocd'):
-                raise ValueError(f'Unknown monitor type (supported: "jlink", "openocd"')
+
+                # Check if monitor type is of format my.module.path.MyMonitorClass; if yes populate monitor_module and monitor_class confif values
+                # In this case, monitor_type is set to 'custom'.
+                if '.' in self._conf['monitor_type'].strip():
+                    parts = self._conf['monitor_type'].split('.')
+                    if len(parts) > 0:
+                        self._conf['monitor_class'] = parts[-1]
+                    if len(parts) > 1:
+                        self._conf['monitor_module'] = '.'.join(parts[0:-1])
+                    else:
+                        self._conf['monitor_module'] = None
+                    self._conf['monitor_type'] = 'custom'
+
+                else:
+                    raise ValueError(f'Unknown monitor type (supported: "jlink", "openocd" or "my.module.path.MyMonitorClass"')
         log.info(f'Selected monitor type: {self._conf["monitor_type"].upper()}')
 
         # determine J-Link path and version
         jlink_path, jlink_lib_name, jlink_version = self._get_jlink_path(jlink_default_path, jlink_lib_name, jlink_gdb_server_binary)
         self._conf["jlink_path"] = jlink_path
         self._conf["jlink_lib_name"] = jlink_lib_name
         self._conf["jlink_version"] = jlink_version
@@ -406,14 +419,56 @@
 
 # ----------------------------------------------------------------------------------------------------------------------
 # Global, static DottConf that is used as default for single-target test environments. This was the standard way to
 # configure DOTT prior to the introduction of the non-Static DottConfExt.
 class DottConf(object):
     conf = DottConfExt()
 
+    class keys(object):
+        # GDB server connection parameters
+        gdb_client_binary: str = 'gdb_client_binary'
+        gdb_server_addr: str = 'gdb_server_addr'
+        gdb_server_port: str = 'gdb_server_port'
+        gdb_server_binary: str = 'gdb_server_binary'
+        gdb_server_connect_timeout: str = 'gdb_server_connect_timeout'
+
+        # Debug monitor variants
+        monitor_type: str = 'monitor_type'
+        monitor_module: str = 'monitor_module'
+        monitor_class: str = 'monitor_class'
+
+        # Device properties
+        device_name: str = 'device_name'
+        device_endianess: str = 'device_endianess'
+
+        # JLINK-specific settings
+        jlink_interface: str = 'jlink_interface'
+        jlink_speed: str = 'jlink_speed'
+        jlink_serial: str = 'jlink_serial'
+        jlink_server_addr: str = 'jlink_server_addr'
+        jlink_script: str = 'jlink_script'
+        jlink_extconf: str = 'jlink_extconf'
+
+        # Application related settings
+        bl_symbol_elf: str = 'bl_symbol_elf'
+        bl_load_elf: str = 'bl_load_elf'
+        bl_symbol_addr: str = 'bl_symbol_addr'
+        app_load_elf: str = 'app_load_elf'
+        app_symbol_elf: str = 'app_symbol_elf'
+
+        # Memory allocation configuraiton
+        on_target_mem_model: str = 'on_target_mem_model'
+        on_target_mem_prestack_alloc_size: str = 'on_target_mem_prestack_alloc_size'
+        on_target_mem_prestack_alloc_location: str = 'on_target_mem_prestack_alloc_location'
+        on_target_mem_prestack_halt_location: str = 'on_target_mem_prestack_halt_location'
+        on_target_mem_prestack_total_stack_size: str = 'on_target_mem_prestack_total_stack_size'
+
+        # Timeout settings
+        fixture_timeout: str = 'fixture_timeout'
+
     @staticmethod
     def set(key: str, val: str) -> None:
         DottConf.conf.set(key, val)
 
     @staticmethod
     def set_runtime_if_unset(dott_runtime_path: str) -> None:
         DottConf.conf.set_runtime_if_unset(dott_runtime_path)
@@ -421,7 +476,13 @@
     @staticmethod
     def get(key: str):
         return DottConf.conf.get(key)
 
     @staticmethod
     def parse_config(force_reparse: bool = False) -> None:
         return DottConf.conf.parse_config(force_reparse)
+
+    @staticmethod
+    def log(key, val):
+        key += ':'
+        log.info(f'{key:25} {val}')
+
```

## dottmi/fixtures.py

```diff
@@ -43,29 +43,28 @@
         pytest.exit('Aborting test execution.')
 
     try:
         if not silent:
             log.info(f'Triggering download of APP to {name}...')
 
         # optionally load bootloader binary (load elf ONLY - symbols are loaded after the app)
-        bl_load_elf = DottConf.get('bl_load_elf')
+        bl_load_elf = dt.dconf.get(dt.dconf.keys.bl_load_elf)
         if bl_load_elf is not None:
             dt.load(bl_load_elf, None, enable_flash=load_to_flash)
 
         # load application binaries
-        app_load_elf = DottConf.get('app_load_elf')
-        app_symbol_elf = DottConf.get('app_symbol_elf')
+        app_load_elf = dt.dconf.get(dt.dconf.keys.app_load_elf)
+        app_symbol_elf = dt.dconf.get(dt.dconf.keys.app_symbol_elf)
         if app_load_elf is not None:
             dt.load(app_load_elf, app_symbol_elf, enable_flash=load_to_flash)
 
         # add bootloader symbol file; note: it is important to this 'add' so after doing target.load() with symbol elf.
-        bl_symbol_elf = DottConf.get('bl_symbol_elf')
+        bl_symbol_elf = dt.dconf.get(dt.dconf.keys.bl_symbol_elf)
         if bl_symbol_elf is not None:
-            dt.cli_exec('add-symbol-file %s 0x%x' % (DottConf.get('bl_symbol_elf'),
-                                                                int(DottConf.get('bl_symbol_addr'))))
+            dt.cli_exec('add-symbol-file %s 0x%x' % bl_symbol_elf, int(dt.dconf.get(dt.dconf.keys.bl_symbol_addr)))
 
         # disable FLASH breakpoints
         dt.monitor.enable_flash_breakpoints(False)
     except Exception as ex:
         log.exception(str(ex))
         pytest.exit('Unhandled exception target download. See trace above.')
 
@@ -117,22 +116,22 @@
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 def _target_mem_init_noalloc(dt: Target = None) -> None:
     dt = dott().target if dt is None else dt
 
     # print mem model override information
-    if DottConf.conf['on_target_mem_model'] != TargetMemModel.NOALLOC:
+    if dt.dconf.get(dt.dconf.keys.on_target_mem_model) != TargetMemModel.NOALLOC:
         log.info(f'Overriding std. target mem model with {TargetMemModel.NOALLOC}.')
 
     # define the initial test breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint('main')
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
+        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn('main not reached. Target halted after timeout at PC: 0x%x' % dt.eval('$pc'))
 
     # remove test hook breakpoint
     bp.delete()
 
@@ -143,22 +142,22 @@
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 def _target_mem_init_testhook(dt: Target = None) -> None:
     dt = dott().target if dt is None else dt
 
     # print mem model override information
-    if DottConf.conf['on_target_mem_model'] != TargetMemModel.TESTHOOK:
+    if dt.dconf.get(dt.dconf.keys.on_target_mem_model) != TargetMemModel.TESTHOOK:
         log.info(f'Overriding std. target mem model with {TargetMemModel.TESTHOOK}.')
 
     # define the initial test breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint('DOTT_test_hook_chained')
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
+        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn('DOTT_test_hook_chained not reached. Target halted after timeout at PC: 0x%x' % dt.eval('$pc'))
 
     # remove test hook breakpoint
     bp.delete()
 
@@ -167,39 +166,38 @@
 
     yield
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 def _target_mem_init_prestack(mem_model_args: Dict = None, dt: Target = None) -> None:
     dt = dott().target if dt is None else dt
-    canary_word = 0xabad1dea
     override = False
 
     # override default value of on-target memory size
-    target_mem_num_bytes: int = DottConf.conf['on_target_mem_prestack_alloc_size']
+    target_mem_num_bytes: int = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_alloc_size)
     if mem_model_args is not None and 'alloc_size' in mem_model_args:
         target_mem_num_bytes = int(mem_model_args['alloc_size'])
         override = True
     if target_mem_num_bytes % 4 != 0:
         raise DottException('The num_bytes argument for prestack memory allocation shall be a multiple of 4!')
 
     # override default value for target alloc location
-    alloc_location: str = DottConf.conf['on_target_mem_prestack_alloc_location']
+    alloc_location: str = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_alloc_location)
     if mem_model_args is not None and 'alloc_location' in mem_model_args:
         alloc_location = str(mem_model_args['alloc_location'])
         override = True
 
     # override default value for target halt location
-    halt_location: str = DottConf.conf['on_target_mem_prestack_halt_location']
+    halt_location: str = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_halt_location)
     if mem_model_args is not None and 'halt_location' in mem_model_args:
         halt_location = str(mem_model_args['halt_location'])
         override = True
 
     # override default value for target total_stack_size
-    total_stack_num_bytes: int = DottConf.conf['on_target_mem_prestack_total_stack_size']
+    total_stack_num_bytes: int = dt.dconf.get(dt.dconf.keys.on_target_mem_prestack_total_stack_size)
     if mem_model_args is not None and 'total_stack_size' in mem_model_args:
         total_stack_num_bytes = mem_model_args['total_stack_size']
         override = True
 
     # print mem model override information
     if override:
         log.info(f'Overriding std. target mem model with {TargetMemModel.PRESTACK}'
@@ -208,15 +206,15 @@
                  f'halt @{halt_location}; '
                  f'total stack: {total_stack_num_bytes if total_stack_num_bytes is not None else "unknown"}).')
 
     # define the initial allocation breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint(alloc_location)
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
+        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn(f'{alloc_location} not reached. Target halted after timeout at PC: 0x{dt.eval("$pc"):x}')
     bp.delete()
 
     # adjust the stack pointer (i.e., steal the requested amount of on-target memory)
     dt.eval(f'$sp -= {target_mem_num_bytes}')
@@ -225,15 +223,15 @@
     target_mem_stack_start = dt.eval('$sp')
     dt.mem = TargetMem(dt, target_mem_stack_start, target_mem_num_bytes)
 
     # define the halt breakpoint, start the target and wait until the breakpoint is reached
     bp = HaltPoint(halt_location)
     dt.cont()
     try:
-        bp.wait_complete(timeout=float(DottConf.get('fixture_timeout')))
+        bp.wait_complete(timeout=float(dt.dconf.get(dt.dconf.keys.fixture_timeout)))
     except Exception:
         dt.halt()
         log.warn(f'{halt_location} not reached. Target halted after timeout at PC: 0x{dt.eval("$pc"):x}')
     bp.delete()
 
     # pass control to test
     yield
@@ -254,15 +252,15 @@
         dt.eval(f'$pc = *{pc}')
 
     # if a callback was specified give user code a chance to do early device initialization
     if setup_cb is not None:
         setup_cb()
 
     # set on-target memory allocation model either from config or from pytest marker
-    mem_model: TargetMemModel = DottConf.conf['on_target_mem_model']
+    mem_model: TargetMemModel = dt.dconf.get(dt.dconf.keys.on_target_mem_model)
     mem_model_args = None
     if 'pytestmark' in request.keywords:
         for m in request.keywords['pytestmark']:
             if m.name == 'dott_mem' and 'model' in m.kwargs:
                 mem_model = m.kwargs['model']
                 mem_model_args = m.kwargs
                 break
@@ -309,15 +307,15 @@
 @pytest.fixture(scope='function')
 def live_access():
     """
     This fixture provides access to target memory while the target is running.
 
     Returns: Instance of TargetLive which provides memory read/write functions while target is running.
     """
-    live = TargetDirect(DottConf.conf['device_name'])
+    live = TargetDirect()
     yield live
     live.disconnect()
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # DOTT-internal fixture which performs DOTT related cleanup on a per-function basis
 @pytest.fixture(scope='function', autouse=True)
```

## dottmi/gdb.py

```diff
@@ -53,14 +53,31 @@
         pass
 
     @abstractmethod
     def shutdown(self):
         pass
 
 
+class GdbServerExternal(GdbServer):
+    """
+    This class represents an external (typically remote) GDB server instance. It is not started or managed by DOTT.
+    Management of this GDB server instance is handled externally.
+    """
+    def __init__(self, addr, port):
+        super().__init__(addr, port)
+
+    def _launch(self, device_name: str):
+        # remote GDB server instances are not managed by DOTT
+        pass
+
+    def shutdown(self):
+        # remote GDB server instances are not managed by DOTT
+        pass
+
+
 class GdbServerJLink(GdbServer):
     def __init__(self, gdb_svr_binary: str, addr: str, port: int, device_name: str, interface: str, endian: str,
                  speed: str = '15000', serial_number: str = None, jlink_addr: str = None, jlink_script: str = None,
                  jlink_extconf: str = None):
         super().__init__(addr, port)
         self._srv_binary: str = gdb_svr_binary
         self._srv_process = None
```

## dottmi/monitor.py

```diff
@@ -16,14 +16,18 @@
 ###############################################################################
 
 from __future__ import annotations  # available from Python 3.7 onwards, default from Python 3.11 onwards
 
 import abc
 import typing
 
+from dottmi import utils
+from dottmi.dott_conf import DottConf
+from dottmi.gdb import GdbServer, GdbServerExternal, GdbServerJLink
+
 if typing.TYPE_CHECKING:
     from dottmi.target import Target
 
 from dottmi.dottexceptions import DottException
 
 
 class Monitor(abc.ABC):
@@ -67,16 +71,61 @@
     def reset(self) -> None:
         pass
 
     @abc.abstractmethod
     def xpsr_name(self) -> str:
         pass
 
+    @abc.abstractmethod
+    def _instantiate_gdb_server(self, dconf: DottConf):
+        pass
+
+    def create_gdb_server(self, dconf: DottConf) -> GdbServer:
+        """
+        Create new GDB server instance. If the configuration contains a gdb server address it is assumed that a GDB server is already running at this
+        address and no attempt is made to launch a GDB server instance. Otherwise, it is tried to launch a gdb server instance corresponding to the
+        monitor type.
+
+        Args:
+            dconf: Dott configuration database.
+
+        Returns: GDB server instance.
+        """
+        addr = dconf.get(dconf.keys.gdb_server_addr)
+        port = dconf.get(dconf.keys.gdb_server_port)
+        if addr is not None:
+            return GdbServerExternal(addr, port)
+        else:
+            return self._instantiate_gdb_server(dconf)
+
 
 class MonitorJLink(Monitor):
+    def _instantiate_gdb_server(self, dconf: DottConf):
+        srv_addr = dconf.get(dconf.keys.gdb_server_addr)
+
+        if srv_addr is not None:
+            srv_port = dconf.get(dconf.keys.gdb_server_port)
+        else:
+            # if gdb server is launched by DOTT, we determine the port ourselves
+            srv_port = utils.Network.get_next_srv_port('127.0.0.1')
+
+        return GdbServerJLink(
+            dconf.get(dconf.keys.gdb_server_binary),
+            srv_addr,
+            srv_port,
+            dconf.get(dconf.keys.device_name),
+            dconf.get(dconf.keys.jlink_interface),
+            dconf.get(dconf.keys.device_endianess),
+            dconf.get(dconf.keys.jlink_speed),
+            dconf.get(dconf.keys.jlink_serial),
+            dconf.get(dconf.keys.jlink_server_addr),
+            dconf.get(dconf.keys.jlink_script),
+            dconf.get(dconf.keys.jlink_extconf)
+        )
+
     def set_flash_device(self, device_name: str) -> None:
         self.run_cmd(f'flash device {device_name}')
 
     def enable_flash_download(self, enable: bool) -> None:
         flag: int = 1 if enable else 0
         self.run_cmd(f'flash download={flag}')
 
@@ -94,14 +143,18 @@
         self.run_cmd('reset')
 
     def xpsr_name(self) -> str:
         return 'xpsr'
 
 
 class MonitorOpenOCD(Monitor):
+    def _instantiate_gdb_server(self, dconf: DottConf):
+        raise NotImplementedError('Automatic starting of OpenOCD GDB server is not supported. Provide "gdb_server_addr" and "gdb_server_addr" '
+                                  'config parameters to connect to an externally started/remote GDB server instance.')
+
     def set_flash_device(self, device_name: str) -> None:
         # For OpenOCD the flash device name is ignored for now
         pass
 
     def enable_flash_download(self, enable: bool) -> None:
         flag: str = 'enable' if enable else 'disable'
         self.run_cmd(f'gdb_flash_program {flag}')
```

## dottmi/pylinkdott.py

```diff
@@ -54,15 +54,16 @@
         is to ensure that pylink and gdb are using the same JLINK installation (and hence the same JLinkDevices.xml).
         """
         yield os.path.join(DottConf.get('jlink_path'), DottConf.get('jlink_lib_name'))
 
 
 # -------------------------------------------------------------------------------------------------
 class TargetDirect(object):
-    def __init__(self, device_name: str):
+    def __init__(self):
+        device_name: str = DottConf.get('device_name')
         jlink_ip_addr = DottConf.get('jlink_server_addr')
         jlink_port = DottConf.get('jlink_server_port')
         jlink_serial = DottConf.get('jlink_serial')
 
         jlink_addr_port = f'{jlink_ip_addr}:{jlink_port}' if jlink_ip_addr is not None else None
 
         self._jlink = _JlinkDott()
```

## dottmi/target.py

```diff
@@ -21,14 +21,16 @@
 import logging
 import os
 import threading
 import time
 from pathlib import Path, PurePosixPath
 from typing import Dict, Union, List, TYPE_CHECKING
 
+from dottmi.dott_conf import DottConf
+
 if TYPE_CHECKING:
     from dottmi.target_mem import TargetMem
 
 from dottmi.breakpointhandler import BreakpointHandler
 from dottmi.dottexceptions import DottException
 from dottmi.gdb import GdbClient, GdbServer
 from dottmi.gdb_mi import NotifySubscriber
@@ -38,26 +40,27 @@
 from dottmi.utils import cast_str, log
 
 logging.basicConfig(level=logging.DEBUG)
 
 
 class Target(NotifySubscriber):
 
-    def __init__(self, gdb_server: GdbServer, gdb_client: GdbClient, monitor: Monitor, device_name: str, device_endianes: str, auto_connect: bool = True, connect_timeout: float = 5) -> None:
+    def __init__(self, gdb_server: GdbServer, gdb_client: GdbClient, monitor: Monitor, dconf: DottConf, auto_connect: bool = True) -> None:
         """
         Creates a target which represents a target device. It requires both a GDB server (either started by DOTT
         or started externally) and a GDB client instance used to connect to the GDB server.
         If auto_connect is True (the default) the connected from GDB client to GDB server is automatically established.
         """
         NotifySubscriber.__init__(self)
+        self._dconf: DottConf = dconf
         self._load_elf_file_name = None
         self._symbol_elf_file_name = None
 
-        self._device_name: str = device_name
-        self._device_endianes: str = device_endianes
+        self._device_name: str = dconf.get(dconf.keys.device_name)
+        self._device_endianess: str = dconf.get(dconf.keys.device_endianess)
         self._gdb_client: GdbClient = gdb_client
         self._gdb_server: GdbServer = gdb_server
         self._monitor: Monitor = monitor
         self._monitor.set_target(self)
 
         # condition variable and status flag used to implement helpers
         # allowing callers to wait until target is stopped or running
@@ -81,15 +84,15 @@
         self._gdb_client.gdb_mi.response_handler.notify_subscribe(self, 'stopped', None)
         self._gdb_client.gdb_mi.response_handler.notify_subscribe(self, 'running', None)
 
         # delay after device startup / continue
         self._startup_delay: float = 0.0
 
         # timeout used when connection to remote GDB server ("target remote")
-        self._connect_timeout: float = connect_timeout
+        self._connect_timeout: float = float(dconf.get(dconf.keys.gdb_server_connect_timeout))
 
         # flag which indicates if gdb client is attached to target
         self._gdb_client_is_connected = False
 
         if auto_connect:
             try:
                 self.gdb_client_connect()
@@ -181,15 +184,19 @@
             self._gdb_server.shutdown()
             self._gdb_server = None
 
     ###############################################################################################
     # Properties
 
     @property
-    def gdb_client(self):
+    def dconf(self) -> DottConf:
+        return self._dconf
+
+    @property
+    def gdb_client(self) -> GdbClient:
         return self._gdb_client
 
     @property
     def gdb_client_is_connected(self) -> bool:
         return self._gdb_client_is_connected
 
     @property
@@ -199,30 +206,30 @@
     @property
     def mem(self) -> TargetMem:
         if self._mem is None:
             raise DottException('No on-target memory access model set at this point!')
         return self._mem
 
     @mem.setter
-    def mem(self, target_mem: TargetMem):
+    def mem(self, target_mem: TargetMem) -> None:
         if not isinstance(target_mem, TargetMem):
             raise DottException('mem has to be an instance of TargetMem')
         self._mem = target_mem
 
     @property
     def monitor(self) -> Monitor:
         return self._monitor
 
     @property
     def bp_handler(self) -> BreakpointHandler:
         return self._bp_handler
 
     @property
     def byte_order(self) -> str:
-        return self._device_endianes
+        return self._device_endianess
 
     @property
     def startup_delay(self) -> float:
         return self._startup_delay
 
     @startup_delay.setter
     def startup_delay(self, delay: float):
```

## dottmi/utils.py

```diff
@@ -17,14 +17,16 @@
 ###############################################################################
 
 import logging
 import struct
 import threading
 from typing import Union, List
 
+from dottmi.dottexceptions import DottException
+
 log = logging.getLogger('DOTT')
 
 
 def log_setup() -> None:
     # suppress log debug/info from pygdbmi
     logger = logging.getLogger('pygdbmi')
     logger.setLevel(logging.ERROR)
@@ -464,7 +466,56 @@
             while key not in self._items:
                 new_item = self._cv.wait(timeout)
                 if not new_item:
                     # timeout hit
                     raise TimeoutError
 
             return self._items.pop(key)
+
+
+class Network(object):
+
+    _next_gdb_srv_port: int = 2331
+
+    @classmethod
+    def get_next_srv_port(cls, srv_addr: str) -> int:
+        """
+        Find the next triplet of free ("bind-able") TCP ports on the given server IP address.
+        Ports are automatically advanced until a free port triplet is found.
+
+        Args:
+            srv_addr: IP address of the server.
+        Returns:
+            Returns the first port number of the discovered, free port triplet.
+        """
+        import socket
+
+        port = cls._next_gdb_srv_port
+        sequentially_free_ports = 0
+        start_port = 0
+
+        while True:
+            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+            try:
+                s.bind((srv_addr, port))
+                sequentially_free_ports += 1
+                if sequentially_free_ports == 1:
+                    start_port = port
+            except socket.error:
+                # log.debug(f'Can not bind port {port} as it is already in use.')
+                sequentially_free_ports = 0
+            finally:
+                s.close()
+
+            if sequentially_free_ports > 2:
+                # found 3 free ports in a row
+                break
+
+            port += 1
+            if port >= 65535:
+                raise DottException(f'Unable do find three (consecutive) free ports for IP {srv_addr}!')
+
+        cls._next_gdb_srv_port = start_port + sequentially_free_ports
+        if cls._next_gdb_srv_port > 65500:
+            # wrap around for next invocation
+            cls._next_gdb_srv_port = 2331
+        return start_port
```

## Comparing `dott_ng-1.8.1.dist-info/LICENSE.txt` & `dott_ng-1.9.0.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `dott_ng-1.8.1.dist-info/METADATA` & `dott_ng-1.9.0.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dott-ng
-Version: 1.8.1
+Version: 1.9.0
 Summary: Debugger-based on Target Testing (DOTT)
 Home-page: https://github.com/tw-ghub/dott-ng
 Author: Thomas Winkler
 Author-email: thomas.winkler@gmail.com
 Classifier: Environment :: Console
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Topic :: Software Development :: Testing
```

## Comparing `dott_ng-1.8.1.dist-info/RECORD` & `dott_ng-1.9.0.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 dottmi/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dottmi/breakpoint.py,sha256=yGOoCKAXwqdfO-UDhC73tuSZpOltkXA_UycQU2PDX4Q,15481
 dottmi/breakpointhandler.py,sha256=AqIL7bee6cYc6af0Nj-faOEWinOe_nLAcUO-DksYodI,2509
-dottmi/dott.py,sha256=b1DUFskXVMI53q1F9AvMUvr5Ksk9o0rJa8ReXytvb9A,8158
-dottmi/dott_conf.py,sha256=ye8KGqOBLYysv6sK-zApbTpUEvbU-lf-JnyERMiE_P0,22402
+dottmi/dott.py,sha256=c9GL_emqJ_UzOxfZTqQHsicXGYS8mU2cR2y0V0gxxYY,8552
+dottmi/dott_conf.py,sha256=oD_-6Ye5GcWrVI9KrMsNrt0lQoGOdI9UX1oCYkPflDc,24977
 dottmi/dottexceptions.py,sha256=6rDpCEzodl_lXL4Zx8v3XO46hDiIUNPzjWvMDL1PN0s,924
-dottmi/fixtures.py,sha256=AGKhoV0wY3b7Md2pDt1YJ8GhYiLwXcVwoRls5G2WL9k,15638
-dottmi/gdb.py,sha256=nxG-VjS78692-JIRoTUwX7LVEtYgwhPSke0D_p679Q8,10377
+dottmi/fixtures.py,sha256=LC-K0pybi5nPi4QV-95rwKOrcKf3-2l2dDBG-XBDns4,15682
+dottmi/gdb.py,sha256=oKldnubxmuN7mZk4CXVbFQmiKx5myRQAy9Qln9tbgtg,10920
 dottmi/gdb_cmds.py,sha256=kB_LDdvGaxUIt-kMtdVVv0OgCVQocPVc1b0y8mfxFoI,8411
 dottmi/gdb_mi.py,sha256=bEC9iZUhiJ4t_yU6BTx5cPj4hZE5XsJzNVAFqNJTMKY,15965
 dottmi/gdb_shared.py,sha256=ivDsqIJmO7ToHcux4gQKbQp2f2rMy8mmcAtIxfbuE1A,3312
 dottmi/gdbcontrollerdott.py,sha256=_pm6jBJdMLq87AG6_nDZTQI5BBRoVKT4ij1YOXXnEMA,1643
-dottmi/monitor.py,sha256=XukEsUZXcFytDDqQeszrnAVnx8vh7j3vCossrju5SB0,3980
-dottmi/pylinkdott.py,sha256=e9hKPNT5Hirbfbs6_LQOIhet7_xB8eDwNP8k9DV96XA,4717
+dottmi/monitor.py,sha256=tiQIe9ORdBNSDRPiJE0ijaiqblfKPs3BTrvF-Ee74F8,6247
+dottmi/pylinkdott.py,sha256=wu_QNDej3GqkMZK07UokDdcmvRU7yz-ZX7M3PC7PSRg,4755
 dottmi/symbols.py,sha256=63yUpDuf9Q4PPub2BN6YLHvGnygixuiV5M7lm7Kuemg,1245
-dottmi/target.py,sha256=W9Gcu6wAmHNTg1xjUFNpZPIwoKT_mZ5erZ6I5Gy3COM,23743
+dottmi/target.py,sha256=ZkxGcgQPnIKysqhJgS14uqmxu4kn879O3z2KmEOX21w,23959
 dottmi/target_mem.py,sha256=0sqEP7ZOrzA8OdRDPa0PvYfhZjFEfbTGaHuNrhDbEzw,32809
-dottmi/utils.py,sha256=9G_7PvkCS0G8QiET6Wz0JNNS4lEBbNsCqMigOozSDak,18434
-dott_ng-1.8.1.dist-info/LICENSE.txt,sha256=SbvpEU5JIU3yzMMkyzrI0dGqHDoJR_lMKGdl6GZHsy4,11558
-dott_ng-1.8.1.dist-info/METADATA,sha256=0l86RBMaZy0NPuRebN2yf-BMKYsTj-AaWg-evOThDlE,890
-dott_ng-1.8.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-dott_ng-1.8.1.dist-info/top_level.txt,sha256=zHszyamN3VN0AAzMMo7e00JdWgdlNPvenbbPAsRt-Kc,7
-dott_ng-1.8.1.dist-info/RECORD,,
+dottmi/utils.py,sha256=tKQgxS6MhQviWDLieYzIpKVG4qbrbvS0N0Udo6kDcDk,20124
+dott_ng-1.9.0.dist-info/LICENSE.txt,sha256=SbvpEU5JIU3yzMMkyzrI0dGqHDoJR_lMKGdl6GZHsy4,11558
+dott_ng-1.9.0.dist-info/METADATA,sha256=qfcFffXhymPsX63ANYx2jfwcowlobyuQS3Pn6v9nnzg,890
+dott_ng-1.9.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+dott_ng-1.9.0.dist-info/top_level.txt,sha256=zHszyamN3VN0AAzMMo7e00JdWgdlNPvenbbPAsRt-Kc,7
+dott_ng-1.9.0.dist-info/RECORD,,
```

