# Comparing `tmp/neo3-boa-0.9.0.tar.gz` & `tmp/neo3-boa-1.0.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/neo3-boa-0.9.0.tar", last modified: Mon Aug  2 17:17:41 2021, max compression
+gzip compressed data, was "neo3-boa-1.0.0.tar", last modified: Mon Jul 10 19:49:54 2023, max compression
```

## Comparing `neo3-boa-0.9.0.tar` & `neo3-boa-1.0.0.tar`

### file list

```diff
@@ -1,693 +1,820 @@
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.200007 neo3-boa-0.9.0/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4186 2021-08-02 17:17:41.200007 neo3-boa-0.9.0/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2577 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/README.rst
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.116007 neo3-boa-0.9.0/boa3/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      116 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.116007 neo3-boa-0.9.0/boa3/analyser/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5887 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/analyser.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8668 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/astanalyser.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    13946 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/astoptimizer.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4571 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/builtinfunctioncallanalyser.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2853 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/constructanalyser.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4259 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/importanalyser.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.116007 neo3-boa-0.9.0/boa3/analyser/model/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/model/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      797 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/model/functionarguments.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/analyser/model/optimizer/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1163 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/model/optimizer/Operation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2981 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/model/optimizer/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      856 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/model/symbolscope.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    44188 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/moduleanalyser.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/analyser/supportedstandard/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      182 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/supportedstandard/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3618 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/supportedstandard/standardanalyser.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    63712 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/analyser/typeanalyser.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1460 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/boa3.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2809 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      945 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/contract/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      435 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/blockchain/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1968 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/blockchain/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1490 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/blockchain/block.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1359 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/blockchain/transaction.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3505 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/contract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       67 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/contract/callflagstype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      904 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/contract/contract.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6117 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/contract/contractmanifest.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/crypto/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2922 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/crypto/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/iterator/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      641 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/iterator/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/json/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      721 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/json/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/oracle/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1911 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/oracle/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       92 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/oracle/oracleresponsecode.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/policy/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      885 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/policy/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/role/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      430 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/role/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       64 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/role/roletype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/runtime/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3180 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/runtime/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      515 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/runtime/notification.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       71 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/runtime/triggertype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/stdlib/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3758 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/stdlib/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/interop/storage/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2387 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/storage/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       71 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/storage/findoptions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      894 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/storage/storagecontext.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1291 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/interop/storage/storagemap.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/builtin/type/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      577 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/builtin/type/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      865 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/cli.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/compiler/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.120007 neo3-boa-0.9.0/boa3/compiler/codegenerator/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      711 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/codegenerator/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    62848 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/codegenerator/codegenerator.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    29755 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/codegenerator/codegeneratorvisitor.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4172 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/codegenerator/initstatementsvisitor.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2509 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/codegenerator/stackmemento.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    11609 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/codegenerator/vmcodemapping.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3484 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/compiler.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17295 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/compiler/filegenerator.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1054 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/constants.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      278 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/env.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.124007 neo3-boa-0.9.0/boa3/exception/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10819 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/exception/CompilerError.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3505 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/exception/CompilerWarning.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      180 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/exception/InvalidPathException.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       46 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/exception/NotLoadedException.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/exception/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.124007 neo3-boa-0.9.0/boa3/helpers/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      368 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/helpers/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.124007 neo3-boa-0.9.0/boa3/model/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      153 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1651 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/attribute.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.124007 neo3-boa-0.9.0/boa3/model/builtin/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6886 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/builtin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1074 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/builtincallable.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      374 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/builtinproperty.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.124007 neo3-boa-0.9.0/boa3/model/builtin/classmethod/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1507 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2654 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/appendmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2299 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/clearmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2131 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/countmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5279 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/countsequencemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8928 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/countstrmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3568 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/extendmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4043 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/insertmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1794 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/mapkeysmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1804 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/mapvaluesmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3537 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/popmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3022 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/removemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1671 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/reversemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2459 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/toboolmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3289 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/tobytesmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2446 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/tointmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2446 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/classmethod/tostrmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.128007 neo3-boa-0.9.0/boa3/model/builtin/contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      310 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/contract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      689 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/contract/abortmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      702 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/contract/nep17transferevent.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      540 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/contract/nep5transferevent.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.128007 neo3-boa-0.9.0/boa3/model/builtin/decorator/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/decorator/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      884 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/decorator/builtindecorator.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      372 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/decorator/metadatadecorator.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      368 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/decorator/publicdecorator.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.128007 neo3-boa-0.9.0/boa3/model/builtin/internal/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/internal/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2308 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/internal/innerdeploymethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      855 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/internal/internalmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.128007 neo3-boa-0.9.0/boa3/model/builtin/interop/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.128007 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1250 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3616 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/blocktype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      728 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/currenthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      689 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/currentindexmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      734 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/getblockmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      679 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/getcontractmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      716 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/getcurrentheightmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      910 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/gettransactionfromblockmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      573 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/gettransactionheightmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      633 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/gettransactionmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3450 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/transactiontype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.128007 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1400 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1612 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/callflagstype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1995 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/callmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1440 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1809 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractabitype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1717 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1521 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractgrouptype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1844 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1993 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1671 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1884 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractparametertype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1766 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1516 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2971 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contracttype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      847 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/createmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      776 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/createmultisigaccountmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      662 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/createstandardaccountmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      447 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/destroymethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      516 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getcallflagsmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1185 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getgasscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      488 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getminimumdeploymentfeemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1185 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getneoscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      739 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/contract/updatemethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      943 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      699 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/checkmultisigmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      624 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/checksigmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      857 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/hash160method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      853 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/hash256method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      472 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/ripemd160method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      462 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/sha256method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1116 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/verifywithecdsasecp256k1.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1116 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/verifywithecdsasecp256r1.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    15716 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/interop.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1011 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/interopevent.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      544 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/interopinterfacetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1689 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/interopmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      213 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1772 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/getiteratorvalue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1466 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/iteratorinitmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      551 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/iteratornextmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3019 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/iteratortype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/json/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      255 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/json/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      485 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/json/jsondeserializemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      479 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/json/jsonserializemethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/ContractManagement/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      133 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/ContractManagement/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      679 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1327 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/CryptoLib/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      105 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/CryptoLib/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      644 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1289 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.132007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Ledger/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Ledger/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1275 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      649 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Ledger/ledgermethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Oracle/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Oracle/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1251 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      629 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Oracle/oraclemethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/PolicyContract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      117 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/PolicyContract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1291 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      673 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/RoleManagement/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      117 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/RoleManagement/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1295 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      659 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/StdLib/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/StdLib/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1254 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/StdLib/getstdlibscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      629 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      412 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1927 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/nativecontractmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      237 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      590 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oraclegetpricemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1016 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oraclerequestmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1591 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oracleresponsecodetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1711 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oracletype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/policy/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      496 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/policy/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      479 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/policy/getexecfeefactormethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      470 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/policy/getfeeperbytemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      475 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/policy/getstoragepricemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      600 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/policy/isblockedmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.136007 neo3-boa-0.9.0/boa3/model/builtin/interop/role/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      234 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/role/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      777 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/role/getdesignatedbyrolemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1418 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/role/roletype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.140007 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2128 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      456 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/burngasmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      860 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/checkwitnessmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      679 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getblocktimemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      791 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getcallingscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      779 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getentryscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      803 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getexecutingscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      681 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getgasleftmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      744 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getinvocationcountermethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      439 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getnetworkmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1673 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getnotificationsmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      685 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getplatformmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      436 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getrandommethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      495 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/gettriggermethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      447 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/logmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2757 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/notificationtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1063 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/notifymethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      726 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/scriptcontainermethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1669 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/triggertype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.144007 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1420 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      630 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/atoimethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      492 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/base58checkdecodemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      492 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/base58checkencodemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      476 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/base58decodemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      476 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/base58encodemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      476 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/base64decodemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      476 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/base64encodemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      473 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/deserializemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      595 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/itoamethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      585 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/memorycomparemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1109 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/memorysearchmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      467 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/serializemethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.144007 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1103 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1682 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/findoptionstype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.144007 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       51 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      554 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1340 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1936 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/storagecontexttype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3839 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagedeletemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4443 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagefindmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      574 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagegetcontextmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4002 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagegetmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      592 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagegetreadonlycontextmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.148007 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       43 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1444 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1436 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemapgetmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1777 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemapputmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3953 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemaptype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3891 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storageputmethod.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.152007 neo3-boa-0.9.0/boa3/model/builtin/method/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1608 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      720 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/absmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      842 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/builtinevent.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     6146 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/builtinmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2699 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/bytearraymethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1520 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/createeventmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3117 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/ecpointmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2334 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/exceptionmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      687 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/exitmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5409 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/isinstancemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1693 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/lenmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4765 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/maxmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4719 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/minmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3683 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/printmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4258 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/rangemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4820 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/reversedmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      718 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/sqrtmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3615 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/strsplitmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1842 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/summethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3869 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/toscripthashmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3969 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/uint160method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3969 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/method/uint256method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      447 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/builtin/neometadatatype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4702 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/callable.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1209 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/debuginstruction.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      982 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/event.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      805 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/expression.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      824 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/identifiedsymbol.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.152007 neo3-boa-0.9.0/boa3/model/imports/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       34 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/imports/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4927 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/imports/builtin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2636 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/imports/importsymbol.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2902 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/imports/package.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5171 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3517 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/module.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.152007 neo3-boa-0.9.0/boa3/model/operation/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.152007 neo3-boa-0.9.0/boa3/model/operation/binary/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.152007 neo3-boa-0.9.0/boa3/model/operation/binary/additional/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      258 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/additional/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5809 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/additional/membership.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2729 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/additional/notmembership.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.156007 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      889 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1660 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/addition.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2017 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/concat.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1569 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/division.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1597 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/floordivision.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1584 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/modulo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1672 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/multiplication.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1582 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/power.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2362 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/strmultiplication.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1596 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/subtraction.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3173 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/binaryoperation.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.156007 neo3-boa-0.9.0/boa3/model/operation/binary/logical/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      651 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1510 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/booleanand.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1507 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/booleanor.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1448 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/leftshift.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1428 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/logicand.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1424 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/logicor.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1428 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/logicxor.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1451 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/logical/rightshift.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.160007 neo3-boa-0.9.0/boa3/model/operation/binary/relational/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1516 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/LessThan.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1533 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/Lessthanorequal.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1092 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1522 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/greaterthan.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1539 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/greaterthanorequal.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1263 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/identity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1341 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/notidentity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1529 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/numericequality.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1539 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/numericinequality.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1590 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/objectequality.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1567 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binary/relational/objectinequality.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4052 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/binaryop.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2972 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/operation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2300 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/operator.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.160007 neo3-boa-0.9.0/boa3/model/operation/unary/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      408 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1251 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/booleannot.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1266 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/logicnot.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1255 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/negative.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1570 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/noneidentity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1633 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/nonenotidentity.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1321 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/positive.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1467 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unary/unaryoperation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1937 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/operation/unaryop.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      901 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/property.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.160007 neo3-boa-0.9.0/boa3/model/standards/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/standards/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1594 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/standards/neostandard.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1309 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/standards/nep17standard.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      521 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/standards/standardmethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      323 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/symbol.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.160007 neo3-boa-0.9.0/boa3/model/type/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.160007 neo3-boa-0.9.0/boa3/model/type/annotation/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/annotation/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1323 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/annotation/metatype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1609 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/annotation/optionaltype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3292 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/annotation/uniontype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      807 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/anytype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      630 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/baseexceptiontype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.164007 neo3-boa-0.9.0/boa3/model/type/classes/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/classes/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      510 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/classes/classarraytype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      511 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/classes/classstructtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5211 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/classes/classtype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.164007 neo3-boa-0.9.0/boa3/model/type/collection/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1452 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/genericcollectiontype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5998 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/icollection.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.164007 neo3-boa-0.9.0/boa3/model/type/collection/mapping/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/mapping/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      874 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/mapping/genericmappingtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4077 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/mapping/mappingtype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.164007 neo3-boa-0.9.0/boa3/model/type/collection/mapping/mutable/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/mapping/mutable/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      779 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/mapping/mutable/dicttype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      764 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/mapping/mutable/mutablemappingtype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.164007 neo3-boa-0.9.0/boa3/model/type/collection/sequence/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      413 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/buffertype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1942 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/ecpointtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1101 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/genericsequencetype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1159 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/genericmutablesequencetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1251 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/listtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      737 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/mutablesequencetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1376 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/rangetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1462 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/reversedtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1032 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/sequencetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1326 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/tupletype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2091 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/uint160type.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2091 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/collection/sequence/uint256type.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5247 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/itype.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/model/type/primitive/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      917 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/booltype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      831 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/bytearraytype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1604 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/bytestype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      951 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/inttype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      885 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/nonetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      228 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/primitivetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1636 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/primitive/strtype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4459 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/type.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1477 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/typeutils.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/model/type/typingmethod/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/typingmethod/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4383 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/type/typingmethod/casttypemethod.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1571 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/model/variable.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1430 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/contracts/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       88 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/contracts/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1822 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/contracts/neffile.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/core/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      121 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/core/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/core/types/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      103 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/core/types/InteropInterface.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/core/types/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/cryptography/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      603 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/cryptography/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/smart_contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      112 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/smart_contract/VoidType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/smart_contract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2045 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/smart_contract/notification.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/utils/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3730 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/utils/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.168007 neo3-boa-0.9.0/boa3/neo/vm/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      716 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/CallCode.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3440 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/TryCode.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3228 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/VMCode.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo/vm/opcode/
--rw-r--r--   0 circleci  (3434) circleci  (3434)    31512 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/opcode/Opcode.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    26303 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/opcode/OpcodeInfo.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1191 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/opcode/OpcodeInformation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/opcode/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo/vm/type/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      364 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/type/AbiType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      516 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/type/ContractParameterType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1205 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/type/Integer.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1805 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/type/StackItem.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      483 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/type/String.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo/vm/type/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/contracts/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      202 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2526 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/contracttypes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      228 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/findoptions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       92 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/namedcurve.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/contracts/native/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       77 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/native/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      512 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/native/nativetypes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7615 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/contracts/nef.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/core/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      195 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/core/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    22856 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/core/serialization.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/core/types/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      103 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/core/types/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4432 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/core/types/biginteger.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7914 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/core/types/uint.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2228 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/core/utils.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/network/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/network/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.172007 neo3-boa-0.9.0/boa3/neo3/network/payloads/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      111 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/network/payloads/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1468 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/network/payloads/oracleresponsecode.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.176007 neo3-boa-0.9.0/boa3/neo3/vm/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       29 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/vm/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      398 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3/neo3/vm/vmstate.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.176007 neo3-boa-0.9.0/boa3_test/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.176007 neo3-boa-0.9.0/boa3_test/test_sc/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.180007 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      109 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/AssignSlice.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      131 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayAppend.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      142 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayAppendWithBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      184 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayAppendWithMutableSequence.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      213 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayBoa2Test.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      219 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayBoa2Test2.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      165 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayBoa2Test3.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      133 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayClear.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      145 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayExtend.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      156 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayExtendWithBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       58 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayFromLiteralBytes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       80 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayFromString.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       68 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayFromVariableBytes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       89 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayGetValue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       90 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayGetValueNegativeIndex.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       72 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayLiteral.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      131 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayReverse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      162 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearraySetValue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      163 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearraySetValueNegativeIndex.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      112 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayToInt.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      121 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayToIntWithBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      117 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytearrayToIntWithBytesBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       95 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesClear.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       75 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesFromBytearray.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       85 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesGetValue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       86 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesGetValueNegativeIndex.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       43 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesLiteral.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       78 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesReverse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      119 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesSetValue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      108 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToBool.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      113 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToBoolWithBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      105 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToBoolWithBuiltinHardCodedFalse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      105 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToBoolWithBuiltinHardCodedTrue.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       60 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToBoolWithBuiltinMismatchedTypes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      101 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToInt.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      106 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToIntWithBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       57 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToIntWithBuiltinMismatchedTypes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       68 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToIntWithBytearrayBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       96 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToStr.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      101 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToStrWithBuiltin.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       56 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/BytesToStrWithBuiltinMismatchedTypes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      154 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/SliceBoa2Test.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      518 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/SliceBoa2Test2.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      142 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/SliceWithCast.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      216 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/UInt160Bytes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      127 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/UInt160Int.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      216 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/UInt256Bytes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      127 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/UInt256Int.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/bytes_test/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.184007 neo3-boa-0.9.0/boa3_test/test_sc/import_test/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportTyping.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      122 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportTypingNotImplementedType.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       88 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportTypingWithAlias.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      205 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportUserModule.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      203 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportUserModuleRecursiveImport.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      214 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportUserModuleWithAlias.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      189 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportVariable.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      196 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/FromImportWithGlobalVariables.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      118 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportInteropWithAlias.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       80 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportNonExistentPackage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      129 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportPythonLib.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       64 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportTyping.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)       71 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportTypingWithAlias.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      221 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportUserModule.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      226 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportUserModuleRecursiveImport.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      199 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportUserModuleWithAlias.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      329 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportUserModuleWithNotImportedSymbols.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      176 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/ImportUserModuleWithNotImportedVariables.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      205 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/UserModuleWithRecursiveImport.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/import_test/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.184007 neo3-boa-0.9.0/boa3_test/test_sc/interop_test/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      404 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/interop_test/UpdateContract.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/test_sc/interop_test/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.184007 neo3-boa-0.9.0/boa3_test/tests/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10908 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/boa_test.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.192007 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    12346 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_any.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    22226 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_arithmetic.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8432 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_assert.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1293 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_boa_builtin_method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    48062 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_builtin_method.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    21876 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_bytes.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3634 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_class.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    13576 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_constant.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17237 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_dict.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8448 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_event.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16442 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_exception.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25010 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_file_generation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17489 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_for.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    37776 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_function.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    21977 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_if.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    10497 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_import.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.192007 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    17407 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_blockchain.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    21675 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_contract.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    23476 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_crypto.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2338 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_iterator.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3825 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_json.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7352 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_oracle.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3123 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_policy.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3460 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_role.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    23192 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_runtime.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    29473 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_stdlib.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    30558 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_interop/test_storage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    38927 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_list.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16583 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_logical.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7287 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_metadata.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     7531 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_multiple_expressions.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    21111 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_neo_types.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4793 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_none.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3362 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_optional.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9219 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_python_operation.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    26697 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_range.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25996 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_relational.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3745 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_reversed.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     8052 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_string.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    13717 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_test_engine.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    19115 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_tuple.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9317 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_types.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4990 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_typing.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3264 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_union.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    23569 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_variable.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    16987 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/compiler_tests/test_while.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.196007 neo3-boa-0.9.0/boa3_test/tests/examples_tests/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    25818 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_HTLC.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    19067 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_NEP17.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    50994 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_amm.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      701 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_hello_world.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    21483 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_ico.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     9844 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_nep5.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3024 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_update_contract.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    34385 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/examples_tests/test_wrapped_neo.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.196007 neo3-boa-0.9.0/boa3_test/tests/neo/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/neo/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.196007 neo3-boa-0.9.0/boa3_test/tests/neo/smart_contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/neo/smart_contract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2509 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/neo/smart_contract/test_neffile.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.196007 neo3-boa-0.9.0/boa3_test/tests/test_classes/
--rw-r--r--   0 circleci  (3434) circleci  (3434)       50 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/TestExecutionException.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/__init__.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.196007 neo3-boa-0.9.0/boa3_test/tests/test_classes/binaryserializer/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1947 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/binaryserializer/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2191 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/block.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.196007 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/
--rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1198 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neoabistruct.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      669 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neoeventstruct.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1869 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neomanifeststruct.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1166 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neomethodstruct.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1302 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neopermissionsstruct.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      966 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neostruct.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      566 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/nativeaccountstate.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     1111 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/nativecontractprefix.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      692 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/signer.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     5961 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/storage.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      670 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/testcontract.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)    14406 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/testengine.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     3164 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/transaction.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.200007 neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/
--rw-r--r--   0 circleci  (3434) circleci  (3434)      118 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/__init__.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)     2193 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      681 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      112 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/transactionattributetype.py
--rw-r--r--   0 circleci  (3434) circleci  (3434)      968 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/boa3_test/tests/test_classes/witness.py
-drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2021-08-02 17:17:41.200007 neo3-boa-0.9.0/neo3_boa.egg-info/
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4186 2021-08-02 17:17:40.000000 neo3-boa-0.9.0/neo3_boa.egg-info/PKG-INFO
--rw-r--r--   0 circleci  (3434) circleci  (3434)    27991 2021-08-02 17:17:41.000000 neo3-boa-0.9.0/neo3_boa.egg-info/SOURCES.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2021-08-02 17:17:40.000000 neo3-boa-0.9.0/neo3_boa.egg-info/dependency_links.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       44 2021-08-02 17:17:40.000000 neo3-boa-0.9.0/neo3_boa.egg-info/entry_points.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)      139 2021-08-02 17:17:40.000000 neo3-boa-0.9.0/neo3_boa.egg-info/requires.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)       15 2021-08-02 17:17:40.000000 neo3-boa-0.9.0/neo3_boa.egg-info/top_level.txt
--rw-r--r--   0 circleci  (3434) circleci  (3434)      132 2021-08-02 17:17:41.200007 neo3-boa-0.9.0/setup.cfg
--rw-r--r--   0 circleci  (3434) circleci  (3434)     4548 2021-08-02 17:17:26.000000 neo3-boa-0.9.0/setup.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.163769 neo3-boa-1.0.0/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11357 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/LICENSE
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4521 2023-07-10 19:49:54.163769 neo3-boa-1.0.0/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3047 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/README.rst
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      116 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2313 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/boa3.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1199 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/compile_time/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13554 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/compile_time/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5804 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/contract/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      435 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/blockchain/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10773 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/blockchain/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1643 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/blockchain/block.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1965 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/blockchain/signer.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1531 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/blockchain/transaction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       65 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/blockchain/vmstate.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6174 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       76 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/contract/callflagstype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1071 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/contract/contract.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6750 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/contract/contractmanifest.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/crypto/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5095 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/crypto/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       89 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/crypto/namedcurve.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/iterator/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      815 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/iterator/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/json/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      960 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/json/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/oracle/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      199 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/oracle/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      101 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/oracle/oracleresponsecode.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3/builtin/interop/policy/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1230 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/policy/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/interop/role/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      543 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/role/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       73 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/role/roletype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/interop/runtime/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6715 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/runtime/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      544 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/runtime/notification.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       80 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/runtime/triggertype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/interop/stdlib/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5564 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/stdlib/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/interop/storage/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3240 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/storage/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       80 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/storage/findoptions.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1055 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/storage/storagecontext.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1379 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/interop/storage/storagemap.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1154 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/math.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/nativecontract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6777 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/contractmanagement.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3175 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/cryptolib.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3409 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/gas.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9158 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/ledger.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8874 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/neo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2291 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/oracle.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1679 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/policy.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      931 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/rolemanagement.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7876 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/nativecontract/stdlib.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/type/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2733 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/type/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      795 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/type/helper.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/builtin/vm/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       76 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/builtin/vm/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1090 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/cli.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1936 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/cpm.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/internal/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.087769 neo3-boa-1.0.0/boa3/internal/analyser/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10820 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/analyser.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11125 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/astanalyser.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    17364 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/astoptimizer.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4737 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/builtinfunctioncallanalyser.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3047 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/constructanalyser.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10840 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/importanalyser.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/analyser/model/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      464 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/model/ManifestSymbol.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/model/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1221 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/model/functionarguments.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/analyser/model/optimizer/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1181 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/model/optimizer/Operation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3056 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/model/optimizer/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1517 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/model/symbolscope.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    65411 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/moduleanalyser.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/analyser/supportedstandard/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      292 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/supportedstandard/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8135 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/supportedstandard/standardanalyser.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    82772 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/analyser/typeanalyser.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/cli_commands/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      106 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/cli_commands/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3765 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/cli_commands/compile_command.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      462 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/cli_commands/icommand.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/compiler/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      883 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    89916 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/codegenerator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    51813 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/codegeneratorvisitor.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1663 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/generatordata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4244 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/initstatementsvisitor.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3350 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/methodtokencollection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3602 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/stackmemento.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      367 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/variablegenerationdata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6725 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/vmcodemap.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11037 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/vmcodemapping.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3244 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/compiledmetadata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7451 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/compiler.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      487 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/compileroutput.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/compiler/filegenerator/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/filegenerator/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    35047 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/filegenerator/filegenerator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      925 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/compiler/filegenerator/importdata.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1752 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/constants.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      489 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/env.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/exception/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    13198 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/exception/CompilerError.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4250 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/exception/CompilerWarning.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      180 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/exception/InvalidPathException.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      334 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/exception/NotLoadedException.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/exception/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.091769 neo3-boa-1.0.0/boa3/internal/helpers/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      368 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/helpers/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.095769 neo3-boa-1.0.0/boa3/internal/model/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      153 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1705 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/attribute.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.095769 neo3-boa-1.0.0/boa3/internal/model/builtin/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    11741 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/builtin.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1685 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/builtincallable.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      726 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/builtinproperty.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      514 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/builtinsymbol.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.099769 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2773 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2816 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/appendmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2372 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/clearmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2652 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/copydictmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      389 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/copylistmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2631 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/copymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3724 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7709 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countsequencegenericmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5683 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countsequencemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      678 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countsequenceprimitivemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9111 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countstrmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3659 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/extendmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8497 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/indexbytesstringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2604 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/indexmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8292 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/indexsequencemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4116 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/insertmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6949 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/isdigitmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6241 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/joinmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6649 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/lowermethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1849 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/mapkeysmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1859 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/mapvaluesmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2652 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/popdictdefaultmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      643 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/popdictmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3822 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/popmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      800 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/popsequencemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3095 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/removemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1726 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/reversemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7883 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/startswithmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10401 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/stripmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6650 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/uppermethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.099769 neo3-boa-1.0.0/boa3/internal/model/builtin/compile_time/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      141 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/compile_time/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      456 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/compile_time/neometadatatype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.099769 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      580 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      726 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/abortmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3166 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/neoaccountstatetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      854 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/nep11transferevent.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      738 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/nep17transferevent.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      567 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/contract/nep5transferevent.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.099769 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      999 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      814 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/builtindecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1367 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/classmethoddecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2817 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/contractdecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3441 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/displaynamedecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      352 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/instancemethoddecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      224 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/metadatadecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1467 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/propertydecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3203 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/publicdecorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      232 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/staticmethoddecorator.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.103769 neo3-boa-1.0.0/boa3/internal/model/builtin/internal/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      238 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/internal/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2038 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/internal/getenvmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2389 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/internal/innerdeploymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      890 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/internal/internalmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.103769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.103769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2484 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4020 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/blocktype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      764 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/currenthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      730 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/currentindexmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      800 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/getblockmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      791 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/getcontractmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      976 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionfromblockmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      609 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionheightmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      745 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      740 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionsignersmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      674 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionvmstatemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3636 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/signertype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3854 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/transactiontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1495 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/vmstatetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1682 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/witnessconditionenumtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3045 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/witnessconditiontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1652 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/witnessruleactiontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3264 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/witnessruletype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1587 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/witnessscopeenumtype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.107769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1496 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1754 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/callflagstype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2049 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/callmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.107769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1521 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2052 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractabitype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1951 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1755 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractgrouptype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2069 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2236 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1905 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2070 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparametertype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2009 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1741 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3375 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contracttype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      883 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/createmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      821 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/createmultisigaccountmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      698 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/createstandardaccountmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      474 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/destroymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      543 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/getcallflagsmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      798 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/getgasscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      515 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/getminimumdeploymentfeemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      798 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/getneoscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      766 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/updatemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1167 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contractgethashmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.107769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1061 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      735 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/checkmultisigmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      974 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/checksigmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1262 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/hash160method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1258 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/hash256method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      562 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/murmur32method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1614 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/namedcurvetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      499 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/ripemd160method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      489 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/sha256method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      881 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/verifywithecdsa.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    18175 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interop.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1066 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interopevent.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      571 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interopinterfacetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1762 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interopmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.107769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      231 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1855 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/getiteratorvalue.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1520 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/iteratorinitmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      587 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/iteratornextmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2828 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/iteratortype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.107769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/json/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      273 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/json/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      510 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/json/jsondeserializemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      504 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/json/jsonserializemethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      133 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      809 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1106 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      105 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      749 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1068 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1054 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      779 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Ledger/ledgermethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Neo/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       97 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Neo/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      834 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Neo/getneoscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      772 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Neo/neocontractmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       89 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1108 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/getnep17scripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      875 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Nep17/nep17method.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1030 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      734 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Oracle/oraclemethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      117 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1070 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      803 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      117 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1074 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      764 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       93 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1033 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/getstdlibscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      734 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      506 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5055 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/nativecontractmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.111769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      249 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      617 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/oraclegetpricemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1043 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/oraclerequestmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1742 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/oracleresponsecodetype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.115769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/policy/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      532 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/policy/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      506 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/policy/getexecfeefactormethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      497 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/policy/getfeeperbytemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      502 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/policy/getstoragepricemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      636 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/policy/isblockedmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.115769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/role/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      252 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/role/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      822 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/role/getdesignatedbyrolemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1555 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/role/roletype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.115769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2551 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      483 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/burngasmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      905 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/checkwitnessmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      762 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getaddressversionmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      715 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getblocktimemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      827 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getcallingscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      815 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getentryscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      839 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getexecutingscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      717 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getgasleftmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      780 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getinvocationcountermethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      466 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getnetworkmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2238 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getnotificationsmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      721 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getplatformmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      463 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getrandommethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      522 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/gettriggermethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1693 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/loadscriptmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      474 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/logmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3152 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/notificationtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1090 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/notifymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      762 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/scriptcontainermethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1784 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/triggertype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.119769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1528 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      657 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/atoimethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      519 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/base58checkdecodemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      519 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/base58checkencodemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      503 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/base58decodemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      503 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/base58encodemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      503 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/base64decodemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      503 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/base64encodemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      500 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/deserializemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      718 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/itoamethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      634 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/memorycomparemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1217 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/memorysearchmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      494 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/serializemethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.119769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1184 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1835 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/findoptionstype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.119769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       51 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      581 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1270 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2188 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2916 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagedeletemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4441 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagefindmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      601 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3412 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagegetmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      619 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.119769 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       43 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1326 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1318 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1631 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapputmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4029 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemaptype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3282 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storageputmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.119769 neo3-boa-1.0.0/boa3/internal/model/builtin/math/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      418 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/math/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2625 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/math/decimalceil.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2590 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/math/decimalfloor.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1047 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/math/powmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      755 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/math/sqrtmethod.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.127769 neo3-boa-1.0.0/boa3/internal/model/builtin/method/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3698 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      757 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/absmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4429 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/boolmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      949 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/builtinevent.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6600 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/builtinmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      733 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/bytearrayencodingmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3780 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/bytearraymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1574 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/createeventmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3300 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/ecpointmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1848 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/ecpointtoscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2407 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/exceptionmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      724 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/exitmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    19709 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/intbytestringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      710 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/intintmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1585 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/intmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5585 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/isinstancemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1766 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/lenmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2535 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/listbytesstringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5630 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/listgenericmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      993 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/listmappingmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3490 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/listmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1091 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/listsequencemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4451 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/maxbytestringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      377 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/maxintmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5942 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/maxmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4455 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/minbytestringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      377 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/minintmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5896 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/minmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      749 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/printboolmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      516 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/printbytestringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1495 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/printclassmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      756 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/printintmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4822 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/printmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      828 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/printsequencemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4349 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/rangemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4970 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/reversedmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1614 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/strboolmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      683 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/strbytestringmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      633 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/strintmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1572 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/strmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4281 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/strsplitmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1888 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/summethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1563 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/supermethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2550 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/toboolmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4813 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/tobytesmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2537 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/tointmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5221 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/toscripthashmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2537 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/tostrmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4832 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/uint160method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4832 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/method/uint256method.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.127769 neo3-boa-1.0.0/boa3/internal/model/builtin/native/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      841 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.127769 neo3-boa-1.0.0/boa3/internal/model/builtin/native/contract_management/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      125 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/contract_management/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      709 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/contract_management/hasmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1566 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/contractmanagementclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1274 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/cryptolibclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1484 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/gasclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1392 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/inativecontractclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1517 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/ledgerclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2454 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nativecontract.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.131769 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1730 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      711 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getaccountstatemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      825 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getallcandidatesmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      783 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatesmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      675 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getcandidatevotemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      606 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getcommitteemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      495 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getgasperblockmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      638 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getnextblockvalidators.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      653 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/registercandidatemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      677 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/unclaimedgasmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      659 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/unregistercandidatemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1251 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/unvote.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      757 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/vote.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3024 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/neoclass.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.131769 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      620 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      657 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/balanceofmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      525 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/decimalsmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      519 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/symbolmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      534 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/totalsupplymethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1004 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/transfermethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1274 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/oracleclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1280 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/policyclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1180 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/rolemanagementclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1804 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/builtin/native/stdlibclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     7112 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/callable.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1222 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/debuginstruction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1139 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/decorator.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1308 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/event.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      823 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/expression.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      833 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/identifiedsymbol.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.131769 neo3-boa-1.0.0/boa3/internal/model/imports/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       43 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/imports/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6500 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/imports/builtin.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2849 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/imports/importsymbol.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4942 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/imports/package.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5833 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/method.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4285 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/module.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.131769 neo3-boa-1.0.0/boa3/internal/model/operation/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.131769 neo3-boa-1.0.0/boa3/internal/model/operation/binary/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.131769 neo3-boa-1.0.0/boa3/internal/model/operation/binary/additional/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      276 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/additional/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5881 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/additional/membership.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2801 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/additional/notmembership.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.135769 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1098 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1556 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/addition.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2253 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/concat.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1456 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/division.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1493 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/floordivision.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2700 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/listaddition.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2827 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/modulo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1568 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/multiplication.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1478 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/power.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2475 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/strbytesmultiplication.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1492 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/subtraction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3191 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/binaryoperation.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.135769 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      714 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1493 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/booleanand.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1490 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/booleanor.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1525 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/leftshift.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1497 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/logicand.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1493 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/logicor.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1497 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/logicxor.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1529 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/rightshift.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.135769 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1182 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1505 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/greaterthan.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1522 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/greaterthanorequal.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1299 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/identity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1499 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/lessthan.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1516 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/lessthanorequal.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1377 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/notidentity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1512 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/numericequality.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1522 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/numericinequality.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1626 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/objectequality.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1603 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/objectinequality.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4190 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/binaryop.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3286 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/operation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2300 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/operator.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.135769 neo3-boa-1.0.0/boa3/internal/model/operation/unary/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      453 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1320 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/booleannot.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1336 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/logicnot.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1324 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/negative.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1606 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/noneidentity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1669 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/nonenotidentity.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1390 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/positive.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1485 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unary/unaryoperation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1973 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/operation/unaryop.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      928 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/property.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.135769 neo3-boa-1.0.0/boa3/internal/model/standards/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/standards/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2243 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/standards/neostandard.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2469 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/standards/nep11standard.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1435 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/standards/nep17standard.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      830 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/standards/standardmethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      322 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/symbol.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.139769 neo3-boa-1.0.0/boa3/internal/model/type/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.139769 neo3-boa-1.0.0/boa3/internal/model/type/annotation/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/annotation/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1546 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/annotation/metatype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1710 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/annotation/optionaltype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4093 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/annotation/uniontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      843 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/anytype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      639 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/baseexceptiontype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.139769 neo3-boa-1.0.0/boa3/internal/model/type/classes/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      537 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/classarraytype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1587 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/classinitmethoddefault.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      119 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/classscope.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      538 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/classstructtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8647 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/classtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1202 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/contractinterfaceclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1035 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/contractinterfacehash.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4631 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/pythonclass.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5768 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/classes/userclass.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.139769 neo3-boa-1.0.0/boa3/internal/model/type/collection/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1470 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/genericcollectiontype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6127 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/icollection.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.139769 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      892 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/genericmappingtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4114 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mappingtype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.139769 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mutable/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mutable/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1347 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mutable/dicttype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      782 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mutable/mutablemappingtype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      627 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/buffertype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2271 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/ecpointtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1128 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/genericsequencetype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1186 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/genericmutablesequencetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1709 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/listtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1433 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/mutablesequencetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1412 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/rangetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1498 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/reversedtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1513 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/sequencetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1353 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/tupletype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1851 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/uint160type.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1927 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/uint256type.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5319 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/itype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1119 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/math.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/model/type/neo/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      684 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      503 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/addresstype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      540 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/blockhashtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1699 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/opcodetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      540 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/publickeytype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      622 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/scripthashlittleendiantype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      550 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/scripthashtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      568 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/neo/transactionidtype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/model/type/primitive/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1209 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/booltype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1023 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/bytearraytype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      740 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/bytestringtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1042 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/bytestype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1908 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/ibytestringtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1246 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/inttype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1005 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/nonetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      193 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/primitivetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1733 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/primitive/strtype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4639 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/type.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1874 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/typeutils.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/model/type/typingmethod/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/typingmethod/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4456 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/type/typingmethod/casttypemethod.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1759 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/model/variable.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/neo/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2541 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/neo/contracts/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       98 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/contracts/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2016 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/contracts/neffile.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.143769 neo3-boa-1.0.0/boa3/internal/neo/core/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      131 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/core/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/core/types/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      103 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/core/types/InteropInterface.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/core/types/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/cryptography/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      603 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/cryptography/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/smart_contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      112 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/smart_contract/VoidType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/smart_contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2267 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/smart_contract/notification.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/utils/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4096 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/utils/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/vm/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      743 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/CallCode.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3476 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/TryCode.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3284 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/VMCode.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    29012 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/Opcode.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    10557 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/OpcodeHelper.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    27309 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/OpcodeInfo.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1209 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/OpcodeInformation.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo/vm/type/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1780 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/type/AbiType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      516 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/type/ContractParameterType.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1214 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/type/Integer.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2516 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/type/StackItem.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      492 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/type/String.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo/vm/type/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo3/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo3/contracts/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      220 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2843 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/contracttypes.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1555 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/findoptions.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      499 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/namedcurve.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo3/contracts/native/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       85 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/native/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      512 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/native/nativetypes.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     9076 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/contracts/nef.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo3/core/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      195 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/core/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    23279 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/core/serialization.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.147769 neo3-boa-1.0.0/boa3/internal/neo3/core/types/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      103 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/core/types/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4432 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/core/types/biginteger.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8211 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/core/types/uint.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2232 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/core/utils.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3/internal/neo3/network/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/network/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3/internal/neo3/network/payloads/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      120 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/network/payloads/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1468 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/network/payloads/oracleresponsecode.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1448 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/network/payloads/verification.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3/internal/neo3/vm/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       29 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/vm/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      787 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3/internal/neo3/vm/vmstate.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.083769 neo3-boa-1.0.0/boa3_test/
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/interface/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/interface/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1156 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/interface/itransactionobject.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      456 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/invokeresult.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2245 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/neobatchinvoke.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1741 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/neoinvoke.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2429 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/neoinvokecollection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1915 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/invoker/neoinvokeresult.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/network/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2165 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/signer.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1898 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/testblock.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4483 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/testtransaction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      968 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/witness.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1200 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/witnessscope.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/smart_contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/smart_contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     5316 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/smart_contract/contractcollection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2733 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/smart_contract/testcontract.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      936 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/smart_contract/triggertype.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/model/wallet/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/wallet/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1977 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/wallet/account.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      530 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/model/wallet/utils.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       45 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8723 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/batch.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.151769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      770 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1102 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/batch/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      294 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      762 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/create.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      434 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/icheckpointcommand.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      764 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/checkpoint/restore.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      528 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1727 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/deploy.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      430 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/icontractcommand.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1910 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/invoke.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      577 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/list.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2264 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/contract/run.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1227 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/create/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      948 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/fastforward/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1704 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/neoexpresscommand.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      944 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/reset/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      267 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1041 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/block.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      422 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/ishowcommand.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      694 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/show/transaction.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1414 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoexpresscommand/transfer/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1218 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoxp.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1448 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/neoxp_contract.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/utils/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      757 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/command/utils/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/model/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/model/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      969 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/model/neoxpaccount.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3326 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/model/neoxpconfig.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     8510 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/neoxp/utils.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.155769 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.159769 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2926 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/block.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1250 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/contract.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1554 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/log.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1460 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/notification.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4193 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/storage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2322 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/storagecollection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2271 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/transaction.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      934 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/blockchain/transactionlog.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    19143 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/neo_test_runner.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2107 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/testrunner/utils.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      335 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/test_drive/utils.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.159769 neo3-boa-1.0.0/boa3_test/tests/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    16870 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/boa_test.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2360 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/run_unit_tests.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.159769 neo3-boa-1.0.0/boa3_test/tests/test_classes/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       50 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/TestExecutionException.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/__init__.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.159769 neo3-boa-1.0.0/boa3_test/tests/test_classes/binaryserializer/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1974 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/binaryserializer/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1699 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/block.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.159769 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1198 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neoabistruct.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      668 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neoeventstruct.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1746 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neomanifeststruct.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1174 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neomethodstruct.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1423 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neopermissionsstruct.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      975 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neostruct.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1558 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/contractcollection.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      584 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/nativeaccountstate.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     1129 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/nativecontractprefix.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2542 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/signer.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     6453 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/storage.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3160 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/testcontract.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2412 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/transaction.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.159769 neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      118 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/__init__.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     2202 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      681 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      112 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/transactionattributetype.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      319 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_classes/witness.py
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     3044 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/boa3_test/tests/test_suite.py
+drwxr-xr-x   0 circleci  (3434) circleci  (3434)        0 2023-07-10 19:49:54.163769 neo3-boa-1.0.0/neo3_boa.egg-info/
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4521 2023-07-10 19:49:54.000000 neo3-boa-1.0.0/neo3_boa.egg-info/PKG-INFO
+-rw-r--r--   0 circleci  (3434) circleci  (3434)    37518 2023-07-10 19:49:54.000000 neo3-boa-1.0.0/neo3_boa.egg-info/SOURCES.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)        1 2023-07-10 19:49:54.000000 neo3-boa-1.0.0/neo3_boa.egg-info/dependency_links.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       72 2023-07-10 19:49:54.000000 neo3-boa-1.0.0/neo3_boa.egg-info/entry_points.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       81 2023-07-10 19:49:54.000000 neo3-boa-1.0.0/neo3_boa.egg-info/requires.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)       15 2023-07-10 19:49:54.000000 neo3-boa-1.0.0/neo3_boa.egg-info/top_level.txt
+-rw-r--r--   0 circleci  (3434) circleci  (3434)      159 2023-07-10 19:49:54.163769 neo3-boa-1.0.0/setup.cfg
+-rw-r--r--   0 circleci  (3434) circleci  (3434)     4985 2023-07-10 19:49:39.000000 neo3-boa-1.0.0/setup.py
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/astanalyser.py` & `neo3-boa-1.0.0/boa3/internal/analyser/astanalyser.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,69 +1,106 @@
 import ast
 import logging
+import os
 from abc import ABC
 from inspect import isclass
 from typing import Any, Dict, List, Optional, Sequence, Union
 
-from boa3.exception.CompilerError import CompilerError, InternalError
-from boa3.exception.CompilerWarning import CompilerWarning
-from boa3.model.attribute import Attribute
-from boa3.model.expression import IExpression
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.operation.operation import IOperation
-from boa3.model.symbol import ISymbol
-from boa3.model.type.annotation.metatype import MetaType
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.type import IType, Type
-from boa3.model.type.typeutils import TypeUtils
+from boa3.internal import constants
+from boa3.internal.exception.CompilerError import CompilerError, InternalError, UnresolvedReference
+from boa3.internal.exception.CompilerWarning import CompilerWarning
+from boa3.internal.model.attribute import Attribute
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.annotation.metatype import MetaType
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.model.type.typeutils import TypeUtils
 
 
 class IAstAnalyser(ABC, ast.NodeVisitor):
     """
     An interface for the analysers that walk the Python abstract syntax tree
 
     :ivar errors: a list that contains all the errors raised by the compiler. Empty by default.
     :ivar warnings: a list that contains all the warnings found by the compiler. Empty by default.
     """
 
-    def __init__(self, ast_tree: ast.AST, filename: str = None, log: bool = False):
+    def __init__(self, ast_tree: ast.AST, filename: str = None, root_folder: str = None,
+                 log: bool = False, fail_fast: bool = True):
         self.errors: List[CompilerError] = []
         self.warnings: List[CompilerWarning] = []
 
         self.filename: Optional[str] = filename
+        if not isinstance(root_folder, str) or not os.path.isdir(root_folder):
+            root_folder = (os.path.dirname(os.path.abspath(filename))
+                           if isinstance(filename, str) and os.path.isfile(filename)
+                           else os.path.abspath(os.path.curdir))
+        self.root_folder: str = root_folder
         self._log: bool = log
+        self._fail_fast: bool = fail_fast
 
         self._tree: ast.AST = ast_tree
         self.symbols: Dict[str, ISymbol] = {}
 
     @property
     def has_errors(self) -> bool:
         return len(self.errors) > 0
 
     def _log_error(self, error: CompilerError):
+        if self._fail_fast and len(self.errors) > 0:
+            raise error
+
+        if error.filepath is None:
+            error.filepath = self.filename
         if not any(err == error for err in self.errors):
             # don't include duplicated errors
             self.errors.append(error)
             if self._log:
-                logging.error(error)
+                logging.getLogger(constants.BOA_LOGGING_NAME).error(error)
+
+        if self._fail_fast:
+            raise error
 
     def _log_warning(self, warning: CompilerWarning):
+        if warning.filepath is None:
+            warning.filepath = self.filename
         if not any(warn == warning for warn in self.warnings):
             # don't include duplicated warnings
             self.warnings.append(warning)
             if self._log:
-                logging.warning(warning)
+                logging.getLogger(constants.BOA_LOGGING_NAME).warning(warning)
+
+    def _log_info(self, info_message: str, log_filename: bool = True):
+        if self._log:
+            if log_filename and self.filename:
+                formatted_message = f'{info_message} <{self.filename}>'
+            else:
+                formatted_message = info_message
+
+            logging.getLogger(constants.BOA_LOGGING_NAME).info(formatted_message)
+
+    def analyse_visit(self, node: ast.AST) -> Any:
+        try:
+            return self.visit(node)
+        except CompilerError:
+            # stops the analyser if fail fast is activated
+            pass
 
     def visit(self, node: ast.AST) -> Any:
         try:
             return super().visit(node)
         except CompilerError as error:
             self._log_error(error)
         except CompilerWarning as warning:
             self._log_warning(warning)
+        except KeyboardInterrupt as interrupt:
+            raise interrupt
         except BaseException as exception:
             if hasattr(node, 'lineno'):
                 self._log_error(
                     InternalError(line=node.lineno,
                                   col=node.col_offset,
                                   raised_exception=exception)
                 )
@@ -79,25 +116,26 @@
         # visits if it is a node
         if isinstance(value, ast.AST):
             fun_rtype_id: Any = ast.NodeVisitor.visit(self, value)
             if isinstance(fun_rtype_id, ast.Name):
                 fun_rtype_id = fun_rtype_id.id
 
             if isinstance(fun_rtype_id, str) and not isinstance(value, ast.Str):
-                value = self.get_symbol(fun_rtype_id)
+                value = self.get_symbol(fun_rtype_id, origin_node=value)
                 if isinstance(value, IType) and not isinstance(value, MetaType):
                     value = TypeUtils.type.build(value) if use_metatype else value
             else:
                 value = fun_rtype_id
 
-        if (isinstance(value, Attribute) and
-                ((isinstance(value.attr_symbol, IExpression) and isinstance(value.attr_symbol.type, ClassType))
-                 or (isinstance(value.attr_symbol, IType))
-                 )):
-            value = value.attr_symbol
+        if isinstance(value, Attribute):
+            if ((isinstance(value.attr_symbol, IExpression) and isinstance(value.attr_symbol.type, ClassType))
+                    or (isinstance(value.attr_symbol, IType))):
+                value = value.attr_symbol
+            elif isinstance(value.type, IType):
+                value = value.type
 
         if isinstance(value, IType):
             final_type = value
         elif isinstance(value, IExpression):
             final_type = value.type
         elif isinstance(value, IOperation):
             final_type = value.result
@@ -107,15 +145,16 @@
         if isinstance(final_type, MetaType) and not use_metatype:
             return final_type.meta_type
         else:
             return final_type
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
-                   check_raw_id: bool = False) -> Optional[ISymbol]:
+                   check_raw_id: bool = False,
+                   origin_node: ast.AST = None) -> Optional[ISymbol]:
         """
         Tries to get the symbol by its id name
 
         :param symbol_id: the id name of the symbol
         :return: the symbol if found. None otherwise.
         :rtype: ISymbol or None
         """
@@ -126,25 +165,35 @@
         if check_raw_id:
             found_symbol = self._search_by_raw_id(symbol_id, list(self.symbols.values()))
             if found_symbol is not None:
                 # the symbol exists in the global scope, but with an alias different from the original name
                 return found_symbol
 
         if is_internal:
-            from boa3.model import imports
+            from boa3.internal.model import imports
             found_symbol = imports.builtin.get_internal_symbol(symbol_id)
             if isinstance(found_symbol, ISymbol):
                 return found_symbol
 
         # the symbol may be a built in. If not, returns None
-        from boa3.model.builtin.builtin import Builtin
+        from boa3.internal.model.builtin.builtin import Builtin
         found_symbol = Builtin.get_symbol(symbol_id)
 
         if found_symbol is None and isinstance(symbol_id, str) and self.is_exception(symbol_id):
             found_symbol = Builtin.Exception.return_type
+
+        if origin_node is not None and found_symbol is None:
+            self._log_error(
+                UnresolvedReference(
+                    line=origin_node.lineno,
+                    col=origin_node.col_offset,
+                    symbol_id=symbol_id
+                )
+            )
+
         return found_symbol
 
     def _search_by_raw_id(self, symbol_id: str, symbols: Sequence[ISymbol]) -> Optional[ISymbol]:
         for symbol in symbols:
             if isinstance(symbol, IdentifiedSymbol) and symbol.identifier == symbol_id:
                 return symbol
 
@@ -156,14 +205,23 @@
             symbol = (global_symbols[symbol_id]
                       if symbol_id in global_symbols
                       else global_symbols['__builtins__'][symbol_id])
             if isclass(symbol) and issubclass(symbol, BaseException):
                 return True
         return False
 
+    def is_implemented_class_type(self, symbol) -> bool:
+        if not isinstance(symbol, ClassType):
+            return False
+
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        from boa3.internal.model.builtin.interop.interopinterfacetype import InteropInterfaceType
+
+        return not isinstance(symbol, PythonClass) or isinstance(symbol, InteropInterfaceType)
+
     def parse_to_node(self, expression: str, origin: ast.AST = None) -> Union[ast.AST, Sequence[ast.AST]]:
         """
         Parses an expression to an ast.
 
         :param expression: string expression to be parsed
         :param origin: an existing ast. If not None, the parsed node will have the same location of origin.
         :return: the parsed node
@@ -214,11 +272,11 @@
         :param node: node to be cloned
         :return:
         """
         clone: ast.AST = node.__class__()
         clone._attributes = node._attributes
         clone._fields = node._fields
 
-        for attr in node._attributes + node._fields:
+        for attr in node.__dict__:
             clone.__setattr__(attr, node.__getattribute__(attr))
 
         return clone
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/astoptimizer.py` & `neo3-boa-1.0.0/boa3/internal/analyser/astoptimizer.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,43 +1,60 @@
 import ast
 from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
 
-from boa3.analyser.astanalyser import IAstAnalyser
-from boa3.analyser.model.optimizer import ScopeValue, Undefined
-from boa3.analyser.model.optimizer.Operation import Operation
-from boa3.model.method import Method
-from boa3.model.module import Module
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary.unaryoperation import UnaryOperation
-from boa3.model.symbol import ISymbol
-from boa3.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal import constants
+from boa3.internal.analyser.astanalyser import IAstAnalyser
+from boa3.internal.analyser.model.optimizer import ScopeValue, Undefined
+from boa3.internal.analyser.model.optimizer.Operation import Operation
+from boa3.internal.exception import CompilerWarning
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.method import Method
+from boa3.internal.model.module import Module
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.property import Property
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.classes.userclass import UserClass
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 
 
 class AstOptimizer(IAstAnalyser, ast.NodeTransformer):
     """
     This class is responsible for reducing the generated ast.
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
 
     :ivar modules: a list with the analysed modules. Empty by default.
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
-    def __init__(self, analyser, log: bool = False):
-        super().__init__(analyser.ast_tree, log=log)
+    def __init__(self, analyser, log: bool = False, fail_fast: bool = True):
+        super().__init__(analyser.ast_tree, filename=analyser.filename, root_folder=analyser.root,
+                         log=log, fail_fast=fail_fast)
         self.modules: Dict[str, Module] = {}
         self.symbols: Dict[str, ISymbol] = analyser.symbol_table
 
         self._is_optimizing: bool = False
         self.has_changes: bool = False
         self.current_scope: ScopeValue = ScopeValue()
 
-        self.visit(self._tree)
+        self._current_class: UserClass = None
+
+        self.analyse_visit(self._tree)
+
+    @property
+    def tree(self) -> ast.AST:
+        """
+        Gets the analysed abstract syntax tree
+
+        :return: the analysed ast
+        """
+        return self._tree
 
     def literal_eval(self, node: ast.AST) -> Any:
         """
         Evaluates an expression node containing a Python expression.
 
         :param node: the node that will be evaluated
         :return: the evaluated expression if the node is valid. Otherwise, returns Undefined.
@@ -64,16 +81,43 @@
             new_node.op = Operator.get_operation(new_node.op)
 
         return new_node
 
     def reset_state(self):
         self.current_scope.reset()
 
+    def get_symbol_id(self, node: ast.AST) -> Optional[str]:
+        parts = []
+        cur_node = node
+        while isinstance(cur_node, ast.Attribute):
+            parts.insert(0, cur_node.attr)
+            cur_node = cur_node.value
+
+        if isinstance(cur_node, ast.Name):
+            parts.insert(0, cur_node.id)
+
+        return constants.ATTRIBUTE_NAME_SEPARATOR.join(parts)
+
+    def visit_ClassDef(self, node: ast.ClassDef) -> Any:
+        if node.name in self.symbols:
+            class_symbol = self.symbols[node.name]
+            if isinstance(class_symbol, UserClass):
+                self._current_class = class_symbol
+
+        self.generic_visit(node)
+        self._current_class = None
+        return node
+
     def visit_FunctionDef(self, node: ast.FunctionDef) -> ast.FunctionDef:
-        method = self.symbols[node.name]
+        symbols = self.symbols if self._current_class is None else self._current_class.symbols
+        method = symbols[node.name]
+
+        if isinstance(method, Property):
+            method = method.getter
+
         if isinstance(method, Method):
             self._is_optimizing = True
             self.has_changes = True
 
             while self.has_changes:
                 self.reset_state()
                 self.has_changes = False
@@ -132,15 +176,15 @@
             left_value = self.literal_eval(bin_op.left)
             right_value = self.literal_eval(bin_op.right)
 
             if (left_value is Undefined and isinstance(bin_op.left, ast.BinOp)
                     and self.is_symmetric_operation(bin_op.op, bin_op.left.op)):
                 left_value, right_value = self.reorder_operations(bin_op, bin_op.left)
             elif (right_value is Undefined and isinstance(bin_op.right, ast.BinOp)
-                    and self.is_symmetric_operation(bin_op.op, bin_op.right.op)):
+                  and self.is_symmetric_operation(bin_op.op, bin_op.right.op)):
                 left_value, right_value = self.reorder_operations(bin_op, bin_op.right)
 
             value = self._evaluate_binary_operation(left_value, right_value, bin_op.op)
             if value is not None:
                 self.has_changes = True
                 return self.parse_to_node(str(value), bin_op, isinstance(value, str))
             return bin_op
@@ -336,27 +380,75 @@
                 self.current_scope = except_scope
 
                 for stmt in handler.body:
                     self.visit(stmt)
 
                 except_scopes.append(except_scope)
 
+        if len(node.orelse) > 0:
+            else_scope = outer_scope.new_scope()
+            self.current_scope = else_scope
+
+            for stmt in node.orelse:
+                self.visit(stmt)
+
+            except_scopes.append(else_scope)
+
         self.current_scope = self.current_scope.previous_scope()
         self.current_scope.update_values(try_scope, *except_scopes)
 
         for stmt in node.finalbody:
             self.visit(stmt)
 
-        # TODO: include else scope
         return node
 
     def visit_Name(self, node: ast.Name) -> ast.AST:
         if (isinstance(node.ctx, ast.Load)
                 and node.id in self.current_scope
                 and isinstance(self.get_type(self.current_scope[node.id]), PrimitiveType)):
             # only values from int, bool, str and bytes types are going to replace the variable
             # TODO: check if it's worth to replace other types
             value = self.current_scope[node.id]
             if isinstance(value, str):
                 value = "'{0}'".format(value)
             return self.parse_to_node(str(value), node)
         return node
+
+    def visit_Call(self, node: ast.Call) -> ast.AST:
+        # check if the call can be evaluated during compile time
+        # TODO: right now only UInt160 and UInt256 constructors are evaluated
+        literal_args = []
+        args_are_literal = True
+
+        for index, arg in enumerate(node.args.copy()):
+            updated_arg = self.visit(arg)  # first try to optimize the arguments
+            if updated_arg != arg:
+                node.args[index] = updated_arg
+
+            if args_are_literal:
+                value = self.literal_eval(updated_arg)
+                if value is Undefined:
+                    # don't break if one argument is not literal to make sure that all arguments were checked
+                    # if they can be optimized
+                    args_are_literal = False
+
+                literal_args.append(value)
+
+        if args_are_literal:
+            # try to get the result
+            try:
+                func_id = self.get_symbol_id(node.func)
+            except BaseException:
+                return node
+            func = self.get_symbol(func_id)
+
+            if isinstance(func, IBuiltinMethod):
+                try:
+                    result = func.evaluate_literal(*literal_args)
+                    if result is not Undefined:
+                        return self.parse_to_node(str(result), node, is_origin_str=isinstance(result, str))
+                except BaseException:
+                    self._log_warning(CompilerWarning.InvalidArgument(
+                        node.lineno, node.col_offset
+                    ))
+
+        return node
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/builtinfunctioncallanalyser.py` & `neo3-boa-1.0.0/boa3/internal/analyser/builtinfunctioncallanalyser.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 import ast
 from typing import Any, Callable, Dict, List, Optional, Type
 
-from boa3.analyser.astanalyser import IAstAnalyser
-from boa3.exception import CompilerError
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.builtin.method.isinstancemethod import IsInstanceMethod
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
+from boa3.internal.analyser.astanalyser import IAstAnalyser
+from boa3.internal.exception import CompilerError
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.builtin.method.isinstancemethod import IsInstanceMethod
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
 
 
 class BuiltinFunctionCallAnalyser(IAstAnalyser):
-    def __init__(self, origin: IAstAnalyser, call: ast.Call, method_id: str, builtin_method: IBuiltinMethod, log: bool):
+    def __init__(self, origin: IAstAnalyser, call: ast.Call, method_id: str, builtin_method: IBuiltinMethod,
+                 log: bool, fail_fast: bool = True):
         self._method: IBuiltinMethod = builtin_method
         self.method_id: str = method_id
-        super().__init__(call, log=log)
+        super().__init__(call, root_folder=origin.root_folder, log=log, fail_fast=fail_fast)
 
         self._origin: IAstAnalyser = origin
 
         # all methods validators must be (IBuiltinMethod, List[IType]) -> None
         self._methods_validators: Dict[Type[IBuiltinMethod],
                                        Callable[[IBuiltinMethod, List[IType]], None]] = {
             IsInstanceMethod: self._validate_IsInstanceMethod
@@ -82,16 +83,16 @@
             elif len(last_arg.elts) > 1:
                 # if there are more than one type, updates information in the instance of the method
                 types: List[IType] = [self.get_symbol_from_node(name) for name in last_arg.elts]
                 method.set_instance_type(types)
                 self.call.args[-1] = last_arg.elts[-1]
                 return
 
-        from boa3.model.type.annotation.metatype import MetaType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.annotation.metatype import MetaType
+        from boa3.internal.model.type.type import Type
         is_ast_valid = (isinstance(last_arg, ast.Name)
                         or (isinstance(last_arg, ast.NameConstant) and args_types[-1] is Type.none))
 
         is_id_valid = (hasattr(last_arg, 'id')
                        and last_arg.id != args_types[-1].identifier
                        and last_arg.id != args_types[-1].raw_identifier
                        and isinstance(self.get_type(last_arg, use_metadata=True), MetaType))
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/constructanalyser.py` & `neo3-boa-1.0.0/boa3/internal/analyser/constructanalyser.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,23 +1,28 @@
 import ast
+from typing import Dict
 
-from boa3.analyser.astanalyser import IAstAnalyser
+from boa3.internal.analyser.astanalyser import IAstAnalyser
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.symbol import ISymbol
 
 
 class ConstructAnalyser(IAstAnalyser, ast.NodeTransformer):
     """
     This class is responsible for pre processing Python constructs
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
     """
 
-    def __init__(self, ast_tree: ast.AST, log: bool = False):
-        super().__init__(ast_tree, log=log)
-        self.visit(self._tree)
+    def __init__(self, analyser, ast_tree: ast.AST, symbol_table: Dict[str, ISymbol],
+                 log: bool = False, fail_fast: bool = True):
+        super().__init__(ast_tree, root_folder=analyser.root, log=log, fail_fast=fail_fast)
+        self.symbols = symbol_table.copy()
+        self.analyse_visit(self._tree)
 
     @property
     def tree(self) -> ast.AST:
         """
         Gets the analysed abstract syntax tree
 
         :return: the analysed ast
@@ -26,46 +31,48 @@
 
     def visit_Call(self, call: ast.Call) -> ast.AST:
         """
         Visitor of a function call node
 
         :param call: the python ast function call node
         """
-        if isinstance(call.func, ast.Attribute):
-            from boa3.model.builtin.builtin import Builtin
-            if call.func.attr == Builtin.ScriptHash.identifier:
-                from boa3.constants import SYS_VERSION_INFO
-                from boa3.model.type.type import Type
+        if isinstance(call.func, ast.Name):
+            from boa3.internal.model.builtin.method import ScriptHashMethod
+            to_script_hash = None
+            for symbol_id, symbol in self.symbols.items():
+                if isinstance(symbol, ScriptHashMethod) and call.func.id == symbol_id:
+                    to_script_hash = symbol
+                    break
+
+            if to_script_hash is not None:
+                from boa3.internal.constants import SYS_VERSION_INFO
+                from boa3.internal.model.type.type import Type
                 types = {
                     Type.int.identifier: int,
                     Type.str.identifier: str,
                     Type.bytes.identifier: bytes
                 }
                 literal: tuple = ((ast.Constant,)
                                   if SYS_VERSION_INFO >= (3, 8)
                                   else (ast.Num, ast.Str, ast.Bytes))
 
-                if isinstance(call.func.value, literal) and len(call.args) == 0:
-                    value = ast.literal_eval(call.func.value)
-                    if not isinstance(value, tuple(types.values())):
-                        return call
-                elif (isinstance(call.func.value, ast.Name)     # checks if is the name of a type
-                      and call.func.value.id in types        # and if the arguments is from the same type
-                      and len(call.args) == 1
-                      and isinstance(call.args[0], literal)):
+                if len(call.args) != 1:
+                    return call
+
+                if isinstance(call.args[0], literal):
                     value = ast.literal_eval(call.args[0])
-                    if not isinstance(value, (types[call.func.value.id],)):
+                    if not isinstance(value, tuple(types.values())):
                         return call
                 else:
                     return call
 
-                from boa3.neo import to_script_hash
+                from boa3.internal.neo import to_script_hash
                 # value must be bytes
                 if isinstance(value, int):
-                    from boa3.neo.vm.type.Integer import Integer
+                    from boa3.internal.neo.vm.type.Integer import Integer
                     value = Integer(value).to_byte_array()
                 elif isinstance(value, str):
-                    from boa3.neo.vm.type.String import String
+                    from boa3.internal.neo.vm.type.String import String
                     value = String(value).to_bytes()
-                return self.parse_to_node(str(to_script_hash(value)), call)
+                return set_internal_call(self.parse_to_node(f"UInt160({str(to_script_hash(value))})", call))
 
         return call
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/model/functionarguments.py` & `neo3-boa-1.0.0/boa3/internal/analyser/model/functionarguments.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 from typing import Dict, Optional, Tuple
 
-from boa3.model.variable import Variable
+from boa3.internal.model.variable import Variable
 
 
 class FunctionArguments:
 
     def __init__(self):
         self._args: Dict[str, Variable] = {}
         self._vararg: Optional[Tuple[str, Variable]] = None
+        self._kwargs: Optional[Dict[str, Variable]] = None
 
     @property
     def args(self) -> Dict[str, Variable]:
         return self._args.copy()
 
     def add_arg(self, arg_id: str, arg: Variable) -> bool:
         if not isinstance(arg, Variable):
@@ -24,7 +25,19 @@
         return self._vararg
 
     def set_vararg(self, arg_id: str, arg: Variable) -> bool:
         if not isinstance(arg, Variable):
             return False
         self._vararg = (arg_id, arg)
         return True
+
+    @property
+    def kwargs(self) -> Dict[str, Variable]:
+        return self._kwargs
+
+    def add_kwarg(self, arg_id: str, arg: Variable) -> bool:
+        if not isinstance(arg, Variable):
+            return False
+        if self._kwargs is None:
+            self._kwargs: Dict[str, Variable] = {}
+        self._kwargs[arg_id] = arg
+        return True
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/model/optimizer/Operation.py` & `neo3-boa-1.0.0/boa3/internal/analyser/model/optimizer/Operation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from __future__ import annotations
 
 import ast
 from enum import Enum, auto
 from typing import Optional, Union
 
-from boa3.model.operation.operation import IOperation
-from boa3.model.operation.operator import Operator
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.operation.operator import Operator
 
 
 class Operation(Enum):
     Add = auto()
     Sub = auto()
     Mult = auto()
     Div = auto()
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/model/optimizer/__init__.py` & `neo3-boa-1.0.0/boa3/internal/analyser/model/optimizer/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -84,9 +84,13 @@
         self._values[key] = value
 
 
 class UndefinedType:
     def __init__(self):
         pass
 
+    @property
+    def identifier(self) -> str:
+        return 'undefined'
+
 
 Undefined = UndefinedType()
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/moduleanalyser.py` & `neo3-boa-1.0.0/boa3/internal/analyser/moduleanalyser.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,87 +1,125 @@
 import ast
 import logging
 import os
 from typing import Any, Dict, Iterable, List, Optional, Tuple, Union
 
-from boa3 import constants
-from boa3.analyser.astanalyser import IAstAnalyser
-from boa3.analyser.importanalyser import ImportAnalyser
-from boa3.analyser.model.functionarguments import FunctionArguments
-from boa3.analyser.model.optimizer import UndefinedType
-from boa3.analyser.model.symbolscope import SymbolScope
-from boa3.builtin import NeoMetadata
-from boa3.exception import CompilerError, CompilerWarning
-from boa3.model.builtin.builtin import Builtin
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.callable import Callable
-from boa3.model.event import Event
-from boa3.model.expression import IExpression
-from boa3.model.imports.importsymbol import Import
-from boa3.model.method import Method
-from boa3.model.module import Module
-from boa3.model.symbol import ISymbol
-from boa3.model.type.annotation.uniontype import UnionType
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.collection.icollection import ICollectionType as Collection
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.type import IType, Type
-from boa3.model.variable import Variable
+from boa3.builtin.compile_time import NeoMetadata
+from boa3.internal import constants
+from boa3.internal.analyser.astanalyser import IAstAnalyser
+from boa3.internal.analyser.importanalyser import ImportAnalyser
+from boa3.internal.analyser.model.ManifestSymbol import ManifestSymbol
+from boa3.internal.analyser.model.functionarguments import FunctionArguments
+from boa3.internal.analyser.model.optimizer import UndefinedType
+from boa3.internal.analyser.model.symbolscope import SymbolScope
+from boa3.internal.exception import CompilerError, CompilerWarning
+from boa3.internal.model.builtin.builtin import Builtin
+from boa3.internal.model.builtin.decorator import ContractDecorator
+from boa3.internal.model.builtin.decorator.builtindecorator import IBuiltinDecorator
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.decorator import IDecorator
+from boa3.internal.model.event import Event
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.imports.importsymbol import BuiltinImport, Import
+from boa3.internal.model.imports.package import Package
+from boa3.internal.model.method import Method
+from boa3.internal.model.module import Module
+from boa3.internal.model.property import Property
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.annotation.metatype import MetaType
+from boa3.internal.model.type.annotation.uniontype import UnionType
+from boa3.internal.model.type.classes.classscope import ClassScope
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.classes.contractinterfaceclass import ContractInterfaceClass
+from boa3.internal.model.type.classes.pythonclass import PythonClass
+from boa3.internal.model.type.classes.userclass import UserClass
+from boa3.internal.model.type.collection.icollection import ICollectionType as Collection
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.model.variable import Variable
 
 
 class ModuleAnalyser(IAstAnalyser, ast.NodeVisitor):
     """
     This class is responsible for mapping the locals of the functions and modules
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
 
     :ivar modules: a dictionary that maps each module with its name. Empty by default.
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
-    def __init__(self, analyser, symbol_table: Dict[str, ISymbol], filename: str = None,
-                 analysed_files: Optional[List[str]] = None, log: bool = False):
-        super().__init__(analyser.ast_tree, filename, log)
+    def __init__(self, analyser, symbol_table: Dict[str, ISymbol],
+                 filename: str = None, root_folder: str = None,
+                 analysed_files: Optional[dict] = None,
+                 import_stack: Optional[List[str]] = None,
+                 log: bool = False,
+                 fail_fast: bool = True):
+        super().__init__(analyser.ast_tree, filename, root_folder, log, fail_fast)
         self.modules: Dict[str, Module] = {}
         self.symbols: Dict[str, ISymbol] = symbol_table
 
-        if isinstance(analysed_files, list):
-            analysed_files = [file_path.replace(os.sep, '/') if isinstance(file_path, str) else file_path
-                              for file_path in analysed_files]
-        self._analysed_files: Optional[List[str]] = analysed_files
+        from boa3.internal.analyser.analyser import Analyser
+        if isinstance(analysed_files, dict):
+            for file_path, file_analyser in analysed_files.copy().items():
+                fixed_path = file_path.replace(os.sep, constants.PATH_SEPARATOR)
+                if file_path != fixed_path:
+                    analysed_files.pop(file_path)
+                    analysed_files[fixed_path] = file_analyser
+        else:
+            analysed_files = {}
+
+        analysed_files[filename.replace(os.sep, constants.PATH_SEPARATOR)] = analyser
+        self._analysed_files: Dict[str, Analyser] = analysed_files
+
+        if isinstance(import_stack, list):
+            import_stack = [file_path.replace(os.sep, constants.PATH_SEPARATOR)
+                            if isinstance(file_path, str) else file_path
+                            for file_path in import_stack]
+        else:
+            import_stack = []
+        self._import_stack: List[str] = import_stack
 
         self._builtin_functions_to_visit: Dict[str, IBuiltinMethod] = {}
         self._current_module: Module = None
+        self._current_class: UserClass = None
         self._current_method: Method = None
         self._current_event: Event = None
 
         self._deploy_method: Optional[Method] = None
 
         self._annotated_variables: List[str] = []
         self._global_assigned_variables: List[str] = []
         self._scope_stack: List[SymbolScope] = []
 
         self._metadata: NeoMetadata = None
         self._metadata_node: ast.AST = ast.parse('')
+        self._manifest_symbols: Dict[Tuple[ManifestSymbol, str, int], Callable] = {}
         self.imported_nodes: List[ast.AST] = []
-        self.visit(self._tree)
+
+        if self.filename:
+            self._tree.filename = self.filename
+        self.analyse_visit(self._tree)
 
         analyser.metadata = self._metadata if self._metadata is not None else NeoMetadata()
 
     @property
-    def _current_scope(self) -> Union[Method, Module, None]:
+    def _current_scope(self) -> Union[Method, Module, UserClass, None]:
         """
         Returns the scope that is currently being analysed
 
         :return: the current scope. Return None if it is the global scope
         :rtype: Method or Module or None
         """
         if self._current_method is not None:
             return self._current_method
+        if self._current_class is not None:
+            return self._current_class
         return self._current_module
 
     @property
     def _current_symbol_scope(self) -> Optional[SymbolScope]:
         if len(self._scope_stack) > 0:
             return self._scope_stack[-1]
         else:
@@ -98,14 +136,18 @@
 
         global_symbols.update(self.symbols)
         for mod in self.modules.values():
             global_symbols.update(mod.symbols)
 
         return global_symbols
 
+    @property
+    def analysed_files(self) -> Dict[str, Any]:
+        return self._analysed_files.copy()
+
     def __include_variable(self, var_id: str, var_type_id: Union[str, IType],
                            source_node: ast.AST,
                            var_enumerate_type: IType = Type.none, assignment: bool = True):
         """
         Includes the variable in the symbol table if the id was not used
 
         :param var_id: variable id
@@ -127,18 +169,18 @@
             outer_symbol = self.get_symbol(var_id)
             if var_id in self._current_symbol_scope.symbols:
                 if hasattr(outer_symbol, 'set_is_reassigned'):
                     # don't mark as reassigned if it is outside of a function
                     is_module_scope = isinstance(self._current_scope, Module)
                     if not is_module_scope:
                         outer_symbol.set_is_reassigned()
-                    if is_module_scope or self._current_scope == self._deploy_method:
-                        source_node.origin = self._tree
+                    self.__set_source_origin(source_node, is_module_scope)
             else:
-                if not isinstance(source_node, ast.Global):
+                if (not isinstance(source_node, ast.Global) and
+                        (not hasattr(source_node, 'targets') or not isinstance(source_node.targets[x], ast.Subscript))):
                     if outer_symbol is not None:
                         self._log_warning(
                             CompilerWarning.NameShadowing(source_node.lineno, source_node.col_offset, outer_symbol, var_id)
                         )
 
                 var_type = None
                 if isinstance(var_type_id, SequenceType):
@@ -169,20 +211,57 @@
     def __include_callable(self, callable_id: str, callable: Callable):
         """
         Includes the method in the symbol table if the id was not used
 
         :param callable_id: method id
         :param callable: method to be included
         """
-        if callable_id not in self._current_module.symbols:
-            self._current_module.include_callable(callable_id, callable)
+        if ((self._current_scope is self._current_class or callable_id not in self._current_scope.symbols)
+                and hasattr(self._current_scope, 'include_callable')):
+            already_exists = not self._current_scope.include_callable(callable_id, callable)
+        else:
+            symbol = self.get_symbol(callable_id)
+            already_exists = symbol is not None and not isinstance(symbol, IBuiltinMethod)
+
+        if already_exists:
+            self._log_error(CompilerError.DuplicatedIdentifier(callable.origin.lineno,
+                                                               callable.origin.col_offset,
+                                                               callable_id))
+
+        if callable.is_public:
+            # check if the external name + argument number is unique
+            manifest_name = callable.external_name if callable.external_name is not None else callable_id
+            manifest_id = (ManifestSymbol.get_manifest_symbol(callable), manifest_name, len(callable.args))
+
+            if manifest_id in self._manifest_symbols:
+                self._log_error(CompilerError.DuplicatedManifestIdentifier(callable.origin.lineno,
+                                                                           callable.origin.col_offset,
+                                                                           manifest_name, len(callable.args)
+                                                                           ))
+            else:
+                self._manifest_symbols[manifest_id] = callable
+
+    def __include_class_variable(self, cl_var_id: str, cl_var: Variable):
+        """
+        Includes the class variable in the current class
+
+        :param cl_var_id: variable name
+        :param cl_var: variable to be included
+        """
+        if cl_var_id not in self._current_scope.class_variables:
+            self._current_class.include_symbol(cl_var_id, cl_var, ClassScope.CLASS)
+
+    def __set_source_origin(self, source_node: ast.AST, scope_is_correct: bool = True):
+        if scope_is_correct or self._current_scope == self._deploy_method:
+            source_node.origin = self._tree
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
-                   check_raw_id: bool = False) -> Optional[ISymbol]:
+                   check_raw_id: bool = False,
+                   origin_node: ast.AST = None) -> Optional[ISymbol]:
         for scope in reversed(self._scope_stack):
             if symbol_id in scope.symbols:
                 return scope.symbols[symbol_id]
 
             if check_raw_id:
                 found_symbol = self._search_by_raw_id(symbol_id, list(scope.symbols.values()))
                 if found_symbol is not None:
@@ -200,21 +279,52 @@
             if found_symbol is not None:
                 return found_symbol
 
             found_symbol = self._search_by_raw_id(symbol_id, list(self._current_module.symbols.values()))
             if found_symbol is not None:
                 return found_symbol
 
-        return super().get_symbol(symbol_id, is_internal, check_raw_id)
+        return super().get_symbol(symbol_id, is_internal, check_raw_id, origin_node)
+
+    def get_annotation(self, value: Any, use_metatype: bool = False, accept_none: bool = False) -> Optional[IType]:
+        if not isinstance(value, ast.AST):
+            return None
+
+        annotation_type = self.get_type(value, use_metatype)
+        if not isinstance(annotation_type, PythonClass):
+            return annotation_type
+        if hasattr(value, 'value') and value.value is None and annotation_type is Type.none:
+            return annotation_type
+
+        if isinstance(value, (ast.Constant, ast.NameConstant, ast.List, ast.Tuple, ast.Dict, ast.Set)):
+            # annotated types should only accept types
+            return None
+        return annotation_type
+
+    def _check_annotation_type(self, node: ast.AST, origin_node: Optional[ast.AST] = None):
+        if node is None:
+            return
+
+        if origin_node is None:
+            origin_node = node
+
+        if self.get_annotation(node) is None:
+            actual_type = self.get_type(node)
+            self._log_error(
+                CompilerError.MismatchedTypes(
+                    origin_node.lineno, origin_node.col_offset,
+                    expected_type_id=type.__name__,
+                    actual_type_id=actual_type.identifier
+                ))
 
     # region Log
 
     def _log_import(self, import_from: str):
         if self._log:
-            logging.info("Importing '{0}'".format(import_from))
+            logging.getLogger(constants.BOA_LOGGING_NAME).info("Importing '{0}'\t <{1}>".format(import_from, self.filename))
 
     def _log_unresolved_import(self, origin_node: ast.AST, import_id: str):
         if self._log:
             self._log_error(
                 CompilerError.UnresolvedReference(
                     line=origin_node.lineno,
                     col=origin_node.col_offset,
@@ -253,39 +363,73 @@
                     line=function.lineno, col=function.col_offset,
                     symbol_id=function.name
                 )
             )
         else:
             function.returns = None
             function.decorator_list = []
+
+            imports: List[ast.AST] = []
+            other_instructions: List[ast.AST] = []
+            for node in self._tree.body:
+                if node == function:
+                    # metadata function must be right after all the imports, so it executes correctly
+                    continue
+
+                if isinstance(node, (ast.ImportFrom, ast.Import)):
+                    imports.append(node)
+                else:
+                    other_instructions.append(node)
+
             module: ast.Module = ast.parse('')
-            module.body = [node for node in self._tree.body
-                           if isinstance(node, (ast.ImportFrom, ast.Import))]
-            module.body.append(function)
+            module.body = imports + [function] + other_instructions
             ast.copy_location(module, function)
-
-            # executes the function
-            code = compile(module, filename='<boa3>', mode='exec')
             namespace = {}
-            exec(code, namespace)
-            obj: Any = namespace[function.name]()
 
+            try:
+                # executes the function
+                code = compile(module, filename='<boa3>', mode='exec')
+                exec(code, namespace)
+            except ModuleNotFoundError:
+                # will fail if any imports can't be executed
+                # in this case, the error is already logged
+                return
+            except BaseException as inner_exception:
+                # reordering the module tree may raise unexpected exceptions
+                # ignore if it has generated the metadata function
+                if function.name not in namespace:
+                    raise inner_exception
+
+            obj: Any = namespace[function.name]()
             node: ast.AST = function.body[-1] if len(function.body) > 0 else function
             # return must be a NeoMetadata object
             if not isinstance(obj, NeoMetadata):
                 obj_type = self.get_type(obj).identifier if self.get_type(obj) is not Type.any else type(obj).__name__
                 self._log_error(
                     CompilerError.MismatchedTypes(
                         line=node.lineno, col=node.col_offset,
                         expected_type_id=NeoMetadata.__name__,
                         actual_type_id=obj_type
                     )
                 )
                 return
 
+            # validate if the extras field can be converted to json
+            try:
+                import json
+                json.dumps(obj.extras)
+            except BaseException as e:
+                self._log_error(
+                    CompilerError.InvalidType(
+                        line=node.lineno, col=node.col_offset,
+                        symbol_id=str(e)
+                    )
+                )
+                return
+
             # validates the metadata attributes types
             attributes: Dict[str, Any] = {attr: value
                                           for attr, value in dict(obj.__dict__).items()
                                           if attr in Builtin.metadata_fields}
             if any(not isinstance(value, Builtin.metadata_fields[attr]) for attr, value in attributes.items()):
                 for expected, actual in [(Builtin.metadata_fields[attr], type(v_type))
                                          for attr, v_type in attributes.items()
@@ -322,16 +466,25 @@
         self._log_import(import_from.module)
         analyser = self._analyse_module_to_import(import_from, import_from.module)
         if analyser is not None:
             import_alias: Dict[str] = \
                 {alias.name: alias.asname if alias.asname is not None else alias.name for alias in import_from.names}
 
             new_symbols: Dict[str, ISymbol] = analyser.export_symbols(list(import_alias.keys()))
+
+            # check if the wildcard is used and filter the symbols
+            if constants.IMPORT_WILDCARD in import_alias:
+                import_alias.pop(constants.IMPORT_WILDCARD)
+                for imported_symbol_id in new_symbols:
+                    # add the symbols imported with the wildcard without specific aliases in the dict
+                    if imported_symbol_id not in import_alias:
+                        import_alias[imported_symbol_id] = imported_symbol_id
+
             # includes the module to be able to generate the functions
-            imported_module = Import(analyser.path, analyser.tree, analyser, import_alias)
+            imported_module = self._build_import(analyser.path, analyser.tree, analyser, import_alias)
             self._current_scope.include_symbol(import_from.module, imported_module)
 
             for name, alias in import_alias.items():
                 if name in new_symbols:
                     self._current_scope.include_symbol(alias, imported_module.symbols[name])
                 else:
                     # if there's a symbol that couldn't be loaded, log a compiler error
@@ -351,50 +504,73 @@
             analyser = self._analyse_module_to_import(import_node, target)
             if analyser is not None:
                 new_symbols: Dict[str, ISymbol] = analyser.export_symbols()
                 for symbol in [symbol for symbol in analyser.symbols if symbol not in new_symbols]:
                     # if there's a symbol that couldn't be loaded, log a compiler error
                     self._log_unresolved_import(import_node, '{0}.{1}'.format(target, symbol))
 
-                imported_module = Import(analyser.path, analyser.tree, analyser)
+                imported_module = self._build_import(analyser.path, analyser.tree, analyser)
                 self._current_scope.include_symbol(alias, imported_module)
 
+    def _build_import(self, origin: str, syntax_tree: ast.AST,
+                      import_analyser: ImportAnalyser,
+                      imported_symbols: Dict[str, ISymbol] = None) -> Import:
+
+        if import_analyser.is_builtin_import:
+            return BuiltinImport(origin, syntax_tree, import_analyser, imported_symbols)
+
+        return Import(origin, syntax_tree, import_analyser, imported_symbols)
+
     def _analyse_module_to_import(self, origin_node: ast.AST, target: str) -> Optional[ImportAnalyser]:
-        already_imported = {imported.origin for imported in self._current_module.symbols.values()
-                            if isinstance(imported, Import)
+        already_imported = {imported.origin: imported.analyser
+                            for imported in self._current_module.symbols.values()
+                            if isinstance(imported, Import) and imported.analyser is not None
                             }
-        if self._analysed_files is not None:
-            already_imported = already_imported.union(self._analysed_files)
+        already_imported.update(self._analysed_files)
 
-        analyser = ImportAnalyser(import_target=target,
-                                  importer_file=self.filename,
-                                  already_imported_modules=list(already_imported),
-                                  log=self._log)
+        try:
+            analyser = ImportAnalyser(import_target=target,
+                                      root_folder=self.root_folder,
+                                      importer_file=self.filename,
+                                      already_imported_modules=already_imported,
+                                      import_stack=self._import_stack.copy(),
+                                      log=self._log,
+                                      fail_fast=self._fail_fast)
 
-        if analyser.recursive_import:
-            self._log_error(
-                CompilerError.CircularImport(line=origin_node.lineno,
-                                             col=origin_node.col_offset,
-                                             target_import=target,
-                                             target_origin=self.filename)
-            )
+            if analyser.recursive_import:
+                self._log_error(
+                    CompilerError.CircularImport(line=origin_node.lineno,
+                                                 col=origin_node.col_offset,
+                                                 target_import=target,
+                                                 target_origin=self.filename)
+                )
 
-        elif not analyser.can_be_imported:
-            circular_import_error = next((error for error in analyser.errors
-                                          if isinstance(error, CompilerError.CircularImport)),
-                                         None)
+            elif not analyser.can_be_imported:
+                circular_import_error = next((error for error in analyser.errors
+                                              if isinstance(error, CompilerError.CircularImport)),
+                                             None)
+
+                if circular_import_error is not None:
+                    # if the problem was a circular import, the error was already logged
+                    self.errors.append(circular_import_error)
+                elif hasattr(analyser, 'is_namespace_package') and analyser.is_namespace_package:
+                    return analyser
+                else:
+                    self._log_unresolved_import(origin_node, target)
 
-            if circular_import_error is not None:
-                # if the problem was a circular import, the error was already logged
-                self.errors.append(circular_import_error)
             else:
-                self._log_unresolved_import(origin_node, target)
+                analyser.update_external_analysed_files(self._analysed_files)
+                return analyser
 
-        else:
-            return analyser
+        except CompilerError.CompilerError as error_on_import:
+            if self._log:
+                self.errors.append(error_on_import)
+                raise error_on_import
+            else:
+                self._log_error(error_on_import)
 
     def visit_Module(self, module: ast.Module):
         """
         Visitor of the module node
 
         Fills module symbol table
 
@@ -429,63 +605,214 @@
         for stmt in function_stmts:
             result = self.visit(stmt)
             # don't evaluate the metadata function in the following analysers
             if result is Builtin.Metadata:
                 module.body.remove(stmt)
 
         # TODO: include the body of the builtin methods to the ast
-        # TODO: get module name
         self.modules['main'] = mod
         module_scope = self._scope_stack.pop()
         for symbol_id, symbol in module_scope.symbols.items():
             if symbol_id in self._global_assigned_variables:
                 mod.include_symbol(symbol_id, symbol)
                 mod.assign_variable(symbol_id)
 
         self._global_assigned_variables.clear()
         self._current_module = None
 
-    def visit_ClassDef(self, node: ast.ClassDef):
-        # TODO: refactor when classes defined by the user are implemented
-        self._log_error(
-            CompilerError.NotSupportedOperation(
-                node.lineno, node.col_offset,
-                symbol_id='class'
+    def visit_ClassDef(self, class_node: ast.ClassDef):
+        """
+        Visitor of the class node
+
+        Includes the class in the scope of its module
+        """
+        bases = []
+        for base in class_node.bases:
+            base_type_id: Any = ast.NodeVisitor.visit(self, base)
+            if isinstance(base_type_id, ast.Name):
+                base_type_id = base_type_id.id
+
+            base_symbol = self.get_symbol(base_type_id)
+            # TODO: change when class inheritance with builtin types is implemented
+            if not isinstance(base_symbol, UserClass):
+                self._log_error(
+                    CompilerError.NotSupportedOperation(
+                        class_node.lineno, class_node.col_offset,
+                        symbol_id='class inheritance with builtins'
+                    )
+                )
+            bases.append(base_symbol)
+
+        # TODO: change when class inheritance with multiple bases is implemented
+        if len(bases) > 1:
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    class_node.lineno, class_node.col_offset,
+                    symbol_id='class inheritance with multiple bases'
+                )
+            )
+
+        # TODO: change when base classes with keyword is implemented
+        if len(class_node.keywords) > 0:
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    class_node.lineno, class_node.col_offset,
+                    symbol_id='class keyword'
+                )
+            )
+
+        # TODO: change when class decorators are implemented
+        class_decorators: List[Method] = self._get_decorators(class_node)
+        if not all(isinstance(decorator, IBuiltinDecorator) and decorator.is_class_decorator
+                   for decorator in class_decorators):
+            # only builtin decorator are currently accepted
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    class_node.lineno, class_node.col_offset,
+                    symbol_id='class decorator'
+                )
             )
-        )
+
+        contract_interface_decorator = next((decorator for decorator in class_decorators
+                                             if isinstance(decorator, ContractDecorator)),
+                                            None)
+
+        if contract_interface_decorator is not None:
+            from boa3.internal.model.type.classes.contractinterfaceclass import ContractInterfaceClass
+            user_class = ContractInterfaceClass(contract_hash=contract_interface_decorator.contract_hash,
+                                                identifier=class_node.name,
+                                                decorators=class_decorators,
+                                                bases=bases)
+        else:
+            user_class = UserClass(identifier=class_node.name,
+                                   decorators=class_decorators,
+                                   bases=bases)
+
+        self._current_class = user_class
+        if self._current_symbol_scope is not None:
+            self._current_symbol_scope.include_symbol(class_node.name, user_class)
+        self._scope_stack.append(SymbolScope())
+
+        for stmt in class_node.body:
+            self.visit(stmt)
+
+        class_scope = self._scope_stack.pop()
+        self._current_module.include_class(class_node.name, user_class)
+        self._current_class = None
 
     def visit_FunctionDef(self, function: ast.FunctionDef):
         """
         Visitor of the function node
 
         Includes the method in the scope of its module
 
         :param function:
         """
+        fun_decorators: List[Method] = self._get_decorators(function)
+        if Builtin.Metadata in fun_decorators:
+            self._read_metadata_object(function)
+            return Builtin.Metadata
+
+        if any(decorator is None for decorator in fun_decorators):
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    function.lineno, function.col_offset,
+                    symbol_id='decorator'
+                )
+            )
+
+        valid_decorators: List[IDecorator] = []
+        for decorator in fun_decorators:
+            if isinstance(decorator, IDecorator):
+                decorator.update_args(function.args, self._current_scope)
+                valid_decorators.append(decorator)
+
+        is_static_method = (isinstance(self._current_scope, ClassType)
+                            and Builtin.StaticMethodDecorator in valid_decorators)
+        is_instance_method = (isinstance(self._current_scope, ClassType)
+                              and Builtin.ClassMethodDecorator not in valid_decorators
+                              and not is_static_method)
+        is_class_constructor = is_instance_method and function.name == constants.INIT_METHOD_ID
+
+        external_function_name = None
+        if isinstance(self._current_class, ContractInterfaceClass):
+            if not is_static_method:
+                self._log_error(CompilerError
+                                .InvalidUsage(function.lineno, function.col_offset,
+                                              "Only static methods are accepted when defining contract interfaces"
+                                              ))
+            else:
+                display_name_decorator = next((decorator for decorator in valid_decorators
+                                               if isinstance(decorator, type(Builtin.ContractMethodDisplayName))),
+                                              None)
+                if display_name_decorator is not None:
+                    external_function_name = display_name_decorator.external_name
+
+        if is_instance_method:
+            if Builtin.InstanceMethodDecorator not in valid_decorators:
+                valid_decorators.append(Builtin.InstanceMethodDecorator)
+
+            if len(function.args.args) > 0 and function.args.args[0].annotation is None:
+                # set annotation to the self method
+                from boa3.internal.model import set_internal_call
+                self_argument = function.args.args[0]
+                self_annotation = self._current_class.identifier
+
+                self_ast_annotation = ast.parse(self_annotation).body[0].value
+                set_internal_call(self_ast_annotation)
+
+                ast.copy_location(self_ast_annotation, self_argument)
+                self_argument.annotation = self_ast_annotation
+
+        if is_class_constructor:
+            # __init__ method behave like class methods
+            if Builtin.ClassMethodDecorator not in valid_decorators:
+                valid_decorators.append(Builtin.ClassMethodDecorator)
+
         fun_args: FunctionArguments = self.visit(function.args)
-        fun_rtype_symbol = self.visit(function.returns) if function.returns is not None else Type.none
+        if function.returns is not None:
+            fun_rtype_symbol = self.visit(function.returns)
+            self._check_annotation_type(function.returns)
+        else:
+            fun_rtype_symbol = Type.none
+
+        # TODO: remove when dictionary unpacking operator is implemented
+        if function.args.kwarg is not None:
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    function.lineno, function.col_offset,
+                    symbol_id='** variables'
+                )
+            )
 
-        if fun_rtype_symbol is None:
-            # it is a function with None return: Main(a: int) -> None:
-            raise NotImplementedError
+        # TODO: remove when keyword-only arguments are implemented
+        if len(function.args.kwonlyargs) > 0:
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    function.lineno, function.col_offset,
+                    symbol_id='keyword-only arguments'
+                )
+            )
 
         if isinstance(fun_rtype_symbol, str):
-            symbol = self.get_symbol(function.returns.id)
+            symbol = self.get_symbol(fun_rtype_symbol, origin_node=function.returns)
             fun_rtype_symbol = self.get_type(symbol)
 
         fun_return: IType = self.get_type(fun_rtype_symbol)
-        fun_decorators: List[Method] = self._get_function_decorators(function)
-
-        if Builtin.Metadata in fun_decorators:
-            self._read_metadata_object(function)
-            return Builtin.Metadata
 
         method = Method(args=fun_args.args, defaults=function.args.defaults, return_type=fun_return,
                         vararg=fun_args.vararg,
-                        origin_node=function, is_public=Builtin.Public in fun_decorators)
+                        origin_node=function,
+                        is_public=any(isinstance(decorator, type(Builtin.Public)) for decorator in fun_decorators),
+                        decorators=valid_decorators,
+                        external_name=external_function_name,
+                        is_init=is_class_constructor)
+
+        # debug information
+        method.file_origin = self.filename.replace(os.path.sep, constants.PATH_SEPARATOR)
 
         if function.name in Builtin.internal_methods:
             internal_method = Builtin.internal_methods[function.name]
             if not internal_method.is_valid_deploy_method(method):
                 self._log_error(
                     CompilerError.InternalIncorrectSignature(line=function.lineno,
                                                              col=function.col_offset,
@@ -494,47 +821,98 @@
         if function.name == constants.DEPLOY_METHOD_ID:
             self._deploy_method = method
 
         self._current_method = method
         self._scope_stack.append(SymbolScope())
 
         # don't evaluate constant expression - for example: string for documentation
-        from boa3.constants import SYS_VERSION_INFO
+        from boa3.internal.constants import SYS_VERSION_INFO
         if SYS_VERSION_INFO >= (3, 8):
             function.body = [stmt for stmt in function.body
                              if not (isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Constant))]
         else:
             function.body = [stmt for stmt in function.body
                              if not (isinstance(stmt, ast.Expr) and
                                      (hasattr(stmt.value, 'n') or hasattr(stmt.value, 's'))
                                      )]
+
+        if isinstance(self._current_class, ClassType):
+            method.origin_class = self._current_class
+            if self._current_class.is_interface and len(function.body) > 0:
+                first_instruction = function.body[0]
+                if not isinstance(first_instruction, ast.Pass):
+                    self._log_warning(CompilerWarning.UnreachableCode(first_instruction.lineno,
+                                                                      first_instruction.col_offset))
+
         for stmt in function.body:
             self.visit(stmt)
 
-        self.__include_callable(function.name, method)
         method_scope = self._scope_stack.pop()
         global_scope_symbols = self._scope_stack[0].symbols if len(self._scope_stack) > 0 else {}
 
+        self._set_instance_variables(method_scope)
+        self._set_properties(function)
+
+        self._current_method = None
+        self.__include_callable(function.name, method)
+
         for var_id, var in method_scope.symbols.items():
             if isinstance(var, Variable) and var_id not in self._annotated_variables:
                 method.include_variable(var_id, Variable(UndefinedType, var.origin))
             else:
                 method.include_symbol(var_id, var)
 
         self._annotated_variables.clear()
-        self._current_method = None
 
-    def _get_function_decorators(self, function: ast.FunctionDef) -> List[Method]:
+    def _get_decorators(self, node: ast.AST) -> List[Method]:
         """
-        Gets a list of the symbols used to decorate the given function
+        Gets a list of the symbols used to decorate the given node
 
-        :param function: python ast function definition node
-        :return: a list with all function decorators. Empty if none decorator is found.
+        :param node: python ast node
+        :return: a list with all decorators in the node. Empty if no decorator is found.
         """
-        return [self.get_symbol(self.visit(decorator)) for decorator in function.decorator_list]
+        decorators = []
+        if hasattr(node, 'decorator_list'):
+            for decorator in node.decorator_list:
+                decorator_visit = self.visit(decorator)
+                if decorator_visit is None and hasattr(decorator, 'func'):
+                    decorator_visit = self.visit(decorator.func)
+
+                symbol = self.get_symbol(decorator_visit, origin_node=decorator)
+                if hasattr(symbol, 'build'):
+                    symbol = symbol.build(decorator, self)
+                decorators.append(symbol)
+
+        return decorators
+
+    def _set_instance_variables(self, scope: SymbolScope):
+        if (isinstance(self._current_class, UserClass)
+                and isinstance(self._current_method, Method)
+                and self._current_method.is_init
+                and len(self._current_method.args) > 0):
+
+            self_id = list(self._current_method.args)[0]
+            for var_id, var in scope.symbols.items():
+                if var_id.startswith(self_id):
+                    split_name = var_id.split(constants.ATTRIBUTE_NAME_SEPARATOR)
+                    if len(split_name) > 0:
+                        instance_var_id = split_name[1]
+                        self._current_class.include_symbol(instance_var_id, var)
+                        scope.remove_symbol(var_id)
+
+    def _set_properties(self, function: ast.FunctionDef):
+        from boa3.internal.model.builtin.decorator import PropertyDecorator
+        if (isinstance(self._current_class, UserClass)
+                and isinstance(self._current_method, Method)
+                and any(isinstance(decorator, PropertyDecorator) for decorator in self._current_method.decorators)):
+            if len(self._current_method.args) < 1 or not any('self' == arg for arg in self._current_method.args):
+                self._log_error(
+                    CompilerError.SelfArgumentError(function.lineno, function.col_offset)
+                )
+            self._current_class.include_symbol(self._current_method.origin.name, Property(self._current_method))
 
     def visit_arguments(self, arguments: ast.arguments) -> FunctionArguments:
         """
         Visitor of the function arguments node
 
         :param arguments:
         :return: a dictionary that maps each argument to its identifier
@@ -545,30 +923,36 @@
             var_id, var = self.visit_arg(arg)  # Tuple[str, Variable]
             fun_args.add_arg(var_id, var)
 
         if arguments.vararg is not None:
             var_id, var = self.visit_arg(arguments.vararg)  # Tuple[str, Variable]
             fun_args.set_vararg(var_id, var)
 
+        if arguments.kwarg is not None:
+            var_id, var = self.visit_arg(arguments.kwarg)  # Tuple[str, Variable]
+            fun_args.add_kwarg(var_id, var)
+
         return fun_args
 
     def visit_arg(self, arg: ast.arg) -> Tuple[str, Variable]:
         """
         Visitor of a function argument node
 
         :param arg:
         :return: a tuple with the identifier and the argument
         """
         var_id = arg.arg
         var_type: IType = self.get_type(arg.annotation)
 
         if var_type is Type.none and isinstance(arg.annotation, ast.Name):
-            var_symbol: ISymbol = self.get_symbol(arg.annotation.id)
+            var_symbol: ISymbol = self.get_symbol(arg.annotation.id, origin_node=arg)
             var_type = self.get_type(var_symbol)
 
+        self._check_annotation_type(arg.annotation, origin_node=arg)
+
         return var_id, Variable(var_type)
 
     def visit_Return(self, ret: ast.Return):
         """
         Visitor of the function return node
 
         If the return is a name, verifies if the symbol is defined
@@ -580,14 +964,17 @@
             symbol = self.get_symbol(symbol_id)
             if symbol is None:
                 # the symbol doesn't exists
                 self._log_error(
                     CompilerError.UnresolvedReference(ret.value.lineno, ret.value.col_offset, symbol_id)
                 )
 
+        if ret.value is not None:
+            self.__set_source_origin(ret.value)
+
     def visit_type(self, target: ast.AST) -> Optional[IType]:
         """
         Gets the type by its identifier
 
         :param target: ast node to be evaluated
         :return: the type of the value inside the node. None by default
         """
@@ -637,53 +1024,69 @@
         """
         Visitor of the variable assignment node
 
         Includes the variable in its scope if it's the first use
 
         :param assign:
         """
-        var_type = self.visit_type(assign.value)
+        # multiple assignments
+        if isinstance(assign.targets[0], ast.Tuple):
+            self._log_error(
+                CompilerError.NotSupportedOperation(assign.lineno, assign.col_offset, 'Multiple variable assignments')
+            )
+
+        else:
+            var_type = self.visit_type(assign.value)
 
-        if var_type is Type.none and isinstance(assign.value, ast.Name):
-            symbol = self.get_symbol(assign.value.id)
-            if isinstance(symbol, Event):
-                var_type = Builtin.Event
-                self._current_event = symbol
-
-        return_type = var_type
-        for target in assign.targets:
-            var_id = self.visit(target)
-            return_type = self.assign_value(var_id, var_type, source_node=assign)
+            if var_type is Type.none and isinstance(assign.value, ast.Name):
+                symbol = self.get_symbol(assign.value.id)
+                if isinstance(symbol, Event):
+                    var_type = Builtin.Event
+                    self._current_event = symbol
+
+            return_type = var_type
+            for target in assign.targets:
+                var_id = self.visit(target)
+                if not isinstance(var_id, ISymbol):
+                    return_type = self.assign_value(var_id, var_type, source_node=assign)
 
-        return return_type
+            return return_type
 
     def visit_AnnAssign(self, ann_assign: ast.AnnAssign):
         """
         Visitor of the annotated variable assignment node
 
         Includes the variable in its scope if it's the first use
 
         :param ann_assign:
         """
         var_id: str = self.visit(ann_assign.target)
         var_type: IType = self.visit_type(ann_assign.annotation)
+        if var_type is Builtin.Event:
+            self.visit(ann_assign.value)
+
+        self._check_annotation_type(ann_assign.annotation, ann_assign)
 
         # TODO: check if the annotated type and the value type are the same
         return self.assign_value(var_id, var_type, source_node=ann_assign, assignment=ann_assign.value is not None)
 
     def assign_value(self, var_id: str, var_type: IType, source_node: ast.AST, assignment: bool = True) -> IType:
         if var_type is Builtin.Event and self._current_event is not None:
             if '' in self._current_module.symbols and self._current_module.symbols[''] is self._current_event:
                 self._current_scope.callables[var_id] = self._current_scope.callables.pop('')
                 self._current_event.name = var_id
             else:
                 self._current_scope.callables[var_id] = self._current_event
             self._current_event = None
         else:
-            self.__include_variable(var_id, var_type, source_node=source_node, assignment=assignment)
+            if isinstance(self._current_scope, UserClass):
+                var = Variable(var_type, source_node)
+                self.__include_class_variable(var_id, var)
+            else:
+                self.__include_variable(var_id, var_type, source_node=source_node, assignment=assignment)
         return var_type
 
     def visit_Global(self, global_node: ast.Global):
         """
         Visitor of the global identifier node
 
         :param global_node:
@@ -719,23 +1122,28 @@
         """
         Verifies if it is the types in the subscription are valid
 
         :param subscript: the python ast subscription node
         :return: if the subscript is not a symbol, returns its type. Otherwise returns the symbol id.
         :rtype: IType or str
         """
+        is_internal = hasattr(subscript, 'is_internal_call') and subscript.is_internal_call
         value = self.visit(subscript.value)
-        symbol = self.get_symbol(value) if isinstance(value, str) else value
+        symbol = self.get_symbol(value, is_internal=is_internal, origin_node=subscript.value) if isinstance(value, str) else value
 
         if isinstance(subscript.ctx, ast.Load):
-            if isinstance(symbol, Collection) and isinstance(subscript.value, (ast.Name, ast.NameConstant)):
+            if (isinstance(symbol, (Collection, MetaType))
+                    and isinstance(subscript.value, (ast.Name, ast.NameConstant, ast.Attribute))):
                 # for evaluating names like List[str], Dict[int, bool], etc
                 value = subscript.slice.value if isinstance(subscript.slice, ast.Index) else subscript.slice
                 values_type: Iterable[IType] = self.get_values_type(value)
-                return symbol.build_collection(*values_type)
+                if isinstance(symbol, Collection):
+                    return symbol.build_collection(*values_type)
+                else:
+                    return symbol.build(*values_type)
 
             symbol_type = self.get_type(symbol)
             if isinstance(subscript.slice, ast.Slice):
                 return symbol_type
 
             if isinstance(symbol, UnionType) or isinstance(symbol_type, UnionType):
                 if not isinstance(symbol_type, UnionType):
@@ -768,17 +1176,18 @@
             value_type = self.get_symbol(value.id)
 
         types: Iterable[Optional[IType]] = value_type if isinstance(value_type, Iterable) else [value_type]
         for tpe in types:
             if not isinstance(tpe, IType):
                 # type hint not using identifiers or using identifiers that are not types
                 index = self.visit(value)
-                self._log_error(
-                    CompilerError.UnresolvedReference(value.lineno, value.col_offset, index)
-                )
+                if isinstance(index, str):
+                    self._log_error(
+                        CompilerError.UnresolvedReference(value.lineno, value.col_offset, index)
+                    )
 
         return types
 
     def visit_Call(self, call: ast.Call) -> Optional[IType]:
         """
         Visitor of a function call node
 
@@ -790,15 +1199,15 @@
 
         # if func_symbol is None, the called function may be a function written after in the code
         # that's why it shouldn't log a compiler error here
         if func_symbol is None:
             return None
 
         if not isinstance(func_symbol, Callable):
-            # verifiy if it is a builtin method with its name shadowed
+            # verify if it is a builtin method with its name shadowed
             func = Builtin.get_symbol(func_id)
             func_symbol = func if func is not None else func_symbol
 
             if func_symbol is Type.exception:
                 func_symbol = Builtin.Exception
             elif isinstance(func_symbol, ClassType):
                 func_symbol = func_symbol.constructor_method()
@@ -822,16 +1231,17 @@
                 if updated_symbol.identifier != func_id:
                     self.__include_callable(updated_symbol.identifier, updated_symbol)
                     return self.get_type(updated_symbol)
 
         return self.get_type(call.func)
 
     def create_new_event(self, create_call: ast.Call) -> Event:
-        event = Event('')
         event_args = create_call.args
+        args = {}
+        name = Builtin.Event.identifier
 
         if len(event_args) < 0:
             self._log_error(
                 CompilerError.UnfilledArgument(line=create_call.lineno,
                                                col=create_call.col_offset,
                                                param=list(Builtin.NewEvent.args)[0])
             )
@@ -853,40 +1263,64 @@
                                                       actual_type_id=self.get_type(value).identifier)
                     elif len(value.elts) < 2:
                         self._log_error(
                             CompilerError.UnfilledArgument(line=value.lineno,
                                                            col=value.col_offset,
                                                            param=list(Builtin.NewEvent.args)[0])
                         )
-                    elif not (isinstance(value.elts[0], ast.Str) and
-                              ((isinstance(value.elts[1], ast.Name)  # if is name, get the type of its id
-                                and isinstance(self.get_symbol(value.elts[1].id), IType))
-                               or isinstance(self.visit(value.elts[1]), IType)  # otherwise, if the result is a type
-                               )):
-                        CompilerError.MismatchedTypes(line=value.lineno,
-                                                      col=value.col_offset,
-                                                      expected_type_id=Type.tuple.identifier,
-                                                      actual_type_id=self.get_type(value).identifier)
                     else:
-                        arg_name = value.elts[0].s
-                        arg_type = (self.get_symbol(value.elts[1].id)
-                                    if isinstance(value.elts[1], ast.Name)
-                                    else self.visit(value.elts[1]))
-                        event.args[arg_name] = Variable(arg_type)
+                        event_arg_name, event_arg_type = value.elts
+                        are_types_valid = True
+                        if not isinstance(event_arg_name, ast.Str):
+                            are_types_valid = False
+                        else:
+                            if isinstance(event_arg_type, ast.Name):  # if is name, get the type of its id
+                                arg_type = self.get_symbol(event_arg_type.id)
+                            else:  # otherwise, if the result is a type
+                                arg_type = self.visit(event_arg_type)
+
+                            from boa3.internal.neo.vm.type.AbiType import AbiType
+                            if not isinstance(arg_type, IType):
+                                are_types_valid = False
+                            elif arg_type.abi_type is AbiType.InteropInterface:
+                                self._log_error(
+                                    CompilerError.MismatchedTypes(line=event_arg_type.lineno,
+                                                                  col=event_arg_type.col_offset,
+                                                                  expected_type_id=MetaType.build().identifier,
+                                                                  actual_type_id=arg_type.identifier)
+                                )
+
+                        if not are_types_valid:
+                            self._log_error(
+                                CompilerError.MismatchedTypes(line=value.lineno,
+                                                              col=value.col_offset,
+                                                              expected_type_id=Type.tuple.identifier,
+                                                              actual_type_id=self.get_type(value).identifier)
+                            )
+                        else:
+                            arg_name = event_arg_name.s
+                            arg_type = (self.get_symbol(event_arg_type.id)
+                                        if isinstance(event_arg_type, ast.Name)
+                                        else self.visit(event_arg_type))
+                            args[arg_name] = Variable(arg_type)
 
             if len(event_args) > 1:
                 if not isinstance(event_args[1], ast.Str):
                     name_type = self.get_type(event_args[1])
-                    CompilerError.MismatchedTypes(line=event_args[1].lineno,
-                                                  col=event_args[1].col_offset,
-                                                  expected_type_id=Type.str.identifier,
-                                                  actual_type_id=name_type.identifier)
+                    self._log_error(
+                        CompilerError.MismatchedTypes(line=event_args[1].lineno,
+                                                      col=event_args[1].col_offset,
+                                                      expected_type_id=Type.str.identifier,
+                                                      actual_type_id=name_type.identifier)
+                    )
                 else:
-                    event.name = event_args[1].s
+                    name = event_args[1].s
 
+        event = Event(name, args)
+        event._origin_node = create_call
         return event
 
     def visit_Attribute(self, attribute: ast.Attribute) -> Union[ISymbol, str]:
         """
         Gets the attribute inside the ast node
 
         :param attribute: the python ast attribute node
@@ -896,16 +1330,20 @@
         value_id = attribute.value.id if isinstance(attribute.value, ast.Name) else None
         value: ISymbol = self.get_symbol(value_id) if value_id is not None else self.visit(attribute.value)
 
         if isinstance(value, Variable):
             value = value.type
         if hasattr(value, 'symbols') and attribute.attr in value.symbols:
             return value.symbols[attribute.attr]
+        elif isinstance(value, Package) and attribute.attr in value.inner_packages:
+            return value.inner_packages[attribute.attr]
         elif Builtin.get_symbol(attribute.attr) is not None:
             return Builtin.get_symbol(attribute.attr)
+        elif isinstance(value, UndefinedType):
+            return value
         else:
             return '{0}.{1}'.format(value_id, attribute.attr)
 
     def visit_For(self, for_node: ast.For):
         """
         Visitor of for statement node
```

### Comparing `neo3-boa-0.9.0/boa3/analyser/typeanalyser.py` & `neo3-boa-1.0.0/boa3/internal/analyser/typeanalyser.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,59 +1,79 @@
 import ast
 from typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union
 
-from boa3.analyser.astanalyser import IAstAnalyser
-from boa3.analyser.builtinfunctioncallanalyser import BuiltinFunctionCallAnalyser
-from boa3.analyser.model.optimizer import UndefinedType
-from boa3.analyser.model.symbolscope import SymbolScope
-from boa3.exception import CompilerError, CompilerWarning
-from boa3.model.attribute import Attribute
-from boa3.model.builtin.builtin import Builtin
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.callable import Callable
-from boa3.model.expression import IExpression
-from boa3.model.imports.importsymbol import Import
-from boa3.model.imports.package import Package
-from boa3.model.method import Method
-from boa3.model.module import Module
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.binaryop import BinaryOp
-from boa3.model.operation.operation import IOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary.unaryoperation import UnaryOperation
-from boa3.model.operation.unaryop import UnaryOp
-from boa3.model.symbol import ISymbol
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.collection.icollection import ICollectionType as Collection
-from boa3.model.type.type import IType, Type
-from boa3.model.type.typeutils import TypeUtils
-from boa3.model.variable import Variable
+from boa3.internal import constants
+from boa3.internal.analyser.astanalyser import IAstAnalyser
+from boa3.internal.analyser.builtinfunctioncallanalyser import BuiltinFunctionCallAnalyser
+from boa3.internal.analyser.model.optimizer import Undefined, UndefinedType
+from boa3.internal.analyser.model.symbolscope import SymbolScope
+from boa3.internal.exception import CompilerError, CompilerWarning
+from boa3.internal.model.attribute import Attribute
+from boa3.internal.model.builtin.builtin import Builtin
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.imports.importsymbol import Import
+from boa3.internal.model.imports.package import Package
+from boa3.internal.model.method import Method
+from boa3.internal.model.module import Module
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.binaryop import BinaryOp
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.operation.unaryop import UnaryOp
+from boa3.internal.model.property import Property
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.annotation.metatype import MetaType
+from boa3.internal.model.type.annotation.uniontype import UnionType
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.classes.pythonclass import PythonClass
+from boa3.internal.model.type.classes.userclass import UserClass
+from boa3.internal.model.type.collection.icollection import ICollectionType as Collection
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.model.type.typeutils import TypeUtils
+from boa3.internal.model.variable import Variable
 
 
 class TypeAnalyser(IAstAnalyser, ast.NodeVisitor):
     """
     This class is responsible for the type checking of the code
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
 
     :ivar type_errors: a list with the found type errors. Empty by default.
     :ivar modules: a list with the analysed modules. Empty by default.
     :ivar symbols: a dictionary that maps the global symbols.
     """
 
-    def __init__(self, analyser, symbol_table: Dict[str, ISymbol], log: bool = False):
-        super().__init__(analyser.ast_tree, log=log)
+    def __init__(self, analyser, symbol_table: Dict[str, ISymbol], log: bool = False, fail_fast: bool = True):
+        super().__init__(analyser.ast_tree, analyser.filename, analyser.root, log=log, fail_fast=fail_fast)
         self.type_errors: List[Exception] = []
         self.modules: Dict[str, Module] = {}
         self.symbols: Dict[str, ISymbol] = symbol_table
 
+        self._current_class: UserClass = None
         self._current_method: Method = None
         self._scope_stack: List[SymbolScope] = []
-        self.visit(self._tree)
+
+        self._super_calls: List[IBuiltinMethod] = []
+        self.analyse_visit(self._tree)
+
+    def visit(self, node: ast.AST, get_literal_value: bool = False):
+        if get_literal_value:
+            node.get_literal_value = True
+
+        result = super().visit(node)
+
+        if hasattr(node, 'get_literal_value'):
+            delattr(node, 'get_literal_value')
+
+        return result
 
     @property
     def _current_method_id(self) -> str:
         """
         Get the string identifier of the current method
 
         :return: The name identifier of the method. If the current method is None, returns None.
@@ -77,15 +97,16 @@
         symbols = {}
         for module in self.modules.values():
             symbols.update(module.symbols)
         return symbols
 
     def get_symbol(self, symbol_id: str,
                    is_internal: bool = False,
-                   check_raw_id: bool = False) -> Optional[ISymbol]:
+                   check_raw_id: bool = False,
+                   origin_node: ast.AST = None) -> Optional[ISymbol]:
         if symbol_id is None:
             return None
         if isinstance(symbol_id, ISymbol) and not isinstance(symbol_id, (IType, IExpression)):
             return symbol_id
         if not isinstance(symbol_id, str):
             return Variable(self.get_type(symbol_id))
 
@@ -98,24 +119,34 @@
                     found_symbol = self._search_by_raw_id(symbol_id, list(scope.symbols.values()))
                     if found_symbol is not None:
                         return found_symbol
 
         if self._current_method is not None and symbol_id in self._current_method.symbols:
             # the symbol exists in the local scope
             return self._current_method.symbols[symbol_id]
+        elif self._current_class is not None and symbol_id in self._current_class.symbols:
+            # the symbol exists in the class
+            return self._current_class.symbols[symbol_id]
         elif symbol_id in self.modules:
             # the symbol exists in the modules scope
             return self.modules[symbol_id]
 
+        if self._current_method is not None:
+            cur_symbols = self._current_method.symbols
+        elif self._current_class is not None:
+            cur_symbols = self._current_class.symbols
+        else:
+            cur_symbols = self.modules
+
         if check_raw_id:
-            found_symbol = self._search_by_raw_id(symbol_id, list(self._current_method.symbols.values()))
+            found_symbol = self._search_by_raw_id(symbol_id, list(cur_symbols.values()))
             if found_symbol is not None:
                 return found_symbol
 
-        return super().get_symbol(symbol_id, is_internal, check_raw_id)
+        return super().get_symbol(symbol_id, is_internal, check_raw_id, origin_node)
 
     def new_local_scope(self, symbols: Dict[str, ISymbol] = None):
         if symbols is None:
             symbols = self._current_scope.symbols if self._current_scope is not None else {}
 
         self._scope_stack.append(SymbolScope(symbols))
 
@@ -129,37 +160,66 @@
         Performs the type checking in the body of the method
 
         :param module: the python ast module node
         """
         for stmt in module.body:
             self.visit(stmt)
 
+    def visit_ClassDef(self, node: ast.ClassDef) -> Any:
+        if node.name in self.symbols:
+            class_symbol = self.symbols[node.name]
+            if isinstance(class_symbol, UserClass):
+                self._current_class = class_symbol
+
+        self.generic_visit(node)
+        self._current_class = None
+
     def visit_FunctionDef(self, function: ast.FunctionDef):
         """
         Visitor of the function node
 
         Performs the type checking in the body of the function
 
         :param function: the python ast function definition node
         """
         self.visit(function.args)
-        method = self.symbols[function.name]
 
-        from boa3.model.event import Event
+        symbols = self.symbols if self._current_class is None else self._current_class.symbols
+        method = symbols[function.name]
+
+        from boa3.internal.model.event import Event
+        if isinstance(method, Property):
+            method = method.getter
+
         if isinstance(method, Method):
             self._current_method = method
             self.new_local_scope({var_id: var for var_id, var in method.symbols.items()
                                   if isinstance(var, Variable) and var.type is not UndefinedType})
 
-            for stmt in function.body:
-                self.visit(stmt)
+            if self._current_class is not None and self._current_class.is_interface and len(function.body) > 0:
+                first_instruction = function.body[0]
+                if not isinstance(first_instruction, ast.Pass):
+                    self._log_warning(CompilerWarning.UnreachableCode(first_instruction.lineno,
+                                                                      first_instruction.col_offset))
+            else:
+                for stmt in function.body:
+                    self.visit(stmt)
 
-            self._validate_return(function)
+            if method.is_init:
+                self._check_base_init_call(function)
+            else:
+                self._validate_return(function)
 
             method_scope = self.pop_local_scope()
+            for symbol_id, symbol in self._current_method.symbols.items():
+                if isinstance(symbol, Variable) and symbol.type is UndefinedType and symbol_id in method_scope:
+                    new_scope_symbol = method_scope[symbol_id]
+                    if hasattr(new_scope_symbol, 'type') and new_scope_symbol.type is not UndefinedType:
+                        symbol.set_type(new_scope_symbol.type)
+
             self._current_method = None
         elif (isinstance(method, Event)  # events don't have return
               and function.returns is not None):
             return_type = self.get_type(function.returns)
             if return_type is not Type.none:
                 self._log_error(
                     CompilerError.MismatchedTypes(line=function.lineno, col=function.col_offset,
@@ -195,15 +255,17 @@
 
     def visit_Return(self, ret: ast.Return):
         """
         Verifies if the return of the function is the same type as the return type annotation
 
         :param ret: the python ast return node
         """
-        ret_value: Any = self.visit(ret.value) if ret.value is not None else None
+        ret_value: Any = (self.visit(ret.value, get_literal_value=True)
+                          if ret.value is not None
+                          else None)
         if ret.value is not None and self.get_type(ret.value) is not Type.none:
             # multiple returns are not allowed
             if isinstance(ret.value, ast.Tuple):
                 self._log_error(
                     CompilerError.TooManyReturns(ret.lineno, ret.col_offset)
                 )
                 return
@@ -252,31 +314,37 @@
             if any(isinstance(stmt, (ast.Return, ast.Pass)) for stmt in node.orelse):
                 return True
             else:
                 orelse = [stmt for stmt in node.orelse if hasattr(stmt, 'body')]
                 return len(orelse) > 0 and all(self._has_return(stmt) for stmt in orelse)
         return body_has_inner_return
 
+    def _check_base_init_call(self, node: ast.AST):
+        if not self._current_method.is_init or not isinstance(self._current_class, ClassType):
+            # if the method is not an user class __init__, don't check
+            return
+
+        if len(self._current_class.bases) == 0:
+            # nothing to check if class has no bases
+            return
+
+        if len(self._super_calls) == 0:
+            self._log_error(CompilerError.MissingInitCall(line=node.lineno,
+                                                          col=node.col_offset))
+        else:
+            self._super_calls.clear()
+
     def visit_Assign(self, assign: ast.Assign):
         """
         Verifies if it is a multiple assignments statement
 
         :param assign: the python ast variable assignment node
         """
-        # multiple assignments
-        if isinstance(assign.targets[0], ast.Tuple):
-            self._log_error(
-                CompilerError.NotSupportedOperation(assign.lineno, assign.col_offset, 'Multiple variable assignments')
-            )
-        else:
-            for target in assign.targets:
-                self.validate_type_variable_assign(target, assign.value)
-
-        # continue to walk through the tree
-        self.generic_visit(assign)
+        for target in assign.targets:
+            self.validate_type_variable_assign(target, assign.value)
 
     def visit_AnnAssign(self, ann_assign: ast.AnnAssign):
         """
         Verifies if the assigned type is the same as the variable type
 
         :param ann_assign: the python ast variable annotated assignment node
         """
@@ -313,59 +381,66 @@
                         CompilerError.UnresolvedReference(
                             value.lineno, value.col_offset,
                             symbol_id=value.id
                         ))
 
         if target is not None:
             target_type = self.get_type(target)
-        elif not isinstance(node, ast.Name):
-            target_type = self.get_type(node)
         else:
-            var: ISymbol = self.get_symbol(node.id)
-            if not isinstance(var, Variable):
+            target_type = None
+            var: ISymbol = self.get_symbol(node.id if hasattr(node, 'id') else node)
+            if isinstance(var, Variable):
+                if (var.type is UndefinedType
+                        or (var.type is Undefined and var not in self.symbols.values())):
+                    var = var.copy()
+
+                if var.type in (None, UndefinedType, Undefined):
+                    # it is an declaration with assignment and the value is neither literal nor another variable
+                    var.set_type(value_type)
+                target_type = var.type
+
+            elif isinstance(node, ast.Name):
                 self._log_error(
                     CompilerError.UnresolvedReference(
                         node.lineno, node.col_offset,
                         symbol_id=node.id
                     ))
                 return False
 
-            if var.type is UndefinedType:
-                var = var.copy()
-
-            if var.type in (None, UndefinedType):
-                # it is an declaration with assignment and the value is neither literal nor another variable
-                var.set_type(value_type)
-            target_type = var.type
-
         if self._current_scope is not None:
             if isinstance(node, ast.Name):
                 if node.id not in self._current_scope:
-                    if not isinstance(value_type, Collection):
+                    if implicit_cast:
+                        value_type = target_type
+                    elif not isinstance(value_type, Collection):
                         target_type = value_type
                     elif not (isinstance(type(value_type), type(target_type)) and
                               (value_type.value_type is Type.any or value_type.valid_key is Type.any)):
                         # if the collection is generic, let the validation for the outer scope
                         value_type = target_type
 
                     self._current_scope.include_symbol(node.id, Variable(value_type))
 
                 else:
                     if self._current_method is not None and node.id in self._current_method.symbols:
-                        can_change_target_type = self._current_method.symbols[node.id].type is UndefinedType
+                        can_change_target_type = (self._current_method.symbols[node.id].type is UndefinedType
+                                                  or node.id in self._current_method.args)
+                        can_change_original = node.id not in self._current_method.args
                     else:
                         can_change_target_type = True
+                        can_change_original = True
 
                     if can_change_target_type:
                         if (not target_type.is_type_of(value_type) and
                                 value != target_type.default_value):
                             target_type = value_type
-                        self._current_scope.include_symbol(node.id, Variable(value_type))
+                        self._current_scope.include_symbol(node.id, Variable(value_type),
+                                                           reassign_original=can_change_original)
 
-        if not target_type.is_type_of(value_type) and value != target_type.default_value:
+        if not target_type.is_type_of(value_type) and not self._has_only_default_values(value, target_type):
             if not implicit_cast:
                 self._log_error(
                     CompilerError.MismatchedTypes(
                         node.lineno, node.col_offset,
                         actual_type_id=value_type.identifier,
                         expected_type_id=target_type.identifier
                     ))
@@ -377,14 +452,38 @@
                         origin_type_id=value_type.identifier,
                         cast_type_id=target_type.identifier
                     )
                 )
 
         return True
 
+    def _has_only_default_values(self, value: Any, target_type: Optional[IType] = None) -> bool:
+        if not isinstance(target_type, IType):
+            target_type = self.get_type(value)
+
+        has_only_default_values = value == target_type.default_value
+        if not has_only_default_values and isinstance(target_type, Collection) and hasattr(value, '__len__'):
+            has_only_default_values = True
+            if isinstance(value, dict):
+                for key, item in value.items():
+                    if not self._has_only_default_values(key):
+                        has_only_default_values = False
+                        break
+
+                    if not self._has_only_default_values(item):
+                        has_only_default_values = False
+                        break
+            else:
+                for item in value:
+                    if not self._has_only_default_values(item):
+                        has_only_default_values = False
+                        break
+
+        return has_only_default_values
+
     def visit_Subscript(self, subscript: ast.Subscript) -> IType:
         """
         Verifies if the subscribed value is a sequence
 
         :param subscript: the python ast subscript node
         :return: the type of the accessed value if it is valid. Type.none otherwise.
         """
@@ -397,29 +496,37 @@
         """
         Verifies if the subscribed value is a sequence and if the index is valid to this sequence
 
         :param subscript: the python ast subscript node
         :param index_node: the subscript index
         :return: the type of the accessed value if it is valid. Type.none otherwise.
         """
+        is_internal = hasattr(subscript, 'is_internal_call') and subscript.is_internal_call
+
         value = self.visit(subscript.value)
         index = self.visit(index_node)
 
         if isinstance(value, ast.Name):
-            value = self.get_symbol(value.id)
+            value = self.get_symbol(value.id, is_internal=is_internal)
         if isinstance(index, ast.Name):
-            index = self.get_symbol(index.id)
+            index = self.get_symbol(index.id, is_internal=is_internal)
         if not isinstance(index, tuple):
             index = (index,)
 
         # if it is a type hint, returns the outer type
         if isinstance(value, IType) and all(isinstance(i, IType) for i in index):
             if isinstance(value, Collection):
                 value = value.build_collection(*index)
-            return TypeUtils.type.build(value)
+            elif isinstance(value, UnionType):
+                value = value.build(index)
+
+            value_to_be_built = index if isinstance(value, MetaType) else value
+            if not isinstance(value_to_be_built, tuple):
+                value_to_be_built = (value_to_be_built,)
+            return TypeUtils.type.build(*value_to_be_built)
 
         symbol_type: IType = self.get_type(value)
         index_type: IType = self.get_type(index[0])
 
         # only sequence types can be subscribed
         if not isinstance(symbol_type, Collection):
             self._log_error(
@@ -454,39 +561,28 @@
         :param subscript: the python ast subscript node
         :param slice_node: the subscript slice
         :return: the type of the accessed value if it is valid. Type.none otherwise.
         """
         value = self.visit(subscript.value)
         lower, upper, step = (self.get_type(value) for value in self.visit(slice_node))
 
-        if step is not Type.none:
-            # TODO: remove when slices with stride are implemented
-            raise NotImplementedError
-        # is not allowed to store into a slice
-        if isinstance(subscript.ctx, ast.Store):
-            self._log_error(
-                CompilerError.NotSupportedOperation(
-                    subscript.lineno, subscript.col_offset,
-                    symbol_id=Operator.Subscript
-                )
-            )
-
         symbol_type: IType = self.get_type(value)
         # only collection types can be subscribed
         if not isinstance(symbol_type, Collection):
             self._log_error(
                 CompilerError.UnresolvedOperation(
                     subscript.lineno, subscript.col_offset,
                     type_id=symbol_type.identifier,
                     operation_id=Operator.Subscript)
             )
             return Type.none
 
         lower = lower if lower is not Type.none else symbol_type.valid_key
         upper = upper if upper is not Type.none else symbol_type.valid_key
+        step = step if step is not Type.none else symbol_type.valid_key
 
         # TODO: remove when slices of other sequence types are implemented
         if (not symbol_type.is_valid_key(lower)
                 or not symbol_type.is_valid_key(upper)
                 or (step is not Type.none and not symbol_type.is_valid_key(step))
             ):
             actual: Tuple[IType, ...] = (lower, upper) if step is Type.none else (lower, upper, step)
@@ -585,21 +681,29 @@
             last_scope.include_symbol(changed_symbol, Variable(new_type))
 
         # updates with the variables assigned in a branch that doesn't exist in the outer scope
         self._include_symbols_to_scope(last_scope, is_instance_if, intersected_ids)
         self._include_symbols_to_scope(last_scope, is_instance_else, intersected_ids)
 
     def _include_symbols_to_scope(self, scope: SymbolScope, other_scope: Dict[str, ISymbol], items_filter: Set[str]):
-        for new_symbol in {key for key in other_scope if key not in items_filter}:
-            new_value_type = self.get_type(other_scope[new_symbol])
-            outer_symbol = self.get_symbol(new_symbol)
+        for new_symbol_id in {key for key in other_scope if key not in items_filter}:
+            new_symbol = other_scope[new_symbol_id]
+            new_value_type = self.get_type(new_symbol)
+            outer_symbol = self.get_symbol(new_symbol_id)
             outer_value_type = outer_symbol.type if isinstance(outer_symbol, IExpression) else Type.none
 
-            new_type = Type.union.build([new_value_type, outer_value_type])
-            scope.include_symbol(new_symbol, Variable(new_type))
+            if (isinstance(outer_symbol, Variable) and isinstance(new_symbol, Variable)
+                    and not new_symbol.is_reassigned):
+                continue
+
+            if isinstance(outer_symbol, IType):
+                new_type = Type.union.build([new_value_type, outer_value_type])
+            else:
+                new_type = new_value_type
+            scope.include_symbol(new_symbol_id, Variable(new_type))
 
     def visit_IfExp(self, if_node: ast.IfExp):
         """
         Verifies if the type of if test is valid
 
         :param if_node: the python ast if expression node
         """
@@ -625,26 +729,18 @@
 
         :param if_node: the python ast if statement node
         :type if_node: ast.If or ast.IfExp
         """
         test = self.visit(if_node.test)
         test_type: IType = self.get_type(test)
 
-        if test_type is not Type.bool:
-            self._log_error(
-                CompilerError.MismatchedTypes(
-                    if_node.lineno, if_node.col_offset,
-                    actual_type_id=test_type.identifier,
-                    expected_type_id=Type.bool.identifier)
-            )
-
         return self._get_is_instance_function_calls(if_node.test)
 
     def _get_is_instance_function_calls(self, node: ast.AST) -> Tuple[Dict[str, ISymbol], Dict[str, ISymbol]]:
-        from boa3.model.builtin.method.isinstancemethod import IsInstanceMethod
+        from boa3.internal.model.builtin.method.isinstancemethod import IsInstanceMethod
         is_instance_objs = [x for x, symbol in self.symbols.items()
                             if isinstance(symbol, IsInstanceMethod)]
         is_instance_objs.append(isinstance.__name__)
 
         is_instance_symbols = {}
         is_not_instance_symbols = {}
 
@@ -655,42 +751,62 @@
 
         for condition in conditions:
             negate = False
             if isinstance(condition, ast.UnaryOp) and isinstance(condition.op, type(UnaryOp.Not)):
                 condition = condition.operand
                 negate = True
 
-            if (isinstance(condition, ast.Call) and isinstance(condition.func, ast.Name)
-                    and condition.func.id in is_instance_objs and len(condition.args) == 2):
-                original = self.get_symbol(condition.args[0])
-                if isinstance(original, Variable) and isinstance(condition.args[0], ast.Name):
-                    original_id = condition.args[0].id
+            # verifies if condition is an is_instance condition
+            is_instance_condition = (isinstance(condition, ast.Call) and isinstance(condition.func, ast.Name)
+                                     and condition.func.id in is_instance_objs and len(condition.args) == 2)
+
+            # verifies if condition is a identity condition (is None or is not None)
+            identity_condition = (isinstance(condition, ast.Compare)
+                                  and isinstance(condition.ops[0], (type(BinaryOp.IsNone), type(BinaryOp.IsNotNone))))
+
+            if identity_condition and isinstance(condition.ops[0], type(BinaryOp.IsNotNone)):
+                negate = True
+
+            if is_instance_condition or identity_condition:
+                if is_instance_condition:
+                    left_value = condition.args[0]
+                    right_value = condition.args[1]
+
+                else:
+                    left_value = condition.left
+                    right_value = Type.none
+
+                original = self.get_symbol(left_value)
+                if isinstance(original, Variable) and isinstance(left_value, ast.Name):
+                    original_id = left_value.id
                     original_type = (original.type
                                      if original_id not in is_instance_symbols
                                      else is_instance_symbols[original_id])
 
-                    instance_obj = self.get_symbol(condition.func.id)
+                    instance_obj = self.get_symbol(condition.func.id) if is_instance_condition else None
                     if isinstance(instance_obj, type(Builtin.IsInstance)):
                         is_instance_type = instance_obj._instances_type
                         if isinstance(is_instance_type, list):
                             is_instance_type = Type.union.build(is_instance_type)
                     else:
-                        is_instance_type = self.get_type(condition.args[1])
+                        is_instance_type = self.get_type(right_value)
                     is_instance_type = is_instance_type.intersect_type(original_type)
                     negation = original_type.except_type(is_instance_type)
                     resulting_type = is_instance_type if not negate else negation
 
                     if original_id not in is_not_instance_symbols:
                         is_instance_symbols[original_id] = resulting_type
                     else:
                         is_instance_symbols[original_id] = is_instance_symbols[original_id].except_type(resulting_type)
 
                     if len(is_instance_symbols) == 1:
                         is_not_instance_symbols[original_id] = is_instance_type if negate else negation
-                    elif len(is_not_instance_symbols) > 1:
+                    elif len(is_not_instance_symbols) == 1:
+                        # if there is more than one isinstance it's not possible to determine in compiler time what is
+                        # the type of the variables on the else body
                         is_not_instance_symbols.clear()
 
         for key, value in is_instance_symbols.copy().items():
             if value == self.get_type(self.get_symbol(key)):
                 is_instance_symbols.pop(key)
             else:
                 is_instance_symbols[key] = Variable(value)
@@ -742,15 +858,14 @@
         try:
             operation: IOperation = self.get_bin_op(operator, r_operand, l_operand)
             if operation is None:
                 self._log_error(
                     CompilerError.NotSupportedOperation(node.lineno, node.col_offset, operator)
                 )
             elif not operation.is_supported:
-                # TODO: concat and power not implemented yet
                 # number float division is not supported by Neo VM
                 self._log_error(
                     CompilerError.NotSupportedOperation(node.lineno, node.col_offset, operator)
                 )
             else:
                 return operation
         except CompilerError.MismatchedTypes as raised_error:
@@ -849,14 +964,40 @@
         if operation is not None:
             return operation
         else:
             expected_op: UnaryOperation = UnaryOp.get_operation_by_operator(operator)
             expected_type: str = expected_op.operand_type.identifier
             raise CompilerError.MismatchedTypes(0, 0, expected_type, actual_type)
 
+    def visit_Assert(self, assert_: ast.Assert):
+        """
+        Verifies if the types of condition and error message in the assert are valid
+
+        If the operations are valid, changes de Python operator by the Boa operator in the syntax tree
+
+        :param assert_: the python ast assert operation node
+        :return: the type of the result of the operation if the operation is valid. Otherwise, returns None
+        """
+        self.visit(assert_.test)
+
+        if assert_.msg is not None:
+            msg = self.visit(assert_.msg)
+            msg_type = self.get_type(msg)
+
+            if not Type.str.is_type_of(msg_type) and not Type.bytes.is_type_of(msg_type):
+
+                # TODO: remove this error when str constructor is implemented
+                self._log_error(
+                    CompilerError.MismatchedTypes(
+                        assert_.msg.lineno, assert_.msg.col_offset,
+                        expected_type_id=Type.str.identifier,
+                        actual_type_id=str(msg_type)
+                    )
+                )
+
     def visit_Compare(self, compare: ast.Compare) -> Optional[IType]:
         """
         Verifies if the types of the operands are valid to the compare operations
 
         If the operations are valid, changes de Python operator by the Boa operator in the syntax tree
 
         :param compare: the python ast compare operation node
@@ -890,15 +1031,14 @@
 
                 operation: IOperation = self.get_bin_op(operator, r_operand, l_operand)
                 if operation is None:
                     self._log_error(
                         CompilerError.NotSupportedOperation(line, col, operator)
                     )
                 elif not operation.is_supported:
-                    # TODO: is, is not and eq were not implemented yet
                     self._log_error(
                         CompilerError.NotSupportedOperation(line, col, operator)
                     )
                 else:
                     compare.ops[index] = operation
                     return_type = operation.result
 
@@ -988,42 +1128,43 @@
         if isinstance(call.func, ast.Name):
             callable_id: str = call.func.id
             is_internal = hasattr(call, 'is_internal_call') and call.is_internal_call
             callable_target = self.get_symbol(callable_id, is_internal)
         else:
             callable_id, callable_target = self.get_callable_and_update_args(call)  # type: str, ISymbol
 
-        callable_target = self.validate_builtin_callable(callable_id, callable_target)
+        callable_target = self.validate_builtin_callable(callable_id, callable_target, call.args)
 
         if not isinstance(callable_target, Callable):
             # if the outer call is a builtin, enable call even without the import
             builtin_symbol = Builtin.get_symbol(callable_id)
             if builtin_symbol is not None:
                 callable_target = builtin_symbol
 
         callable_method_id = None
         if isinstance(callable_target, ClassType):
             callable_target = callable_target.constructor_method()
-            callable_method_id = '__init__'
+            callable_method_id = constants.INIT_METHOD_ID
 
         if not isinstance(callable_target, Callable):
-            # the symbol doesn't exists or is not a function
+            # the symbol doesn't exist or is not a function
             # if it is None, the error was already logged
             if callable_id is not None:
                 if callable_method_id is not None:
                     callable_id = '{0}.{1}()'.format(callable_id, callable_method_id)
                 self._log_error(
                     CompilerError.UnresolvedReference(call.func.lineno, call.func.col_offset, callable_id)
                 )
         else:
+            if not self.check_call_scope(call, callable_target, callable_id):
+                # errors are logged and handled by the method itself
+                return self.get_type(callable_target)
+
             if callable_target is Builtin.NewEvent:
                 return callable_target.return_type
-            # TODO: change when kwargs is implemented
-            if len(call.keywords) > 0:
-                raise NotImplementedError
 
             private_identifier = None  # used for validating internal builtin methods
             if self.validate_callable_arguments(call, callable_target):
                 args = [self.get_type(param, use_metatype=True) for param in call.args]
                 if isinstance(callable_target, IBuiltinMethod):
                     # if the arguments are not generic, build the specified method
                     if callable_target.raw_identifier.startswith('-'):
@@ -1060,33 +1201,58 @@
                 callable_id = private_identifier
             self.update_callable_after_validation(call, callable_id, callable_target)
 
         return self.get_type(callable_target)
 
     def get_callable_and_update_args(self, call: ast.Call) -> Tuple[str, ISymbol]:
         attr: Attribute = self.visit(call.func)
+        if not isinstance(attr, Attribute):
+            attr_id = str(attr)
+            attr_id_split = attr_id.split(constants.ATTRIBUTE_NAME_SEPARATOR)
+            attr_call_id = attr_id
+            if len(attr_id_split) > 0:
+                attr_call_id = constants.ATTRIBUTE_NAME_SEPARATOR.join(attr_id_split[:-1])
+
+            self._log_error(
+                CompilerError.UnresolvedReference(call.func.lineno, call.func.col_offset, attr_call_id)
+            )
+
+            return attr_id, None
+
         arg0, callable_target, callable_id = attr.values
 
         if isinstance(arg0, Package):
             # visit works only with ast classes
             package = arg0
             package_symbol = self.get_symbol(package.identifier, check_raw_id=True)
 
             while package_symbol is None and package.parent is not None:
                 package = package.parent
                 package_symbol = self.get_symbol(package.identifier, check_raw_id=True)
-            arg0_identifier = package_symbol if package_symbol else package.identifier
-        else:
+
+            if package_symbol is None:
+                arg0_identifier = package.identifier
+            elif isinstance(package_symbol, Package):
+                arg0_identifier = package_symbol
+            else:
+                arg0_identifier = package
+
+        elif isinstance(arg0, UserClass):
+            arg0_identifier = arg0.identifier
+        elif isinstance(arg0, ast.AST):
             arg0_identifier = self.visit(arg0)
+        else:
+            arg0_identifier = None
 
         if isinstance(arg0_identifier, ast.Name):
             arg0_identifier = arg0_identifier.id
 
         if (callable_target is not None
                 and not isinstance(self.get_symbol(arg0_identifier), (IType, Import, Package))
+                and not isinstance(arg0_identifier, UserClass)
                 and (len(call.args) < 1 or call.args[0] != arg0)):
             # move self to the arguments
             # don't move if it's class method
             if not (isinstance(arg0, ClassType) and callable_id in arg0.class_methods):
                 call.args.insert(0, arg0)
 
         if len(call.args) > 0 and isinstance(callable_target, IBuiltinMethod) and callable_target.has_self_argument:
@@ -1094,51 +1260,153 @@
             caller = self.get_symbol(arg0_identifier)
             if isinstance(caller, IType) and not caller.is_type_of(self_type):
                 self_type = caller
             callable_target = callable_target.build(self_type)
 
         return callable_id, callable_target
 
-    def validate_builtin_callable(self, callable_id: str, callable_target: ISymbol) -> ISymbol:
+    def check_call_scope(self, call: ast.Call, callable: Callable, callable_id: str):
+        error_count = len(self.errors)
+        if not isinstance(call.func, ast.Attribute):
+            # if the call doesn't came from an attribute, there's nothing to be validated
+            return True
+
+        attr_node: ast.Attribute = call.func
+        if isinstance(attr_node.value, ast.Name):
+            attribute_symbol = self.get_symbol(attr_node.value.id)
+        else:
+            attribute_symbol = self.get_symbol(attr_node.value)
+        is_from_type_name = isinstance(attribute_symbol, IType)
+
+        attribute_type = self.get_type(attribute_symbol)
+        if not isinstance(attribute_type, UserClass):
+            # TODO: change when class specific scopes are implemented in the built-ins
+            return True
+
+        # TODO: remove this verification when calling an instance function from a class is implemented
+        if is_from_type_name and isinstance(callable, Method) and hasattr(attribute_symbol, 'instance_methods') \
+                and callable_id in attribute_symbol.instance_methods:
+            callable_complete_id = f'{attribute_type.identifier}.{callable_id}'
+            self._log_error(
+                CompilerError.NotSupportedOperation(call.func.lineno, call.func.col_offset, callable_complete_id)
+            )
+        elif is_from_type_name and callable_id not in attribute_type.class_symbols:
+            # the current symbol doesn't exist in the class scope
+            callable_complete_id = f'{attribute_type.identifier}.{callable_id}'
+            self._log_error(
+                CompilerError.UnresolvedReference(call.func.lineno, call.func.col_offset, callable_complete_id)
+            )
+        elif not is_from_type_name and callable_id not in attribute_type.instance_symbols:
+            # the current symbol doesn't exist in the instance scope
+            callable_complete_id = f'{attribute_type.identifier}().{callable_id}'
+            self._log_error(
+                CompilerError.UnresolvedReference(call.func.lineno, call.func.col_offset, callable_complete_id)
+            )
+
+        return len(self.errors) == error_count
+
+    def validate_builtin_callable(self, callable_id: str, callable_target: ISymbol,
+                                  call_args: List[ast.AST] = None) -> ISymbol:
+        if call_args is None:
+            call_args = []
+
         if not isinstance(callable_target, Callable):
             # verify if it is a builtin method with its name shadowed
             call_target = Builtin.get_symbol(callable_id)
-            if not isinstance(call_target, Callable) and self.is_exception(callable_id):
-                call_target = Builtin.Exception
+            if not isinstance(call_target, Callable):
+                if self.is_exception(callable_id):
+                    call_target = Builtin.Exception
+                elif hasattr(callable_target, 'constructor_method'):
+                    call_target = callable_target.constructor_method()
 
             callable_target = call_target if call_target is not None else callable_target
+
+        if isinstance(callable_target, IBuiltinMethod):
+            # verify if it's a variation of the default builtin method
+            args = [self.get_type(param, use_metatype=True) for param in call_args]
+
+            from boa3.internal.model.builtin.method import SuperMethod
+            # TODO: change when implementing super() with args
+            if (isinstance(callable_target, SuperMethod)
+                    and isinstance(self._current_method, Method) and self._current_method.has_cls_or_self):
+                args.insert(0, self._current_class)
+
+            new_target = callable_target.build(args)
+            if new_target is not None:
+                callable_target = new_target
+
+            if isinstance(callable_target, SuperMethod) and callable_target not in self._super_calls:
+                self._super_calls.append(callable_target)
         return callable_target
 
     def validate_callable_arguments(self, call: ast.Call, callable_target: Callable) -> bool:
         if callable_target.has_starred_argument and not hasattr(call, 'checked_starred_args'):
 
             if (len(call.args) >= len(callable_target.args)
                     and (len(call.args) == 0 or not isinstance(call.args[0], ast.Starred))):
-
                 # starred argument is always the last argument
                 len_args_without_starred = len(callable_target.args) - 1
                 args = self.parse_to_node(str(Type.tuple.default_value), call)
 
                 # include the arguments into a tuple to be assigned to the starred argument
                 args.elts = call.args[len_args_without_starred:]
                 call.args[len_args_without_starred:] = [args]
 
             call.checked_starred_args = True
 
+        ignore_first_argument = int(callable_target.has_cls_or_self)  # 1 if True, 0 otherwise
         len_call_args = len(call.args)
-        callable_required_args = len(callable_target.args_without_default)
+        len_call_keywords = len(call.keywords)
+        callable_required_args = len(callable_target.args_without_default) - ignore_first_argument
 
-        if len_call_args > len(callable_target.args):
-            unexpected_arg = call.args[len(callable_target.args)]
+        # verifies if a non-default arg is being called as a keyword
+        necessary_kwargs = list(callable_target.args_without_default.keys())[len_call_args:callable_required_args]
+        keywords_names_used = []
+        all_required_arg_have_values = True
+        for keyword in call.keywords:
+            keywords_names_used.append(keyword.arg)
+        index = 0
+        while index < len(necessary_kwargs) and all_required_arg_have_values:
+            if necessary_kwargs[index] not in keywords_names_used:
+                all_required_arg_have_values = False
+            index += 1
+
+        # verifies if a kwarg is being used but is not an argument for the function
+        index = 0
+        unexpected_kwarg = None
+        while unexpected_kwarg is None and index < len(call.keywords):
+            if call.keywords[index].arg not in list(callable_target.args.keys()):
+                unexpected_kwarg = call.keywords[index].value
+            index += 1
+
+        # verifies if a kwarg that was already used as a positional argument is being used again
+        implicit_args = list(callable_target.args_without_default.keys())[:len_call_args]
+        index = 0
+        already_called_arg = None
+        kwargs_used_names = []
+        for keyword in call.keywords:
+            kwargs_used_names.append(keyword.arg)
+        while already_called_arg is None and index < len(implicit_args):
+            if implicit_args[index] in kwargs_used_names:
+                already_called_arg = call.keywords[index].value
+            index += 1
+
+        if len_call_args > len(callable_target.args) or unexpected_kwarg is not None or already_called_arg is not None:
+            if unexpected_kwarg is not None:
+                unexpected_arg = unexpected_kwarg
+            elif already_called_arg is not None:
+                unexpected_arg = already_called_arg
+            else:
+                unexpected_arg = call.args[len(callable_target.args) + ignore_first_argument]
             self._log_error(
                 CompilerError.UnexpectedArgument(unexpected_arg.lineno, unexpected_arg.col_offset)
             )
             return False
-        elif len_call_args < callable_required_args:
-            missed_arg = list(callable_target.args)[len(call.args)]
+        elif len_call_args + len_call_keywords < callable_required_args or not all_required_arg_have_values:
+            missed_arg = list(callable_target.args)[len(call.args) + ignore_first_argument]
             self._log_error(
                 CompilerError.UnfilledArgument(call.lineno, call.col_offset, missed_arg)
             )
             return False
 
         if isinstance(callable_target, IBuiltinMethod) and callable_target.requires_reordering:
             if not hasattr(call, 'was_reordered') or not call.was_reordered:
@@ -1155,27 +1423,54 @@
         if isinstance(callable, IBuiltinMethod):
             builtin_analyser = BuiltinFunctionCallAnalyser(self, call, callable_id, callable, self._log)
             if builtin_analyser.validate():
                 self.errors.extend(builtin_analyser.errors)
                 self.warnings.extend(builtin_analyser.warnings)
                 return
 
-        for index, (arg_id, arg_value) in enumerate(callable.args.items()):
-            param = call.args[index]
-            param_type = self.get_type(param, use_metatype=True)
-            args_types.append(param_type)
-            if not arg_value.type.is_type_of(param_type):
-                self._log_error(
-                    CompilerError.MismatchedTypes(
-                        param.lineno, param.col_offset,
-                        arg_value.type.identifier,
-                        param_type.identifier
-                    ))
+        param_types = []
+        ignore_first_argument = int(callable.has_cls_or_self)  # 1 if True, 0 otherwise
+        is_first_arg_cls_of_self = ignore_first_argument and len(call.args) == len(callable.args)
+
+        # validate positional parameters
+        if is_first_arg_cls_of_self:
+            (self_id, self_value) = list(callable.args.items())[0]
+            param_type = self._validate_argument_type(call.args[0], self_value.type, use_metatype=True)
+            param_types.append(param_type)
+
+        for index, param in enumerate(call.args[is_first_arg_cls_of_self:]):
+            (arg_id, arg_value) = list(callable.args.items())[ignore_first_argument + index]
+
+            param_type = self._validate_argument_type(param, arg_value.type, use_metatype=True)
+            param_types.append(param_type)
+
+        # validate keyword arguments
+        for param in call.keywords:
+            arg_value = callable.args[param.arg]
+            param = param.value
+            param_type = self._validate_argument_type(param, arg_value.type)
+            param_types.append(param_type)
+
+    def _validate_argument_type(self, param: ast.AST, arg_type: IType, use_metatype: bool = False) -> Optional[IType]:
+        param_type = self.get_type(param, use_metatype=use_metatype)
+        if arg_type.is_type_of(param_type):
+            return param_type
+        else:
+            self._log_error(
+                CompilerError.MismatchedTypes(
+                    param.lineno, param.col_offset,
+                    arg_type.identifier,
+                    param_type.identifier
+                ))
+
+        return None
 
     def update_callable_after_validation(self, call: ast.Call, callable_id: str, callable_target: Callable):
+        callable_target.add_call_origin(call)
+
         # if the arguments are not generic, include the specified method in the symbol table
         if (isinstance(callable_target, IBuiltinMethod)
                 and callable_target.identifier != callable_id
                 and callable_target.raw_identifier == callable_id):
             if callable_target.identifier not in self.symbols:
                 self.symbols[callable_target.identifier] = callable_target
             call.func = ast.Name(lineno=call.func.lineno, col_offset=call.func.col_offset,
@@ -1320,47 +1615,110 @@
             return '{0}.{1}'.format(attribute.value.id, attribute.attr)
 
         symbol = None
         if isinstance(value, str) and not isinstance(attribute.value, ast.Str):
             symbol = self.get_symbol(value)
             if symbol is None:
                 return '{0}.{1}'.format(value, attribute.attr)
+            value_type = self.get_type(symbol)
+        else:
+            value_type = self.get_type(value)
+
         if isinstance(value, ISymbol):
             symbol = value
 
         if isinstance(symbol, Attribute):
             symbol = symbol.attr_symbol
         if isinstance(symbol, IExpression):
             symbol = symbol.type
         if hasattr(symbol, 'symbols') and attribute.attr in symbol.symbols:
             attr_symbol = symbol.symbols[attribute.attr]
+        elif isinstance(symbol, Package) and attribute.attr in symbol.inner_packages:
+            attr_symbol = symbol.inner_packages[attribute.attr]
         else:
             attr_symbol: Optional[ISymbol] = self.get_symbol(attribute.attr)
 
-        if attr_symbol is None and hasattr(symbol, 'symbols'):
+        origin = value
+        module_symbols = origin.symbols if isinstance(origin, Package) else symbol.methods if isinstance(symbol, Import) else None
+        if isinstance(origin, Attribute):
+            while isinstance(origin, Attribute):
+                origin = origin.value
+        else:
+            origin = attribute.value
+
+        is_invalid_method = module_symbols is not None and isinstance(attr_symbol, Method) and attribute.attr not in module_symbols
+        is_from_class_name = isinstance(origin, ast.Name) and isinstance(self.get_symbol(origin.id), UserClass)
+        is_instance_variable_from_class = (isinstance(symbol, UserClass)
+                                           and attribute.attr in symbol.instance_variables)
+        is_class_variable_from_class = isinstance(symbol, UserClass) and attribute.attr in symbol.class_variables and not symbol.is_interface
+        is_property_from_class = isinstance(symbol, UserClass) and attribute.attr in symbol.properties and not symbol.is_interface
+
+        if ((attr_symbol is None and hasattr(symbol, 'symbols'))
+                or is_invalid_method
+                or (is_from_class_name and is_instance_variable_from_class)
+                or (is_from_class_name and is_property_from_class)):
             # if it couldn't find the symbol in the attribute symbols, raise unresolved reference
             self._log_error(
                 CompilerError.UnresolvedReference(
                     attribute.lineno, attribute.col_offset,
-                    symbol_id='{0}.{1}'.format(symbol.identifier, attribute.attr)
+                    symbol_id='{0}.{1}'.format(symbol.identifier if module_symbols is None else attribute.value.id, attribute.attr)
+                ))
+            return Attribute(attribute.value, None, attr_symbol, attribute)
+
+        if is_class_variable_from_class and isinstance(attribute.ctx, ast.Store):
+            # reassign class variables in objects is not supported yet
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    attribute.lineno, attribute.col_offset,
+                    symbol_id='reassign class variables'
+                ))
+            return Attribute(attribute.value, None, attr_symbol, attribute)
+
+        if not is_from_class_name and is_property_from_class and isinstance(attribute.ctx, ast.Store):
+            # setting values for properties in objects is not supported yet
+            # @property.setter is not implemented
+            self._log_error(
+                CompilerError.NotSupportedOperation(
+                    attribute.lineno, attribute.col_offset,
+                    symbol_id='setting values for properties'
                 ))
             return Attribute(attribute.value, None, attr_symbol, attribute)
 
         attr_type = value.type if isinstance(value, IExpression) else value
         # for checking during the code generation
-        if (isinstance(attr_type, ClassType) and
+        if (self.is_implemented_class_type(attr_type) and
                 not (isinstance(attribute.value, ast.Name) and attribute.value.id == attr_type.identifier) and
                 (not hasattr(attribute, 'generate_value') or not attribute.generate_value)):
             attribute.generate_value = True
 
-        if isinstance(symbol, Package) or isinstance(value, Attribute):
-            attr_value = symbol
+        if (isinstance(symbol, (Package, Attribute))
+                or (isinstance(symbol, ClassType) and isinstance(value, (Package, Attribute)))):
+            attr_value = symbol if not isinstance(symbol, PythonClass) else attribute.value
         else:
             attr_value = attribute.value
+            if not isinstance(symbol, Import):
+                if hasattr(attr_type, 'symbols'):
+                    is_valid_symbol_in_attribute = attribute.attr in attr_type.symbols
+                else:
+                    is_valid_symbol_in_attribute = attr_symbol in self.symbols.values()
+                attr_id = value_type.identifier
+            else:
+                is_valid_symbol_in_attribute = attribute.attr in symbol.symbols
+                attr_id = attr_type
 
+            if not is_internal and not is_valid_symbol_in_attribute:
+                self._log_error(
+                    CompilerError.UnresolvedReference(
+                        attribute.lineno, attribute.col_offset,
+                        symbol_id='{0}.{1}'.format(attr_id, attribute.attr)
+                    ))
+
+        if isinstance(attr_symbol, Property):
+            if isinstance(attribute.ctx, ast.Load):
+                attr_symbol.getter.add_call_origin(attribute)
         return Attribute(attr_value, attribute.attr, attr_symbol, attribute)
 
     def visit_Constant(self, constant: ast.Constant) -> Any:
         """
         Visitor of constant values node
 
         :param constant: the python ast constant value node
@@ -1401,44 +1759,66 @@
         Visitor of literal bytes node
 
         :param bts: the python ast bytes node
         :return: the value of the bytes
         """
         return bts.s
 
+    def _visit_literal(self, node: ast.expr, get_literal_values: bool = False) -> Any:
+        if get_literal_values:
+            item = self.visit(node, get_literal_value=True)
+            if item is None or isinstance(item, ast.AST):
+                item = self.get_type(node)
+        else:
+            item = self.get_type(node)
+
+        return item
+
     def visit_Tuple(self, tup_node: ast.Tuple) -> Tuple[Any, ...]:
         """
         Visitor of literal tuple node
 
         :param tup_node: the python ast tuple node
         :return: the value of the tuple
         """
-        return tuple(self.get_type(value) for value in tup_node.elts)
+        get_literal_values = hasattr(tup_node, 'get_literal_value') and tup_node.get_literal_value
+        result = []
+        for value in tup_node.elts:
+            result.append(self._visit_literal(value, get_literal_values))
+
+        return tuple(result)
 
     def visit_List(self, list_node: ast.List) -> List[Any]:
         """
         Visitor of literal list node
 
         :param list_node: the python ast list node
         :return: the value of the list
         """
-        return [self.get_type(value) for value in list_node.elts]
+        get_literal_values = hasattr(list_node, 'get_literal_value') and list_node.get_literal_value
+        result = []
+        for value in list_node.elts:
+            result.append(self._visit_literal(value, get_literal_values))
+
+        return result
 
     def visit_Dict(self, dict_node: ast.Dict) -> Dict[Any, Any]:
         """
         Visitor of literal dict node
 
         :param dict_node: the python ast dict node
         :return: a list with each key and value type
         """
+        get_literal_values = hasattr(dict_node, 'get_literal_value') and dict_node.get_literal_value
         dictionary = {}
         size = min(len(dict_node.keys), len(dict_node.values))
         for index in range(size):
-            key = self.get_type(dict_node.keys[index])
-            value = self.get_type(dict_node.values[index])
+            key = self._visit_literal(dict_node.keys[index], get_literal_values)
+            value = self._visit_literal(dict_node.values[index], get_literal_values)
+
             if key in dictionary and dictionary[key] != value:
                 dictionary[key] = Type.get_generic_type(dictionary[key], value)
             else:
                 dictionary[key] = value
         return dictionary
 
     def visit_NameConstant(self, constant: ast.NameConstant) -> Any:
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/blockchain/block.py` & `neo3-boa-1.0.0/boa3/builtin/interop/blockchain/block.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,14 +1,21 @@
+__all__ = [
+    'Block'
+]
+
 from boa3.builtin.type import UInt160, UInt256
 
 
 class Block:
     """
     Represents a block.
 
+    Check out `Neo's Documentation <https://developers.neo.org/docs/n3/foundation/Blocks>`__ to learn more
+    about Blocks.
+
     :ivar hash: a unique identifier based on the unsigned data portion of the object
     :vartype hash: UInt256
     :ivar version: the data structure version of the block
     :vartype version: int
     :ivar previous_hash: the hash of the previous block
     :vartype previous_hash: UInt256
     :ivar merkle_root: the merkle root of the transactions
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/blockchain/transaction.py` & `neo3-boa-1.0.0/boa3/builtin/interop/blockchain/transaction.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,21 @@
+__all__ = [
+    'Transaction',
+]
+
 from boa3.builtin.type import UInt160, UInt256
 
 
 class Transaction:
     """
     Represents a transaction.
 
+    Check out `Neo's Documentation <https://developers.neo.org/docs/n3/foundation/Transactions>`__ to learn more about
+    Transactions.
+
     :ivar hash: a unique identifier based on the unsigned data portion of the object
     :vartype hash: UInt256
     :ivar version: the data structure version of the transaction
     :vartype version: int
     :ivar nonce: a random number used once in the cryptography
     :vartype nonce: int
     :ivar sender: the sender is the first signer of the transaction, they will pay the fees of the transaction
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/contract/contractmanifest.py` & `neo3-boa-1.0.0/boa3/builtin/interop/contract/contractmanifest.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,23 +1,36 @@
+__all__ = [
+    'ContractManifest',
+    'ContractPermission',
+    'ContractPermissionDescriptor',
+    'ContractGroup',
+    'ContractAbi',
+    'ContractMethodDescriptor',
+    'ContractEventDescriptor',
+    'ContractParameterDefinition',
+    'ContractParameterType',
+]
+
 from typing import List, Optional
 
 from boa3.builtin.type import ECPoint, UInt160
-from boa3.neo.vm.type.ContractParameterType import ContractParameterType
+from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType
 
 
 class ContractManifest:
     """
-    Represents the manifest of a smart contract [#]_.
+    Represents the manifest of a smart contract.
 
     When a smart contract is deployed, it must explicitly declare the features and permissions it will use.
 
     When it is running, it will be limited by its declared list of features and permissions, and cannot make any
     behavior beyond the scope of the list.
 
-    .. [#] For more details, see NEP-15.
+    For more details, check out `NEP-15 <https://github.com/neo-project/proposals/blob/master/nep-15.mediawiki>`__ or
+    `Neo's Documentation <https://developers.neo.org/docs/n3/develop/write/manifest#manifest>`__.
 
     :ivar name: The name of the contract.
     :vartype name: str
     :ivar groups: The groups of the contract.
     :vartype groups: List[ContractGroup]
     :ivar supported_standards: Indicates which standards the contract supports. It can be a list of NEPs.
     :vartype supported_standards: List[str]
@@ -51,25 +64,26 @@
 
     If a contract invokes a contract or method that is not declared in the manifest at runtime, the invocation will
     fail.
 
     :ivar contract:
         Indicates which contract to be invoked.
 
-        It can be a hash of a contract, a public key of a group, or a wildcard *.
+        It can be a hash of a contract, a public key of a group, or a wildcard \\*.
 
         If it specifies a hash of a contract, then the contract will be invoked; If it specifies a public key of a
-        group, then any contract in this group may be invoked; If it specifies a wildcard *, then any contract may be
+        group, then any contract in this group may be invoked; If it specifies a wildcard \\*, then any contract may be
         invoked.
 
     :vartype contract: ContractPermissionDescriptor or None
     :ivar methods:
         Indicates which methods to be called.
 
-        It can also be assigned with a wildcard *. If it is a wildcard *, then it means that any method can be called.
+        It can also be assigned with a wildcard \\*. If it is a wildcard \\*, then it means that any method can be
+        called.
 
     :vartype methods: List[str] or None
     """
 
     def __init__(self):
         self.contract: Optional[ContractPermissionDescriptor] = None
         self.methods: Optional[List[str]] = None
@@ -109,17 +123,18 @@
     def __init__(self):
         self.pubkey: ECPoint = ECPoint(b'')
         self.signature: bytes = b''
 
 
 class ContractAbi:
     """
-    Represents the ABI of a smart contract [#]_.
+    Represents the ABI of a smart contract.
 
-    .. [#] For more details, see NEP-14.
+    For more details, check out `NEP-14 <https://github.com/neo-project/proposals/blob/master/nep-14.mediawiki>`__ or
+    `Neo's Documentation <https://developers.neo.org/docs/n3/develop/write/manifest#manifest>`__.
 
     :ivar methods: Gets the methods in the ABI.
     :vartype methods: List[ContractMethodDescriptor]
     :ivar events: Gets the events in the ABI.
     :vartype events: List[ContractEventDescriptor]
     """
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/iterator/__init__.py` & `neo3-boa-1.0.0/boa3/builtin/interop/iterator/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,9 +1,14 @@
 from __future__ import annotations
 
+__all__ = [
+    'Iterator',
+]
+
+
 from typing import Any
 
 
 class Iterator:
     """
     The iterator for smart contracts.
     """
@@ -18,11 +23,16 @@
         """
         return None
 
     def next(self) -> bool:
         """
         Advances the iterator to the next element of the collection.
 
+        >>> from boa3.builtin.interop import storage
+        ... iterator = storage.find(b'prefix')
+        ... iterator.next()
+        True
+
         :return: true if it advanced, false if there isn't a next element
         :rtype: bool
         """
         pass
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/json/__init__.py` & `neo3-boa-1.0.0/boa3/builtin/interop/json/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,30 +1,42 @@
+__all__ = [
+    'json_serialize',
+    'json_deserialize',
+]
+
+
 from typing import Any
 
 
-def json_serialize(item: Any) -> bytes:
+def json_serialize(item: Any) -> str:
     """
     Serializes an item into a json.
 
+    >>> json_serialize({'one': 1, 'two': 2, 'three': 3})
+    '{"one":1,"two":2,"three":3}'
+
     :param item: The item that will be serialized
     :type item: Any
     :return: The serialized item
-    :rtype: bytes
+    :rtype: str
 
     :raise Exception: raised if the item is an integer value out of the Neo's accepted range, is a dictionary with a
         bytearray key, or isn't serializable.
     """
     pass
 
 
-def json_deserialize(json: bytes) -> Any:
+def json_deserialize(json: str) -> Any:
     """
     Deserializes a json into some valid type.
 
+    >>> json_deserialize('{"one":1,"two":2,"three":3}')
+    {'one': 1, 'three': 3, 'two': 2}
+
     :param json: A json that will be deserialized
-    :type json: bytes
+    :type json: str
     :return: The deserialized json
     :rtype: Any
 
-    :raise Exception: raised if json's deserialization is not valid.
+    :raise Exception: raised if jsons deserialization is not valid.
     """
     pass
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/runtime/notification.py` & `neo3-boa-1.0.0/boa3/builtin/interop/runtime/notification.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+__all__ = ['Notification']
+
+
 from boa3.builtin.type import UInt160
 
 
 class Notification:
     """
     Represents a notification.
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/storage/__init__.py` & `neo3-boa-1.0.0/boa3/builtin/interop/storage/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,83 +1,128 @@
+__all__ = [
+    'FindOptions',
+    'StorageContext',
+    'StorageMap',
+    'get',
+    'get_context',
+    'get_read_only_context',
+    'put',
+    'delete',
+    'find',
+]
+
+
 from typing import Union
 
 from boa3.builtin.interop.iterator import Iterator
 from boa3.builtin.interop.storage.findoptions import FindOptions
 from boa3.builtin.interop.storage.storagecontext import StorageContext
 from boa3.builtin.interop.storage.storagemap import StorageMap
 
 
-def get(key: Union[str, bytes], context: StorageContext = None) -> bytes:
+def get_context() -> StorageContext:
     """
-    Gets a value from the persistent store based on the given key.
+    Gets current storage context.
 
-    :param key: value identifier in the store
-    :type key: str or bytes
-    :param context: storage context to be used
-    :type context: StorageContext
-    :return: the value corresponding to given key for current storage context
-    :rtype: bytes
+    >>> get_context()       # StorageContext cannot be read outside the blockchain
+    _InteropInterface
+
+    :return: the current storage context
+    :rtype: StorageContext
     """
     pass
 
 
-def get_context() -> StorageContext:
+def get(key: bytes, context: StorageContext = get_context()) -> bytes:
     """
-    Gets current storage context.
+    Gets a value from the persistent store based on the given key.
 
-    :return: the current storage context
-    :rtype: StorageContext
+    >>> put(b'unit', 'test')
+    ... get(b'unit')
+    'test'
+
+    >>> get(b'fake_key')
+    ''
+
+    :param key: value identifier in the store
+    :type key: bytes
+    :param context: storage context to be used
+    :type context: StorageContext
+    :return: the value corresponding to given key for current storage context
+    :rtype: bytes
     """
     pass
 
 
 def get_read_only_context() -> StorageContext:
     """
     Gets current read only storage context.
 
+    >>> get_context()       # StorageContext cannot be read outside the blockchain
+    _InteropInterface
+
     :return: the current read only storage context
     :rtype: StorageContext
     """
     pass
 
 
-def put(key: Union[str, bytes], value: Union[int, str, bytes], context: StorageContext = None):
+def put(key: bytes, value: Union[int, bytes, str], context: StorageContext = get_context()):
     """
     Inserts a given value in the key-value format into the persistent storage.
 
+    >>> put(b'unit', 'test')
+    None
+
     :param key: the identifier in the store for the new value
-    :type key: str or bytes
+    :type key: bytes
     :param value: value to be stored
     :type value: int or str or bytes
     :param context: storage context to be used
     :type context: StorageContext
     """
     pass
 
 
-def delete(key: Union[str, bytes], context: StorageContext = None):
+def delete(key: bytes, context: StorageContext = get_context()):
     """
     Removes a given key from the persistent storage if exists.
 
+    >>> put(b'unit', 'test')
+    ... delete()
+    ... get(b'unit')
+    ''
+
     :param key: the identifier in the store for the new value
-    :type key: str or bytes
+    :type key: bytes
     :param context: storage context to be used
     :type context: StorageContext
     """
     pass
 
 
-def find(prefix: Union[str, bytes],
-         context: StorageContext = None,
+def find(prefix: bytes,
+         context: StorageContext = get_context(),
          options: FindOptions = FindOptions.NONE) -> Iterator:
     """
     Searches in the storage for keys that start with the given prefix.
 
+    >>> put(b'a1', 'one')
+    ... put(b'a2', 'two')
+    ... put(b'a3', 'three')
+    ... put(b'b4', 'four')
+    ... findIterator = find(b'a')
+    ... findResults = []
+    ... while findIterator.next():
+    ...     findResults.append(findIterator.value)
+    ... findResults
+    ['one', 'two', 'three']
+
     :param prefix: prefix to find the storage keys
-    :type prefix: str or bytes
+    :type prefix: bytes
     :param context: storage context to be used
     :type context: StorageContext
     :param options: the options of the search
     :type options: FindOptions
     :return: an iterator with the search results
     :rtype: Iterator
     """
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/storage/storagecontext.py` & `neo3-boa-1.0.0/boa3/builtin/interop/storage/storagecontext.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,28 +1,31 @@
 from __future__ import annotations
 
-from typing import Union
+__all__ = ['StorageContext']
 
 from boa3.builtin.interop.storage.storagemap import StorageMap
 
 
 class StorageContext:
     """
     The storage context used to read and write data in smart contracts.
+
+    Check out `Neo's Documentation <https://developers.neo.org/docs/n3/reference/scapi/framework/services/StorageContext>`__
+    to learn more about the StorageContext class.
     """
 
     def __init__(self):
         pass
 
-    def create_map(self, prefix: Union[str, bytes]) -> StorageMap:
+    def create_map(self, prefix: bytes) -> StorageMap:
         """
         Creates a storage map with the given prefix.
 
         :param prefix: the identifier of the storage map
-        :type prefix: str or bytes
+        :type prefix: bytes
         :return: a map with the key-values in the storage that match with the given prefix
         :rtype: StorageMap
         """
         pass
 
     def as_read_only(self) -> StorageContext:
         """
```

### Comparing `neo3-boa-0.9.0/boa3/builtin/interop/storage/storagemap.py` & `neo3-boa-1.0.0/boa3/builtin/interop/storage/storagemap.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,44 +1,49 @@
+__all__ = ['StorageMap']
+
 from typing import Union
 
 
 class StorageMap:
     """
     The key-value storage for the specific prefix in the given storage context.
+
+    Check out `Neo's Documentation <https://developers.neo.org/docs/n3/reference/scapi/framework/services/StorageMap>`__
+    to learn more about StorageMap.
     """
 
-    def __init__(self, context, prefix: Union[bytes, str]):
-        from boa3.builtin.interop.storage.storagecontext import StorageContext
+    def __init__(self, context, prefix: bytes):
+        from boa3.builtin.interop.storage import StorageContext
 
         self._context: StorageContext
-        self._prefix: Union[bytes, str]
+        self._prefix: bytes
 
-    def get(self, key: Union[str, bytes]) -> bytes:
+    def get(self, key: bytes) -> bytes:
         """
         Gets a value from the map based on the given key.
 
         :param key: value identifier in the store
-        :type key: str or bytes
+        :type key: bytes
         :return: the value corresponding to given key for current storage context
         :rtype: bytes
         """
         pass
 
-    def put(self, key: Union[str, bytes], value: Union[int, str, bytes]):
+    def put(self, key: bytes, value: Union[int, bytes, str]):
         """
         Inserts a given value in the key-value format into the map.
 
         :param key: the identifier in the store for the new value
-        :type key: str or bytes
+        :type key: bytes
         :param value: value to be stored
         :type value: int or str or bytes
         """
         pass
 
-    def delete(self, key: Union[str, bytes]):
+    def delete(self, key: bytes):
         """
         Removes a given key from the map if exists.
 
         :param key: the identifier in the store for the new value
-        :type key: str or bytes
+        :type key: bytes
         """
         pass
```

### Comparing `neo3-boa-0.9.0/boa3/compiler/codegenerator/codegenerator.py` & `neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/codegenerator.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,131 +1,172 @@
-from typing import Any, Dict, List, Optional, Tuple, Union
+from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
 
-from boa3 import constants
-from boa3.analyser.analyser import Analyser
-from boa3.analyser.model.symbolscope import SymbolScope
-from boa3.compiler import codegenerator
-from boa3.compiler.codegenerator.stackmemento import NeoStack, StackMemento
-from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
-from boa3.model.builtin.builtin import Builtin
-from boa3.model.builtin.internal.innerdeploymethod import InnerDeployMethod
-from boa3.model.builtin.interop.interop import Interop
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.event import Event
-from boa3.model.imports.importsymbol import Import
-from boa3.model.method import Method
-from boa3.model.operation.binaryop import BinaryOp
-from boa3.model.operation.operation import IOperation
-from boa3.model.operation.unaryop import UnaryOp
-from boa3.model.property import Property
-from boa3.model.symbol import ISymbol
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.collection.sequence.buffertype import Buffer as BufferType
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.model.type.type import IType, Type
-from boa3.model.variable import Variable
-from boa3.neo.vm.TryCode import TryCode
-from boa3.neo.vm.VMCode import VMCode
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.opcode.OpcodeInfo import OpcodeInfo, OpcodeInformation
-from boa3.neo.vm.type.Integer import Integer
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal import constants
+from boa3.internal.analyser.analyser import Analyser
+from boa3.internal.analyser.model.symbolscope import SymbolScope
+from boa3.internal.compiler import codegenerator
+from boa3.internal.compiler.codegenerator.stackmemento import NeoStack, StackMemento
+from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
+from boa3.internal.compiler.compileroutput import CompilerOutput
+from boa3.internal.model.builtin.builtin import Builtin
+from boa3.internal.model.builtin.internal.innerdeploymethod import InnerDeployMethod
+from boa3.internal.model.builtin.interop.interop import Interop
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.event import Event
+from boa3.internal.model.imports.importsymbol import Import
+from boa3.internal.model.imports.package import Package
+from boa3.internal.model.method import Method
+from boa3.internal.model.operation.binaryop import BinaryOp
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.operation.unaryop import UnaryOp
+from boa3.internal.model.property import Property
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.classes.contractinterfaceclass import ContractInterfaceClass
+from boa3.internal.model.type.classes.userclass import UserClass
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.collection.sequence.buffertype import Buffer as BufferType
+from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.model.type.primitive.strtype import StrType
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.TryCode import TryCode
+from boa3.internal.neo.vm.VMCode import VMCode
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo, OpcodeInformation
+from boa3.internal.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class CodeGenerator:
     """
     This class is responsible for generating the Neo VM bytecode
 
     :ivar symbol_table: a dictionary that maps the global symbols.
     """
 
     @staticmethod
-    def generate_code(analyser: Analyser) -> bytes:
+    def generate_code(analyser: Analyser) -> CompilerOutput:
         """
         Generates the Neo VM bytecode using of the analysed Python code
 
-        :param analyser: semantic analyser it tge Python code
+        :param analyser: semantic analyser of the Python code
         :return: the Neo VM bytecode
         """
         VMCodeMapping.reset()
-        import ast
-        from boa3.compiler.codegenerator.codegeneratorvisitor import VisitorCodeGenerator
+        analyser.update_symbol_table_with_imports()
 
+        all_imports = CodeGenerator._find_all_imports(analyser)
         generator = CodeGenerator(analyser.symbol_table)
-        deploy_method = (analyser.symbol_table[constants.DEPLOY_METHOD_ID]
-                         if constants.DEPLOY_METHOD_ID in analyser.symbol_table
-                         else None)
-        deploy_origin_module = analyser.ast_tree
 
-        if hasattr(deploy_method, 'origin') and deploy_method.origin in analyser.ast_tree.body:
-            analyser.ast_tree.body.remove(deploy_method.origin)
+        from boa3.internal.exception.CompilerError import CompilerError
 
-        visitor = VisitorCodeGenerator(generator)
-        visitor.visit(analyser.ast_tree)
+        try:
+            import ast
+            from boa3.internal.compiler.codegenerator.codegeneratorvisitor import VisitorCodeGenerator
 
-        analyser.update_symbol_table(generator.symbol_table)
-        generator.symbol_table.clear()
-        generator.symbol_table.update(analyser.symbol_table.copy())
-
-        for symbol in [symbol for symbol in analyser.symbol_table.values() if isinstance(symbol, Import)]:
-            generator.symbol_table.update(symbol.all_symbols)
+            deploy_method = (analyser.symbol_table[constants.DEPLOY_METHOD_ID]
+                             if constants.DEPLOY_METHOD_ID in analyser.symbol_table
+                             else None)
+            deploy_origin_module = analyser.ast_tree
 
-            if hasattr(deploy_method, 'origin') and deploy_method.origin in symbol.ast.body:
-                symbol.ast.body.remove(deploy_method.origin)
-                deploy_origin_module = symbol.ast
+            if hasattr(deploy_method, 'origin') and deploy_method.origin in analyser.ast_tree.body:
+                analyser.ast_tree.body.remove(deploy_method.origin)
 
-            visitor.visit(symbol.ast)
+            visitor = VisitorCodeGenerator(generator, analyser.filename, analyser.root)
+            visitor._root_module = analyser.ast_tree
+            visitor.visit_and_update_analyser(analyser.ast_tree, analyser)
 
-            analyser.update_symbol_table(symbol.all_symbols)
+            analyser.update_symbol_table(generator.symbol_table)
             generator.symbol_table.clear()
             generator.symbol_table.update(analyser.symbol_table.copy())
 
-        if len(generator._globals) > 0:
-            from boa3.compiler.codegenerator.initstatementsvisitor import InitStatementsVisitor
-            deploy_stmts, static_stmts = InitStatementsVisitor.separate_global_statements(analyser.symbol_table,
-                                                                                          visitor.global_stmts)
-
-            deploy_method = deploy_method if deploy_method is not None else InnerDeployMethod.instance().copy()
-
-            if len(deploy_stmts) > 0:
-                if_update_body = ast.parse(f"if not {list(deploy_method.args)[1]}: pass").body[0]
-                if_update_body.body = deploy_stmts
-                if_update_body.test.op = UnaryOp.Not
-                deploy_method.origin.body.insert(0, if_update_body)
-
-            visitor.global_stmts = static_stmts
-
-        if hasattr(deploy_method, 'origin'):
-            deploy_ast = ast.parse("")
-            deploy_ast.body = [deploy_method.origin]
-
-            generator.symbol_table[constants.DEPLOY_METHOD_ID] = deploy_method
-            analyser.symbol_table[constants.DEPLOY_METHOD_ID] = deploy_method
-            visitor._tree = deploy_origin_module
-            visitor.visit(deploy_ast)
+            for symbol in all_imports.values():
+                generator.symbol_table.update(symbol.all_symbols)
 
-            generator.symbol_table.clear()
-            generator.symbol_table.update(analyser.symbol_table.copy())
+                if hasattr(deploy_method, 'origin') and deploy_method.origin in symbol.ast.body:
+                    symbol.ast.body.remove(deploy_method.origin)
+                    deploy_origin_module = symbol.ast
+
+                visitor.set_filename(symbol.origin)
+                visitor.visit_and_update_analyser(symbol.ast, analyser)
+
+                analyser.update_symbol_table(symbol.all_symbols)
+                generator.symbol_table.clear()
+                generator.symbol_table.update(analyser.symbol_table.copy())
+
+            if len(generator._globals) > 0:
+                from boa3.internal.compiler.codegenerator.initstatementsvisitor import InitStatementsVisitor
+                deploy_stmts, static_stmts = InitStatementsVisitor.separate_global_statements(analyser.symbol_table,
+                                                                                              visitor.global_stmts)
+
+                deploy_method = deploy_method if deploy_method is not None else InnerDeployMethod.instance().copy()
+
+                if len(deploy_stmts) > 0:
+                    if_update_body = ast.parse(f"if not {list(deploy_method.args)[1]}: pass").body[0]
+                    if_update_body.body = deploy_stmts
+                    if_update_body.test.op = UnaryOp.Not
+                    deploy_method.origin.body.insert(0, if_update_body)
+
+                visitor.global_stmts = static_stmts
+
+            if hasattr(deploy_method, 'origin'):
+                deploy_ast = ast.parse("")
+                deploy_ast.body = [deploy_method.origin]
+
+                generator.symbol_table[constants.DEPLOY_METHOD_ID] = deploy_method
+                analyser.symbol_table[constants.DEPLOY_METHOD_ID] = deploy_method
+                visitor._tree = deploy_origin_module
+                visitor.visit_and_update_analyser(deploy_ast, analyser)
+
+                generator.symbol_table.clear()
+                generator.symbol_table.update(analyser.symbol_table.copy())
+
+            visitor.set_filename(analyser.filename)
+            generator.can_init_static_fields = True
+            if len(visitor.global_stmts) > 0:
+                global_ast = ast.parse("")
+                global_ast.body = visitor.global_stmts
+                visitor.visit_and_update_analyser(global_ast, analyser)
+                generator.initialized_static_fields = True
 
-        generator.can_init_static_fields = True
-        if len(visitor.global_stmts) > 0:
-            global_ast = ast.parse("")
-            global_ast.body = visitor.global_stmts
-            visitor.visit(global_ast)
-            generator.initialized_static_fields = True
+        except CompilerError:
+            pass
 
         analyser.update_symbol_table(generator.symbol_table)
-        return generator.bytecode
+        compilation_result = generator.output
+        return compilation_result
+
+    @staticmethod
+    def _find_all_imports(analyser: Analyser) -> Dict[str, Import]:
+        imports = {}
+        for key, symbol in analyser.symbol_table.copy().items():
+            if isinstance(symbol, Import):
+                importing = symbol
+            elif isinstance(symbol, Package) and isinstance(symbol.origin, Import):
+                importing = symbol.origin
+                analyser.symbol_table[symbol.origin.origin] = symbol.origin
+            else:
+                importing = None
+
+            if importing is not None and importing.origin not in imports:
+                imports[importing.origin] = importing
+
+        return imports
 
     def __init__(self, symbol_table: Dict[str, ISymbol]):
         self.symbol_table: Dict[str, ISymbol] = symbol_table.copy()
+        self.additional_symbols: Optional[Dict[str, ISymbol]] = None
 
         self._current_method: Method = None
+        self._current_class: Method = None
 
         self._missing_target: Dict[int, List[VMCode]] = {}  # maps targets with address not included yet
         self._can_append_target: bool = True
 
         self._scope_stack: List[SymbolScope] = []
         self._global_scope = SymbolScope()
 
@@ -139,26 +180,39 @@
 
         self._opcodes_to_remove: List[int] = []
         self._stack_states: StackMemento = StackMemento()  # simulates neo execution stack
 
         self.can_init_static_fields: bool = False
         self.initialized_static_fields: bool = False
 
+        self._static_vars: Optional[list] = None
+        self._global_vars: Optional[list] = None
+
     @property
     def bytecode(self) -> bytes:
         """
         Gets the bytecode of the translated code
 
         :return: the generated bytecode
         """
+        output = self.output
+        return output.bytecode
+
+    @property
+    def output(self) -> CompilerOutput:
+        """
+        Gets the bytecode of the translated code
+
+        :return: the generated bytecode
+        """
         opcodes = VMCodeMapping.instance().get_opcodes(self._opcodes_to_remove)
         self.set_code_targets()
         VMCodeMapping.instance().remove_opcodes_by_code(opcodes)
         self._opcodes_to_remove.clear()
-        return VMCodeMapping.instance().bytecode()
+        return VMCodeMapping.instance().result()
 
     @property
     def last_code(self) -> Optional[VMCode]:
         """
         Gets the last code in the bytecode
 
         :return: the last code. If the bytecode is empty, returns None
@@ -182,16 +236,15 @@
         """
         return len(self._stack)
 
     def _stack_append(self, value_type: IType):
         self._stack_states.append(value_type, self.last_code)
 
     def _stack_pop(self, index: int = -1) -> IType:
-        if len(self._stack) > 0:
-            return self._stack.pop(index)
+        return self._stack_states.pop(self.last_code, index)
 
     @property
     def last_code_start_address(self) -> int:
         """
         Gets the first address from last code in the bytecode
 
         :return: the last code's first address
@@ -239,81 +292,180 @@
 
     def _module_variables(self, modified_variable: bool) -> List[str]:
         """
         Gets a list with the variables name in the global scope
 
         :return: A list with the variables names
         """
-        module_globals = [var_id for var_id, var in self.symbol_table.items()
-                          if isinstance(var, Variable) and var.is_reassigned == modified_variable]
+        if modified_variable:
+            vars_map = self._global_vars
+        else:
+            vars_map = self._static_vars
+
+        module_global_variables = []
+        module_global_ids = []
+        result_global_vars = []
+        for var_id, var in self.symbol_table.items():
+            if isinstance(var, Variable) and var.is_reassigned == modified_variable and var not in result_global_vars:
+                module_global_variables.append((var_id, var))
+                module_global_ids.append(var_id)
+                result_global_vars.append(var)
+
+        class_with_class_variables = []
+        class_with_variables_ids = []
+        for class_id, class_symbol in self.symbol_table.items():
+            if isinstance(class_symbol, UserClass) and len(class_symbol.class_variables) > 0:
+                class_with_class_variables.append((class_id, class_symbol))
+                class_with_variables_ids.append(class_id)
 
         if not self.can_init_static_fields:
             for imported in self.symbol_table.values():
                 if isinstance(imported, Import):
                     # tried to use set and just update, but we need the variables to be ordered
                     for var_id, var in imported.variables.items():
                         if (isinstance(var, Variable)
                                 and var.is_reassigned == modified_variable
-                                and var_id not in module_globals):
-                            module_globals.append(var_id)
-        return module_globals
+                                and var_id not in module_global_ids
+                                and var not in result_global_vars):
+                            module_global_variables.append((var_id, var))
+                            module_global_ids.append(var_id)
+                            result_global_vars.append(var)
+
+                    # TODO: include user class from imported symbols as well
+
+        if modified_variable:
+            result_map = module_global_variables
+            result = module_global_ids
+        else:
+            result_map = module_global_variables + class_with_class_variables
+            result_global_vars = result_global_vars + [classes for (class_id, classes) in class_with_class_variables]
+            result = module_global_ids + class_with_variables_ids
+
+        original_ids = []
+        for value in result:
+            split = value.split(constants.VARIABLE_NAME_SEPARATOR)
+            if len(split) > 1:
+                new_index = split[-1]
+            else:
+                new_index = value
+            original_ids.append(new_index)
+
+        if vars_map != result_map:
+            if vars_map is None:
+                # save to keep the same order in future accesses
+                if modified_variable:
+                    self._global_vars = result_map
+                else:
+                    self._static_vars = result_map
+
+            else:
+                # reorder to keep the same order as the first access
+                pre_reordered_ids = [var_id for (var_id, var) in vars_map]
+                for index, (value, var) in enumerate(vars_map):
+                    if value not in result:
+                        if var in result_global_vars:
+                            var_index = result_global_vars.index(var)
+                            new_value = result_map[var_index]
+                        else:
+                            var_index = original_ids.index(value)
+                            new_value = result_map[var_index]
+
+                        vars_map[index] = new_value
+
+                # add new symbols at the end always
+                reordered_ids = [var_id for (var_id, var) in vars_map]
+                additional_items = []
+                for index, var_id in enumerate(result):
+                    if var_id not in reordered_ids and var_id not in pre_reordered_ids:
+                        additional_items.append(var_id)
+                        vars_map.append(result_map[index])
+
+                result = reordered_ids + additional_items
+
+        return result
 
     @property
     def _current_scope(self) -> SymbolScope:
         return self._scope_stack[-1] if len(self._scope_stack) > 0 else self._global_scope
 
     def is_none_inserted(self) -> bool:
         """
         Checks whether the last insertion is null
 
         :return: whether the last value is null
         """
-        return self.last_code.opcode is Opcode.PUSHNULL
+        return (self.last_code.opcode is Opcode.PUSHNULL or
+                (len(self._stack) > 0 and self._stack[-1] is Type.none))
 
-    def get_symbol(self, identifier: str, scope: Optional[ISymbol] = None, is_internal: bool = False) -> ISymbol:
+    def get_symbol(self, identifier: str, scope: Optional[ISymbol] = None, is_internal: bool = False) -> Tuple[str, ISymbol]:
         """
         Gets a symbol in the symbol table by its id
 
         :param identifier: id of the symbol
         :return: the symbol if exists. Symbol None otherwise
         """
+        cur_symbol_table = self.symbol_table.copy()
+        if isinstance(self.additional_symbols, dict):
+            cur_symbol_table.update(self.additional_symbols)
+
+        found_id = None
+        found_symbol = None
         if len(self._scope_stack) > 0:
             for symbol_scope in self._scope_stack:
                 if identifier in symbol_scope:
-                    return symbol_scope[identifier]
+                    found_id, found_symbol = identifier, symbol_scope[identifier]
+                    break
 
-        if scope is not None and hasattr(scope, 'symbols') and isinstance(scope.symbols, dict):
-            if identifier in scope.symbols and isinstance(scope.symbols[identifier], ISymbol):
-                return scope.symbols[identifier]
-        else:
-            if self._current_method is not None and identifier in self._current_method.symbols:
-                return self._current_method.symbols[identifier]
-            elif identifier in self.symbol_table:
-                return self.symbol_table[identifier]
-
-            # the symbol may be a built in. If not, returns None
-            symbol = Builtin.get_symbol(identifier)
-            if symbol is not None:
-                return symbol
-
-            if not isinstance(identifier, str):
-                return symbol
-            split = identifier.split('.')
-            if len(split) > 1:
-                attribute, symbol_id = '.'.join(split[:-1]), split[-1]
-                attr = self.get_symbol(attribute, is_internal=is_internal)
-                if hasattr(attr, 'symbols') and symbol_id in attr.symbols:
-                    return attr.symbols[symbol_id]
-
-            if is_internal:
-                from boa3.model import imports
-                found_symbol = imports.builtin.get_internal_symbol(identifier)
-                if isinstance(found_symbol, ISymbol):
-                    return found_symbol
-        return Type.none
+        if found_id is None:
+            if scope is not None and hasattr(scope, 'symbols') and isinstance(scope.symbols, dict):
+                if identifier in scope.symbols and isinstance(scope.symbols[identifier], ISymbol):
+                    found_id, found_symbol = identifier, scope.symbols[identifier]
+            else:
+                if self._current_method is not None and identifier in self._current_method.symbols:
+                    found_id, found_symbol = identifier, self._current_method.symbols[identifier]
+                elif identifier in cur_symbol_table:
+                    found_id, found_symbol = identifier, cur_symbol_table[identifier]
+                else:
+                    # the symbol may be a built-in. If not, returns None
+                    symbol = Builtin.get_symbol(identifier)
+                    if symbol is None:
+                        symbol = Interop.get_symbol(identifier)
+
+                    if symbol is not None:
+                        found_id, found_symbol = identifier, symbol
+
+                    elif not isinstance(identifier, str):
+                        found_id, found_symbol = identifier, symbol
+
+                    else:
+                        split = identifier.split(constants.ATTRIBUTE_NAME_SEPARATOR)
+                        if len(split) > 1:
+                            attribute, symbol_id = constants.ATTRIBUTE_NAME_SEPARATOR.join(split[:-1]), split[-1]
+                            another_attr_id, attr = self.get_symbol(attribute, is_internal=is_internal)
+                            if hasattr(attr, 'symbols') and symbol_id in attr.symbols:
+                                found_id, found_symbol = symbol_id, attr.symbols[symbol_id]
+                            elif isinstance(attr, Package) and symbol_id in attr.inner_packages:
+                                found_id, found_symbol = symbol_id, attr.inner_packages[symbol_id]
+
+                        if found_id is None and is_internal:
+                            from boa3.internal.model import imports
+                            found_symbol = imports.builtin.get_internal_symbol(identifier)
+                            if isinstance(found_symbol, ISymbol):
+                                found_id = identifier
+
+        if found_id is not None:
+            if isinstance(found_symbol, Variable) and not found_symbol.is_reassigned and found_id not in self._statics:
+                # verifies if it's a static variable with a unique name
+                for static_id, static_var in self._static_vars:
+                    if found_symbol == static_var:
+                        found_id = static_id
+                        break
+
+            return found_id, found_symbol
+        return identifier, Type.none
 
     def initialize_static_fields(self) -> bool:
         """
         Converts the signature of the method
 
         :return: whether there are static fields to be initialized
         """
@@ -324,30 +476,30 @@
 
         num_static_fields = len(self._statics)
         if num_static_fields > 0:
             init_data = bytearray([num_static_fields])
             self.__insert1(OpcodeInfo.INITSSLOT, init_data)
 
             if constants.INITIALIZE_METHOD_ID in self.symbol_table:
-                from boa3.helpers import get_auxiliary_name
+                from boa3.internal.helpers import get_auxiliary_name
                 method = self.symbol_table.pop(constants.INITIALIZE_METHOD_ID)
                 new_id = get_auxiliary_name(constants.INITIALIZE_METHOD_ID, method)
                 self.symbol_table[new_id] = method
 
             init_method = Method(is_public=True)
             init_method.init_bytecode = self.last_code
             self.symbol_table[constants.INITIALIZE_METHOD_ID] = init_method
 
         return num_static_fields > 0
 
     def end_initialize(self):
         """
         Converts the signature of the method
         """
-        self.__insert1(OpcodeInfo.RET)
+        self.insert_return()
         self.initialized_static_fields = True
 
         if constants.INITIALIZE_METHOD_ID in self.symbol_table:
             init_method = self.symbol_table[constants.INITIALIZE_METHOD_ID]
             init_method.end_bytecode = self.last_code
 
     def convert_begin_method(self, method: Method):
@@ -373,29 +525,46 @@
         """
         Converts the end of the method
         """
         if (self._current_method.init_bytecode is None
                 and self._current_method.init_address in VMCodeMapping.instance().code_map):
             self._current_method.init_bytecode = VMCodeMapping.instance().code_map[self._current_method.init_address]
 
-        if self.last_code.opcode is not Opcode.RET:
+        if self.last_code.opcode is not Opcode.RET or self._check_codes_with_target():
+            if self._current_method.is_init:
+                # return the built object if it's a constructor
+                self_id, self_value = list(self._current_method.args.items())[0]
+                self.convert_load_variable(self_id, self_value)
+
             self.insert_return()
 
         self._current_method.end_bytecode = self.last_code
         self._current_method = None
         self._stack.clear()
 
         function_variable_scope = self._scope_stack.pop()
 
     def insert_return(self):
         """
         Insert the return statement
         """
         self.__insert1(OpcodeInfo.RET)
 
+    def insert_not(self):
+        """
+        Insert a `not` to change the value of a bool
+        """
+        self.__insert1(OpcodeInfo.NOT)
+
+    def insert_nop(self):
+        """
+        Insert a NOP opcode
+        """
+        self.__insert1(OpcodeInfo.NOP)
+
     def convert_begin_while(self, is_for: bool = False) -> int:
         """
         Converts the beginning of the while statement
 
         :param is_for: whether the loop is a for loop or not
         :return: the address of the while first opcode
         """
@@ -471,29 +640,31 @@
         while_begin: VMCode = VMCodeMapping.instance().code_map[start_address]
         while_body: int = VMCodeMapping.instance().get_end_address(while_begin) + 1
         end_jmp_to: int = while_body - VMCodeMapping.instance().bytecode_size
         self._insert_jump(OpcodeInfo.JMPIF, end_jmp_to)
 
         self._current_loop.pop()
 
+        is_break_pos = self.bytecode_size
         self.convert_literal(False)  # is not break
-        is_break_pos = self.last_code_start_address
+        is_break_end = self.last_code_start_address
         self._update_break_jumps(start_address)
 
         if is_for:
             self._current_for.pop()
-            self.swap_reverse_stack_items(3)
             reverse_to_drop_pos = self.last_code_start_address
+            self.swap_reverse_stack_items(3)
+            reverse_to_drop_end = self.last_code_start_address
 
             self.remove_stack_top_item()    # removes index and sequence from stack
             self.remove_stack_top_item()
 
-            self._insert_loop_break_addresses(start_address, reverse_to_drop_pos, self.bytecode_size)
+            self._insert_loop_break_addresses(start_address, reverse_to_drop_pos, reverse_to_drop_end, self.bytecode_size)
 
-        self._insert_loop_break_addresses(start_address, is_break_pos, self.bytecode_size)
+        self._insert_loop_break_addresses(start_address, is_break_pos, is_break_end, self.bytecode_size)
         self._insert_jump(OpcodeInfo.JMPIF)
 
     def convert_end_loop_else(self, start_address: int, else_begin: int, has_else: bool = False, is_for: bool = False):
         """
         Updates the break loops jumps
 
         :param start_address: the address of the loop first opcode
@@ -631,26 +802,27 @@
 
             if isinstance(try_vm_code, TryCode):
                 try_vm_code.set_finally_code(finally_start_code)
             self._update_jump(vmcode_mapping_instance.bytecode_size, self.last_code_start_address)
 
         self._update_jump(last_address, VMCodeMapping.instance().bytecode_size)
 
-    def fix_negative_index(self, value_index: int = None):
+    def fix_negative_index(self, value_index: int = None, test_is_negative=True):
         self._can_append_target = not self._can_append_target
 
         value_code = self.last_code_start_address
         size = VMCodeMapping.instance().bytecode_size
 
-        self.duplicate_stack_top_item()
-        self.__insert1(OpcodeInfo.SIGN)
-        self.convert_literal(-1)
+        if test_is_negative:
+            self.duplicate_stack_top_item()
+            self.__insert1(OpcodeInfo.SIGN)
+            self.convert_literal(-1)
 
-        jmp_address = VMCodeMapping.instance().bytecode_size
-        self._insert_jump(OpcodeInfo.JMPNE)     # if index < 0
+            jmp_address = VMCodeMapping.instance().bytecode_size
+            self._insert_jump(OpcodeInfo.JMPNE)     # if index < 0
 
         state = self._stack_states.get_state(value_index) if isinstance(value_index, int) else self._stack
         # get position of collection relative to top
         index_of_last = -1
         for index, value in reversed(list(enumerate(state))):
             if isinstance(value, ICollectionType):
                 index_of_last = index
@@ -661,23 +833,69 @@
         else:
             pos_from_top = 2
 
         self.duplicate_stack_item(pos_from_top)     # index += len(array)
         self.convert_builtin_method_call(Builtin.Len)
         self.convert_operation(BinaryOp.Add)
 
-        if not isinstance(value_index, int):
-            value_index = VMCodeMapping.instance().bytecode_size
-        jmp_target = value_index if value_index < size else VMCodeMapping.instance().bytecode_size
-        self._update_jump(jmp_address, jmp_target)
+        if test_is_negative:
+            if not isinstance(value_index, int):
+                value_index = VMCodeMapping.instance().bytecode_size
+            jmp_target = value_index if value_index < size else VMCodeMapping.instance().bytecode_size
+            self._update_jump(jmp_address, jmp_target)
 
-        VMCodeMapping.instance().move_to_end(value_index, value_code)
+            VMCodeMapping.instance().move_to_end(value_index, value_code)
 
         self._can_append_target = not self._can_append_target
 
+    def fix_index_out_of_range(self, has_another_index_in_stack: bool):
+        """
+        Will fix a negative index to 0 or an index greater than the sequence length to the length.
+
+        For example: [0, 1, 2][-999:999] is the same as [0, 1, 2][0:3]
+
+        :param has_another_index_in_stack: whether the stack is [..., Sequence, index, index] or [..., Sequence, index].
+        """
+        # if index is still negative, then it should be 0
+        self.duplicate_stack_item(2 if has_another_index_in_stack else 1)
+        self.__insert1(OpcodeInfo.SIGN)
+        self.convert_literal(-1)
+        jmp_address = VMCodeMapping.instance().bytecode_size
+        self._insert_jump(OpcodeInfo.JMPNE)  # if index < 0, then index = 0
+
+        if has_another_index_in_stack:
+            self.swap_reverse_stack_items(2)
+        self.remove_stack_top_item()
+        self.convert_literal(0)
+        if has_another_index_in_stack:
+            self.swap_reverse_stack_items(2)
+        jmp_target = VMCodeMapping.instance().bytecode_size
+        self._update_jump(jmp_address, jmp_target)
+
+        # index can not be greater than len(string)
+        self.duplicate_stack_item(3 if has_another_index_in_stack else 2)
+        self.convert_builtin_method_call(Builtin.Len)
+        self.__insert1(
+            OpcodeInfo.MIN)  # the builtin MinMethod accepts more than 2 arguments, that's why this Opcode is being directly inserted
+        self._stack_pop()
+
+    def fix_index_negative_stride(self):
+        """
+        If stride is negative, then the array was reversed, thus, lower and upper should be changed
+        accordingly.
+        The Opcodes below will only fix 1 index.
+        array[lower:upper:-1] == reversed_array[len(array)-lower-1:len(array)-upper-1]
+        If lower or upper was None, then it's not necessary to change its values.
+        """
+        # top array should be: len(array), index
+        self.convert_builtin_method_call(Builtin.Len)
+        self.swap_reverse_stack_items(2)
+        self.convert_operation(BinaryOp.Sub)
+        self.__insert1(OpcodeInfo.DEC)
+
     def convert_loop_continue(self):
         loop_start = self._current_loop[-1]
         self._insert_jump(OpcodeInfo.JMP)
         continue_address = self.last_code_start_address
 
         if loop_start not in self._jumps_to_loop_condition:
             self._jumps_to_loop_condition[loop_start] = [continue_address]
@@ -688,32 +906,39 @@
         if loop_start_address in self._jumps_to_loop_condition:
             jump_addresses = self._jumps_to_loop_condition.pop(loop_start_address)
             for address in jump_addresses:
                 self._update_jump(address, loop_test_address)
 
     def convert_loop_break(self):
         loop_start = self._current_loop[-1]
+        is_break_pos = self.bytecode_size
         self.convert_literal(True)  # is break
         self._stack_pop()
-        is_break_pos = self.last_code_start_address
+        is_break_end = self.last_code_start_address
         self._insert_jump(OpcodeInfo.JMP)
         break_address = self.last_code_start_address
 
-        self._insert_loop_break_addresses(loop_start, is_break_pos, break_address)
+        self._insert_loop_break_addresses(loop_start, is_break_pos, is_break_end, break_address)
 
-    def _insert_loop_break_addresses(self, loop_start: int, is_break_pos: int, break_address: int):
+    def _insert_loop_break_addresses(self, loop_start: int, is_break_start: int, is_break_end: int, break_address: int):
         if loop_start not in self._jumps_to_loop_condition:
             self._jumps_to_loop_break[loop_start] = [break_address]
         elif break_address not in self._jumps_to_loop_break[loop_start]:
             self._jumps_to_loop_break[loop_start].append(break_address)
 
+        is_break_instructions = VMCodeMapping.instance().get_addresses(is_break_start, is_break_end)
+
         if loop_start not in self._inserted_loop_breaks:
-            self._inserted_loop_breaks[loop_start] = [is_break_pos]
+            self._inserted_loop_breaks[loop_start] = is_break_instructions
         else:
-            self._inserted_loop_breaks[loop_start].append(is_break_pos)
+            loop_breaks_list = self._inserted_loop_breaks[loop_start]
+            for address in is_break_instructions:
+                # don't include duplicated addresses
+                if address not in loop_breaks_list:
+                    loop_breaks_list.append(address)
 
     def _update_break_jumps(self, loop_start_address) -> int:
         jump_target = VMCodeMapping.instance().bytecode_size
 
         if loop_start_address in self._jumps_to_loop_break:
             jump_addresses = self._jumps_to_loop_break.pop(loop_start_address)
             for address in jump_addresses:
@@ -733,42 +958,46 @@
             self.convert_integer_literal(value)
         elif isinstance(value, str):
             self.convert_string_literal(value)
         elif value is None:
             self.insert_none()
         elif isinstance(value, (bytes, bytearray)):
             self.convert_byte_array(value)
+        elif isinstance(value, Sequence):
+            self.convert_sequence_literal(value)
+        elif isinstance(value, dict):
+            self.convert_dict_literal(value)
         else:
-            # TODO: convert other python literals as they are implemented
+            # it's not a type that is supported by neo-boa
             raise NotImplementedError
         return start_address
 
     def convert_integer_literal(self, value: int):
         """
         Converts an integer literal value
 
         :param value: the value to be converted
         """
-        opcode = Opcode.get_literal_push(value)
+        opcode = OpcodeHelper.get_literal_push(value)
         if opcode is not None:
             op_info: OpcodeInformation = OpcodeInfo.get_info(opcode)
             self.__insert1(op_info)
             self._stack_append(Type.int)
         else:
-            opcode = Opcode.get_literal_push(-value)
+            opcode = OpcodeHelper.get_literal_push(-value)
             if opcode is not None:
                 op_info: OpcodeInformation = OpcodeInfo.get_info(opcode)
                 self.__insert1(op_info)
                 self._stack_append(Type.int)
                 self.convert_operation(UnaryOp.Negative)
             else:
-                array = Integer(value).to_byte_array(signed=True)
-                self.insert_push_data(array)
-                # cast the value to integer
-                self.convert_cast(Type.int)
+                opcode, data = OpcodeHelper.get_push_and_data(value)
+                op_info: OpcodeInformation = OpcodeInfo.get_info(opcode)
+                self.__insert1(op_info, data)
+                self._stack_append(Type.int)
 
     def convert_string_literal(self, value: str):
         """
         Converts an string literal value
 
         :param value: the value to be converted
         """
@@ -779,19 +1008,50 @@
     def convert_bool_literal(self, value: bool):
         """
         Converts an boolean literal value
 
         :param value: the value to be converted
         """
         if value:
-            self.__insert1(OpcodeInfo.PUSH1)
+            self.__insert1(OpcodeInfo.PUSHT)
         else:
-            self.__insert1(OpcodeInfo.PUSH0)
+            self.__insert1(OpcodeInfo.PUSHF)
         self._stack_append(Type.bool)
 
+    def convert_sequence_literal(self, sequence: Sequence):
+        """
+        Converts a sequence value
+
+        :param sequence: the value to be converted
+        """
+        if isinstance(sequence, tuple):
+            value_type = Type.tuple.build(sequence)
+        else:
+            value_type = Type.list.build(list(sequence))
+
+        for inner_value in reversed(sequence):
+            self.convert_literal(inner_value)
+
+        self.convert_new_array(len(sequence), value_type)
+
+    def convert_dict_literal(self, dictionary: dict):
+        """
+        Converts a dict value
+
+        :param dictionary: the value to be converted
+        """
+        value_type = Type.dict.build(dictionary)
+        self.convert_new_map(value_type)
+
+        for key, value in dictionary.items():
+            self.duplicate_stack_top_item()
+            self.convert_literal(key)
+            value_start = self.convert_literal(value)
+            self.convert_set_item(value_start)
+
     def convert_byte_array(self, array: bytes):
         """
         Converts a byte value
 
         :param array: the value to be converted
         """
         self.insert_push_data(array)
@@ -855,14 +1115,15 @@
         :param length: the size of the new array
         :param array_type: the Neo Boa type of the array
         """
         if length <= 0:
             self.__insert1(OpcodeInfo.NEWARRAY0)
         else:
             self.convert_literal(length)
+            self._stack_pop()
             self.__insert1(OpcodeInfo.NEWARRAY)
         self._stack_append(array_type)
 
     def convert_new_array(self, length: int, array_type: IType = Type.list):
         """
         Converts the creation of a new array
 
@@ -875,47 +1136,48 @@
             self.convert_literal(length)
             self.__insert1(OpcodeInfo.PACK)
             self._stack_pop()  # array size
             for x in range(length):
                 self._stack_pop()
             self._stack_append(array_type)
 
-    def _set_array_item(self, value_start_address: int):
+    def _set_array_item(self, value_start_address: int, check_for_negative_index: bool = True):
         """
         Converts the end of setting af a value in an array
         """
         index_type: IType = self._stack[-2]  # top: index
-        if index_type is Type.int:
+        if index_type is Type.int and check_for_negative_index:
             self.fix_negative_index(value_start_address)
 
-    def convert_set_item(self, value_start_address: int):
+    def convert_set_item(self, value_start_address: int, index_inserted_internally: bool = False):
         """
         Converts the end of setting af a value in an array
         """
         item_type: IType = self._stack[-3]  # top: index, 2nd-to-top: value, 3nd-to-top: array or map
         if item_type.stack_item is not StackItemType.Map:
-            self._set_array_item(value_start_address)
+            self._set_array_item(value_start_address, check_for_negative_index=not index_inserted_internally)
 
         self.__insert1(OpcodeInfo.SETITEM)
         self._stack_pop()  # value
         self._stack_pop()  # index
         self._stack_pop()  # array or map
 
-    def _get_array_item(self):
+    def _get_array_item(self, check_for_negative_index: bool = True, test_is_negative_index=True):
         """
         Converts the end of get a value in an array
         """
         index_type: IType = self._stack[-1]  # top: index
-        if index_type is Type.int:
-            self.fix_negative_index()
+        if index_type is Type.int and check_for_negative_index:
+            self.fix_negative_index(test_is_negative=test_is_negative_index)
 
-    def convert_get_item(self):
+    def convert_get_item(self, index_inserted_internally: bool = False, index_is_positive=False, test_is_negative_index=True):
         array_or_map_type: IType = self._stack[-2]  # second-to-top: array or map
         if array_or_map_type.stack_item is not StackItemType.Map:
-            self._get_array_item()
+            self._get_array_item(check_for_negative_index=not (index_inserted_internally or index_is_positive),
+                                 test_is_negative_index=test_is_negative_index)
 
         if array_or_map_type is Type.str:
             self.convert_literal(1)  # length of substring
             self.convert_get_substring()
         else:
             self.__insert1(OpcodeInfo.PICKITEM)
             self._stack_pop()
@@ -974,185 +1236,356 @@
         self.convert_end_loop_else(start_jump, self.last_code_start_address, False)
         self.remove_stack_top_item()        # removes from the stack the arguments and the index
         self.swap_reverse_stack_items(4)    # doesn't use CLEAR opcode because this would delete
         self.remove_stack_top_item()        # data from external scopes
         self.remove_stack_top_item()
         self.remove_stack_top_item()
 
-    def convert_get_sub_array(self, value_addresses: List[int] = None):
+    def convert_get_sub_sequence(self):
         """
-        Converts the end of get a slice in the beginning of an array
-
-        :param value_addresses: the start and end values addresses
+        Gets a slice of an array or ByteString
         """
         # top: length, index, array
         if len(self._stack) > 2 and isinstance(self._stack[-3], SequenceType):
-            if value_addresses is not None:
-                # use the next value address to found where the opcodes to fix the value sign should be
-                end_value_opcodes = value_addresses[1:]
-                for code in reversed(end_value_opcodes):
-                    self.fix_negative_index(code)
-                self.fix_negative_index()  # fix the last value sign
 
             if self._stack[-3].stack_item in (StackItemType.ByteString,
                                               StackItemType.Buffer):
                 self.duplicate_stack_item(2)
                 self.convert_operation(BinaryOp.Sub)
                 self.convert_get_substring()
             else:
                 array = self._stack[-3]
-                self.duplicate_stack_item(3)        # if slice end is greater than the array size, fixes them
-                self.convert_builtin_method_call(Builtin.Len)
-
-                # TODO: change to convert_builtin_method_call(Builtin.Min) when min(a, b) is implemented
-                self.__insert1(OpcodeInfo.MIN)
-                self._stack_pop()
                 self.convert_get_array_slice(array)
 
-    def convert_get_array_beginning(self):
+    def convert_get_sequence_beginning(self):
         """
-        Converts the end of get a slice in the beginning of an array
+        Gets the beginning slice of an array or ByteString
         """
         if len(self._stack) > 1 and isinstance(self._stack[-2], SequenceType):
-            self.fix_negative_index()
             if self._stack[-2].stack_item in (StackItemType.ByteString,
                                               StackItemType.Buffer):
                 self.__insert1(OpcodeInfo.LEFT)
                 self._stack_pop()  # length
                 original_type = self._stack_pop()  # original array
                 self._stack_append(BufferType)  # left returns a buffer instead of a bytestring
                 self.convert_cast(original_type)
             else:
                 array = self._stack[-2]
+
                 self.convert_literal(0)
                 self.swap_reverse_stack_items(2)
                 self.convert_get_array_slice(array)
 
-    def convert_get_array_ending(self):
+    def convert_get_sequence_ending(self):
         """
-        Converts the end of get a slice in the ending of an array
+        Gets the ending slice of an array or ByteString
         """
-        # top: start_slice, array_length, array
-        if len(self._stack) > 2 and isinstance(self._stack[-3], SequenceType):
-            self.fix_negative_index()
-            if self._stack[-3].stack_item in (StackItemType.ByteString,
+        # top: start_slice, array
+        if len(self._stack) > 1 and isinstance(self._stack[-2], SequenceType):
+            if self._stack[-2].stack_item in (StackItemType.ByteString,
                                               StackItemType.Buffer):
-                self.convert_operation(BinaryOp.Sub)
+                self.duplicate_stack_item(2)
+                self.convert_builtin_method_call(Builtin.Len)
+                self.swap_reverse_stack_items(2)
+                self.convert_operation(BinaryOp.Sub)    # gets the amount of chars that should be taken after the index
                 self.__insert1(OpcodeInfo.RIGHT)
                 self._stack_pop()  # length
                 original_type = self._stack_pop()  # original array
                 self._stack_append(BufferType)     # right returns a buffer instead of a bytestring
                 self.convert_cast(original_type)
             else:
-                array = self._stack[-3]
-                self.swap_reverse_stack_items(2)
+                array = self._stack[-2]
+
+                self.duplicate_stack_item(2)
+                self.convert_builtin_method_call(Builtin.Len)
+
                 self.convert_get_array_slice(array)
 
     def convert_copy(self):
         if self._stack[-1].stack_item is StackItemType.Array:
             self.__insert1(OpcodeInfo.UNPACK)
             self.__insert1(OpcodeInfo.PACK)    # creates a new array with the values
 
+    def convert_get_stride(self):
+        if len(self._stack) > 1 and isinstance(self._stack[-2], SequenceType):
+            if self._stack[-2].stack_item in (StackItemType.ByteString, StackItemType.Buffer):
+                self.convert_get_substring_stride()
+            else:
+                self.convert_get_array_stride()
+
+    def convert_array_negative_stride(self):
+        """
+        Converts an array to its reverse, to be able to scroll through the reversed list
+        """
+        # The logic on this function only do variable[::-z]
+
+        original = self._stack[-1]
+        self.convert_builtin_method_call(Builtin.Reversed)
+        self.convert_cast(ListType())
+        if isinstance(original, (StrType, BytesType)):        # if self was a string/bytes, then concat the values in the array
+            self.duplicate_stack_top_item()
+            self.convert_builtin_method_call(Builtin.Len)       # index = len(array) - 1
+            self.convert_literal('')                            # string = ''
+
+            start_jump = self.convert_begin_while()
+            self.duplicate_stack_item(3)
+            self.duplicate_stack_item(3)
+            str_type = self._stack[-3]
+            self.__insert1(OpcodeInfo.PICKITEM)
+            self._stack_pop()
+            self._stack_pop()
+            self._stack_append(str_type)
+            self.swap_reverse_stack_items(2)
+            self.convert_operation(BinaryOp.Concat)             # string = string + array[index]
+
+            condition_address = VMCodeMapping.instance().bytecode_size
+            self.swap_reverse_stack_items(2)
+            self.__insert1(OpcodeInfo.DEC)                      # index--
+            self.swap_reverse_stack_items(2)
+            self.duplicate_stack_item(2)
+            self.convert_literal(0)
+            self.convert_operation(BinaryOp.GtE)                # if index <= 0, stop loop
+            self.convert_end_while(start_jump, condition_address)
+            self.convert_end_loop_else(start_jump, self.last_code_start_address, False)
+
+            # remove auxiliary values
+            self.swap_reverse_stack_items(3)
+            self.remove_stack_top_item()
+            self.remove_stack_top_item()
+
+    def convert_get_substring_stride(self):
+        # initializing auxiliary variables
+        self.duplicate_stack_item(2)
+        self.convert_builtin_method_call(Builtin.Len)
+        self.convert_literal(0)                         # index = 0
+        self.convert_literal('')                        # substr = ''
+
+        # logic verifying if substr[index] should be concatenated or not
+        start_jump = self.convert_begin_while()
+        self.duplicate_stack_item(2)
+        self.duplicate_stack_item(5)
+        self.convert_operation(BinaryOp.Mod)
+        self.convert_literal(0)
+        self.convert_operation(BinaryOp.NumEq)
+        is_mod_0 = self.convert_begin_if()              # if index % stride == 0, then concatenate it
+
+        # concatenating substr[index] with substr
+        self.duplicate_stack_item(5)
+        self.duplicate_stack_item(3)
+        self.convert_literal(1)
+        self._stack_pop()  # length
+        self._stack_pop()  # start
+        str_type = self._stack_pop()
+        self.__insert1(OpcodeInfo.SUBSTR)
+        self._stack_append(BufferType)                  # SUBSTR returns a buffer instead of a bytestring
+        self.convert_cast(str_type)
+        self.convert_operation(BinaryOp.Concat)         # substr = substr + string[index]
+        self.convert_end_if(is_mod_0)
+
+        # increment the index by 1
+        self.swap_reverse_stack_items(2)
+        self.__insert1(OpcodeInfo.INC)                  # index++
+        self.swap_reverse_stack_items(2)
+
+        # verifying if it should still be in the while
+        condition_address = VMCodeMapping.instance().bytecode_size
+        self.duplicate_stack_item(2)
+        self.duplicate_stack_item(4)
+        self.convert_operation(BinaryOp.Lt)             # stop the loop when index >= len(str)
+        self.convert_end_while(start_jump, condition_address)
+        self.convert_end_loop_else(start_jump, self.last_code_start_address, False)
+
+        # removing auxiliary values
+        self.swap_reverse_stack_items(5)
+        self.remove_stack_top_item()
+        self.remove_stack_top_item()
+        self.remove_stack_top_item()
+        self.remove_stack_top_item()
+
+    def convert_get_array_stride(self):
+        # initializing auxiliary variable
+        self.duplicate_stack_item(2)
+        self.convert_builtin_method_call(Builtin.Len)
+        self.__insert1(OpcodeInfo.DEC)                      # index = len(array) - 1
+
+        # logic verifying if array[index] should be removed or not
+        start_jump = self.convert_begin_while()
+        self.duplicate_stack_item(2)
+        self.duplicate_stack_item(2)
+        self.swap_reverse_stack_items(2)
+        self.convert_operation(BinaryOp.Mod)
+        self.convert_literal(0)
+        self.convert_operation(BinaryOp.NumNotEq)
+        is_not_mod_0 = self.convert_begin_if()              # if index % stride != 0, then remove it
+
+        # removing element from array
+        self.duplicate_stack_item(3)
+        self.duplicate_stack_item(2)
+        self.__insert1(OpcodeInfo.REMOVE)                   # array.pop(index)
+        self._stack_pop()
+        self._stack_pop()
+        self.convert_end_if(is_not_mod_0)
+
+        # decrement 1 from index
+        self.__insert1(OpcodeInfo.DEC)
+
+        # verifying if it should still be in the while
+        condition_address = VMCodeMapping.instance().bytecode_size
+        self.duplicate_stack_top_item()
+        self.__insert1(OpcodeInfo.SIGN)
+        self.convert_literal(-1)
+        self.convert_operation(BinaryOp.NumNotEq)       # stop the loop when index < 0
+        self.convert_end_while(start_jump, condition_address)
+        self.convert_end_loop_else(start_jump, self.last_code_start_address, False)
+
+        # removing auxiliary values
+        self.remove_stack_top_item()                    # removed index from stack
+        self.remove_stack_top_item()                    # removed stride from stack
+
     def convert_starred_variable(self):
         top_stack_item = self._stack[-1].stack_item
         if top_stack_item is StackItemType.Array:
             self.convert_copy()
         elif top_stack_item is StackItemType.Map:
             self.convert_builtin_method_call(Builtin.DictKeys)
         else:
             return
 
         self.convert_cast(Type.tuple)
 
-    def convert_load_symbol(self, symbol_id: str, params_addresses: List[int] = None, is_internal: bool = False):
+    def convert_load_symbol(self, symbol_id: str, params_addresses: List[int] = None, is_internal: bool = False,
+                            class_type: Optional[UserClass] = None):
         """
         Converts the load of a symbol
 
         :param symbol_id: the symbol identifier
         :param params_addresses: a list with each function arguments' first addresses
         """
-        symbol = self.get_symbol(symbol_id, is_internal=is_internal)
+        if class_type is None and len(self._stack) > 0 and isinstance(self._stack[-1], UserClass):
+            class_type = self._stack[-1]
+
+        another_symbol_id, symbol = self.get_symbol(symbol_id, is_internal=is_internal)
+
+        if class_type is not None and symbol_id in class_type.symbols:
+            symbol = class_type.symbols[symbol_id]
+
         if symbol is not Type.none:
             if isinstance(symbol, Property):
                 symbol = symbol.getter
                 params_addresses = []
             elif isinstance(symbol, ClassType) and params_addresses is not None:
                 symbol = symbol.constructor_method()
 
             if not params_addresses:
                 params_addresses = []
 
             if isinstance(symbol, Variable):
-                self.convert_load_variable(symbol_id, symbol)
+                symbol_id = another_symbol_id
+                self.convert_load_variable(symbol_id, symbol, class_type)
             elif isinstance(symbol, IBuiltinMethod) and symbol.body is None:
                 self.convert_builtin_method_call(symbol, params_addresses)
             elif isinstance(symbol, Event):
                 self.convert_event_call(symbol)
             elif isinstance(symbol, Method):
                 self.convert_method_call(symbol, len(params_addresses))
+            elif isinstance(symbol, UserClass):
+                self.convert_class_symbol(symbol, symbol_id)
 
-    def convert_load_variable(self, var_id: str, var: Variable):
+    def convert_load_variable(self, var_id: str, var: Variable, class_type: Optional[UserClass] = None):
         """
         Converts the assignment of a variable
 
         :param var_id: the value to be converted
         :param var: the actual variable to be loaded
         """
         index, local, is_arg = self._get_variable_info(var_id)
         if index >= 0:
-            opcode = Opcode.get_load(index, local, is_arg)
+            opcode = OpcodeHelper.get_load(index, local, is_arg)
             op_info = OpcodeInfo.get_info(opcode)
 
             if op_info.data_len > 0:
                 self.__insert1(op_info, Integer(index).to_byte_array())
             else:
                 self.__insert1(op_info)
             self._stack_append(var.type)
 
         elif hasattr(var.type, 'get_value'):
             # the variable is a type constant
             # TODO: change this when implement class conversion
-            value = var.type.get_value(var_id.split('.')[-1])
+            value = var.type.get_value(var_id.split(constants.ATTRIBUTE_NAME_SEPARATOR)[-1])
             if value is not None:
                 self.convert_literal(value)
 
         elif var_id in self._globals:
-            var = self.get_symbol(var_id)
+            another_var_id, var = self.get_symbol(var_id)
             storage_key = codegenerator.get_storage_key_for_variable(var)
             self._convert_builtin_storage_get_or_put(True, storage_key)
 
-    def convert_store_variable(self, var_id: str, value_start_address: int = None):
+        elif class_type:
+            if var_id in class_type.variables:
+                index = list(class_type.variables).index(var_id)
+                self.convert_literal(index)
+                self.convert_get_item(index_inserted_internally=True)
+                self._stack_pop()             # pop class type
+                self._stack_append(var.type)  # push variable type
+
+    def convert_store_variable(self, var_id: str, value_start_address: int = None, user_class: UserClass = None):
         """
         Converts the assignment of a variable
 
         :param var_id: the value to be converted
         """
+        inner_index = None
         index, local, is_arg = self._get_variable_info(var_id)
+
+        if user_class is None and len(self._stack) > 1 and isinstance(self._stack[-2], UserClass):
+            user_class = self._stack[-2]
+
+        if isinstance(user_class, UserClass) and var_id in user_class.variables:
+            index, local, is_arg = self._get_variable_info(user_class.identifier)
+            inner_index = list(user_class.variables).index(var_id)
+
+        if isinstance(inner_index, int):
+            # it's a variable from a class
+            self.convert_literal(inner_index)
+            index_address = self.bytecode_size
+
+            if var_id in user_class.class_variables:
+                # it's a class variable
+                self.convert_load_variable(user_class.identifier, Variable(user_class))
+                no_stack_items_to_swap = 3
+            else:
+                no_stack_items_to_swap = 2
+
+            self.swap_reverse_stack_items(no_stack_items_to_swap)
+            self.convert_set_item(index_address, index_inserted_internally=True)
+            return
+
         if index >= 0:
-            opcode = Opcode.get_store(index, local, is_arg)
+            opcode = OpcodeHelper.get_store(index, local, is_arg)
             if opcode is not None:
                 op_info = OpcodeInfo.get_info(opcode)
 
                 if op_info.data_len > 0:
                     self.__insert1(op_info, Integer(index).to_byte_array())
                 else:
                     self.__insert1(op_info)
                 stored_type = self._stack_pop()
 
-                from boa3.analyser.model.optimizer import UndefinedType
+                from boa3.internal.analyser.model.optimizer import UndefinedType
                 if (var_id in self._current_scope.symbols or
                         (var_id in self._locals and self._current_method.locals[var_id].type is UndefinedType)):
-                    symbol = self.get_symbol(var_id)
+                    another_symbol_id, symbol = self.get_symbol(var_id)
                     if isinstance(symbol, Variable):
                         var = symbol.copy()
                         var.set_type(stored_type)
                         self._current_scope.include_symbol(var_id, var)
 
         elif var_id in self._globals:
-            var = self.get_symbol(var_id)
+            another_var_id, var = self.get_symbol(var_id)
             storage_key = codegenerator.get_storage_key_for_variable(var)
             if value_start_address is None:
                 value_start_address = self.bytecode_size
             self._convert_builtin_storage_get_or_put(False, storage_key, value_start_address)
 
     def _convert_builtin_storage_get_or_put(self, is_get: bool, storage_key: bytes, arg_address: int = None):
         addresses = [arg_address] if arg_address is not None else [self.bytecode_size]
@@ -1217,16 +1650,16 @@
 
         if function.pack_arguments:
             self.convert_new_array(len(args_address))
 
         if function.stores_on_slot and 0 < len(function.args) <= len(args_address):
             address = args_address[-len(function.args)]
             load_instr = VMCodeMapping.instance().code_map[address]
-            if load_instr.opcode.is_load_slot:
-                store: Opcode = Opcode.get_store_from_load(load_instr.opcode)
+            if OpcodeHelper.is_load_slot(load_instr.opcode):
+                store: Opcode = OpcodeHelper.get_store_from_load(load_instr.opcode)
                 store_opcode = OpcodeInfo.get_info(store)
                 store_data = load_instr.data
 
         fix_negatives = function.validate_negative_arguments()
         if len(fix_negatives) > 0:
             args_end_addresses = args_address[1:]
             args_end_addresses.append(self.bytecode_size)
@@ -1238,56 +1671,98 @@
 
             for arg in sorted(fix_negatives, reverse=True):
                 if len(addresses) > arg:
                     self.fix_negative_index(addresses[arg])
 
         for opcode, data in function.opcode:
             op_info = OpcodeInfo.get_info(opcode)
-            self.__insert1(op_info, data)
+            if opcode is Opcode.CALL and isinstance(data, Method):
+                # avoid losing current stack state
+                for _ in data.args:
+                    self._stack_append(Type.any)
+                self.convert_method_call(data, len(data.args) - 1)
+            else:
+                self.__insert1(op_info, data)
 
         if store_opcode is not None:
             self._insert_jump(OpcodeInfo.JMP)
             jump = self.last_code_start_address
             self.__insert1(store_opcode, store_data)
             self._update_jump(jump, VMCodeMapping.instance().bytecode_size)
 
         for _ in range(function.args_on_stack):
             self._stack_pop()
         if function.return_type not in (None, Type.none):
             self._stack_append(function.return_type)
 
     def convert_method_call(self, function: Method, num_args: int):
         """
-        Converts a builtin method function call
+        Converts a method function call
 
         :param function: the function to be converted
         """
-        from boa3.neo.vm.CallCode import CallCode
-        self.__insert_code(CallCode(function))
+        if function.is_init:
+            if num_args == len(function.args):
+                self.remove_stack_top_item()
+                num_args -= 1
+
+            if num_args == len(function.args) - 1:
+                # if this method is a constructor and only the self argument is missing
+                function_result = function.type
+                size = len(function_result.variables) if isinstance(function_result, UserClass) else 0
+                if self.stack_size < 1 or not self._stack[-1].is_type_of(function_result):
+                    self.convert_new_empty_array(size, function_result)
+
+        if isinstance(function.origin_class, ContractInterfaceClass):
+            if function.external_name is not None:
+                function_id = function.external_name
+            else:
+                function_id = next((symbol_id
+                                    for symbol_id, symbol in function.origin_class.symbols.items()
+                                    if symbol is function),
+                                   None)
+            self._add_to_metadata_permissions(function.origin_class, function_id)
+
+            if isinstance(function_id, str):
+                self.convert_new_array(len(function.args))
+                self.convert_literal(Interop.CallFlagsType.default_value)
+                self.convert_literal(function_id)
+                self.convert_literal(function.origin_class.contract_hash.to_array())
+                self.convert_builtin_method_call(Interop.CallContract)
+                self._stack_pop()  # remove call contract 'any' result from the stack
+                self._stack_append(function.return_type)    # add the return type on the stack even if it is None
 
-        for arg in range(num_args):
-            self._stack_pop()
+        else:
+            from boa3.internal.neo.vm.CallCode import CallCode
+            call_code = CallCode(function)
+            self.__insert_code(call_code)
+            self._update_codes_with_target(call_code)
 
-        if function.return_type is not Type.none:
-            self._stack_append(function.return_type)
+            for arg in range(num_args):
+                self._stack_pop()
+            if function.is_init:
+                self._stack_pop()  # pop duplicated result if it's init
+
+            if function.return_type is not Type.none:
+                self._stack_append(function.return_type)
 
     def convert_event_call(self, event: Event):
         """
         Converts an event call
 
         :param event_id: called event identifier
         :param event: called event
         """
         self.convert_new_array(len(event.args_to_generate), Type.list)
         if event.generate_name:
             self.convert_literal(event.name)
         else:
             self.swap_reverse_stack_items(2)
 
-        from boa3.model.builtin.interop.interop import Interop
+        from boa3.internal.model.builtin.interop.interop import Interop
         for opcode, data in Interop.Notify.opcode:
             info = OpcodeInfo.get_info(opcode)
             self.__insert1(info, data)
             self._stack_pop()
             self._stack_pop()
 
     def convert_class_symbol(self, class_type: ClassType, symbol_id: str, load: bool = True) -> Optional[int]:
@@ -1303,37 +1778,58 @@
         if symbol_id in class_type.variables:
             return self.convert_class_variable(class_type, symbol_id, load)
         elif symbol_id in class_type.properties:
             symbol = class_type.properties[symbol_id]
             method = symbol.getter if load else symbol.setter
         elif symbol_id in class_type.instance_methods:
             method = class_type.instance_methods[symbol_id]
+        elif symbol_id in class_type.class_methods:
+            method = class_type.class_methods[symbol_id]
+        elif isinstance(class_type, UserClass):
+            return self.convert_user_class(class_type, symbol_id)
         else:
             return
 
         if isinstance(method, IBuiltinMethod):
             self.convert_builtin_method_call(method)
         else:
             self.convert_method_call(method, 0)
         return symbol_id
 
+    def convert_user_class(self, class_type: UserClass, symbol_id: str) -> Optional[int]:
+        """
+        Converts an class symbol
+
+        :param class_type:
+        :param symbol_id:
+        """
+        start_address = self.bytecode_size
+
+        if symbol_id in self._statics:
+            self.convert_load_variable(symbol_id, Variable(class_type))
+        else:
+            # TODO: change to create an array with the class variables' default values when they are implemented
+            self.convert_new_empty_array(len(class_type.class_variables), class_type)
+
+        return start_address
+
     def convert_class_variable(self, class_type: ClassType, symbol_id: str, load: bool = True):
         """
         Converts an class variable
 
         :param class_type:
         :param symbol_id:
         :param load:
         """
         if symbol_id in class_type.variables:
             index = list(class_type.variables).index(symbol_id)
 
             if load:
                 self.convert_literal(index)
-                self.convert_get_item()
+                self.convert_get_item(index_inserted_internally=True)
 
             return index
 
     def convert_operation(self, operation: IOperation):
         """
         Converts an operation
 
@@ -1396,15 +1892,15 @@
         Inserts one opcode into the bytecode
 
         :param op_info: info of the opcode  that will be inserted
         :param data: data of the opcode, if needed
         """
         vm_code = VMCode(op_info, data)
 
-        if op_info.opcode.has_target():
+        if OpcodeHelper.has_target(op_info.opcode):
             data = vm_code.raw_data
             relative_address: int = Integer.from_bytes(data, signed=True)
             actual_address = VMCodeMapping.instance().bytecode_size + relative_address
             if (self._can_append_target
                     and relative_address != 0
                     and actual_address in VMCodeMapping.instance().code_map):
                 vm_code.set_target(VMCodeMapping.instance().code_map[actual_address])
@@ -1426,15 +1922,15 @@
         """
         Includes a instruction which parameter is another instruction that wasn't converted yet
 
         :param vmcode: instruction with incomplete parameter
         :param target_address: target instruction expected address
         :return:
         """
-        if vmcode.opcode.has_target():
+        if OpcodeHelper.has_target(vmcode.opcode):
             if target_address == VMCodeMapping.instance().bytecode_size:
                 target_address = None
             else:
                 self._remove_missing_target(vmcode)
 
             if target_address not in self._missing_target:
                 self._missing_target[target_address] = []
@@ -1444,22 +1940,40 @@
     def _remove_missing_target(self, vmcode: VMCode):
         """
         Removes a instruction from the missing target list
 
         :param vmcode: instruction with incomplete parameter
         :return:
         """
-        if vmcode.opcode.has_target():
+        if OpcodeHelper.has_target(vmcode.opcode):
             for target_address, opcodes in self._missing_target.copy().items():
                 if vmcode in opcodes:
                     opcodes.remove(vmcode)
                     if len(opcodes) == 0:
                         self._missing_target.pop(target_address)
                     break
 
+    def _check_codes_with_target(self) -> bool:
+        """
+        Verifies if there are any instructions targeting positions not included yet.
+        """
+        instance = VMCodeMapping.instance()
+        current_bytecode_size = instance.bytecode_size
+        for target_address, codes in list(self._missing_target.items()):
+            if target_address is not None and target_address >= current_bytecode_size:
+                return True
+
+        if None in self._missing_target:
+            for code in self._missing_target[None]:
+                if OpcodeHelper.is_jump(code.info.opcode) and code.target is None:
+                    target = Integer.from_bytes(code.raw_data) + VMCodeMapping.instance().get_start_address(code) + 1
+                    if target >= current_bytecode_size:
+                        return True
+        return False
+
     def _update_codes_with_target(self, vm_code: VMCode):
         """
         Verifies if there are any instructions targeting the code. If it exists, updates each instruction found
 
         :param vm_code: targeted instruction
         """
         instance = VMCodeMapping.instance()
@@ -1523,61 +2037,121 @@
                 VMCodeMapping.instance().update_vm_code(vmcode, vmcode.info, data)
                 if updated_jump_to not in VMCodeMapping.instance().code_map:
                     self._include_missing_target(vmcode, updated_jump_to)
 
     def _get_jump_data(self, op_info: OpcodeInformation, jump_to: int) -> bytes:
         return Integer(jump_to).to_byte_array(min_length=op_info.data_len, signed=True)
 
+    def _add_to_metadata_permissions(self, contract_class: ContractInterfaceClass, method_name: str):
+        from boa3.internal.compiler.compiledmetadata import CompiledMetadata
+        CompiledMetadata.instance().add_contract_permission(contract_class.contract_hash, method_name)
+
     def duplicate_stack_top_item(self):
         self.duplicate_stack_item(1)
 
     def duplicate_stack_item(self, pos: int = 0):
         """
         Duplicates the item n back in the stack
 
         :param pos: index of the variable
         """
         # n = 1 -> duplicates stack top item
         # n = 0 -> value varies in runtime
         if pos >= 0:
-            opcode: Opcode = Opcode.get_dup(pos)
+            opcode: Opcode = OpcodeHelper.get_dup(pos)
             if opcode is Opcode.PICK and pos > 0:
                 self.convert_literal(pos - 1)
                 self._stack_pop()
             op_info = OpcodeInfo.get_info(opcode)
             self.__insert1(op_info)
             self._stack_append(self._stack[-pos])
 
     def clear_stack(self, clear_if_in_loop: bool = False):
         if not clear_if_in_loop or len(self._current_for) > 0:
-            self.__insert1(OpcodeInfo.CLEAR)
+            for _ in range(self.stack_size):
+                self.__insert1(OpcodeInfo.DROP)
 
     def remove_stack_top_item(self):
         self.remove_stack_item(1)
 
     def remove_stack_item(self, pos: int = 0):
         """
         Removes the item n from the stack
 
         :param pos: index of the variable
         """
         # n = 1 -> removes stack top item
         if pos > 0:
-            opcode: Opcode = Opcode.get_drop(pos)
+            opcode: Opcode = OpcodeHelper.get_drop(pos)
             if opcode is Opcode.XDROP:
                 self.convert_literal(pos - 1)
                 self._stack_pop()
             op_info = OpcodeInfo.get_info(opcode)
             self.__insert1(op_info)
             if pos > 0 and len(self._stack) > 0:
                 self._stack_pop(-pos)
 
+    def _remove_inserted_opcodes_since(self, last_address: int, last_stack_size: Optional[int] = None):
+        self._stack_states.restore_state(last_address)
+        if VMCodeMapping.instance().bytecode_size > last_address:
+            # remove opcodes inserted during the evaluation of the symbol
+            VMCodeMapping.instance().remove_opcodes(last_address, VMCodeMapping.instance().bytecode_size)
+
+        if isinstance(last_stack_size, int) and last_stack_size < self.stack_size:
+            # remove any additional values pushed to the stack during the evalution of the symbol
+            for _ in range(self.stack_size - last_stack_size):
+                self._stack_pop()
+
     def swap_reverse_stack_items(self, no_items: int = 0):
         # n = 0 -> value varies in runtime
         if 0 <= no_items != 1:
-            opcode: Opcode = Opcode.get_reverse(no_items)
+            opcode: Opcode = OpcodeHelper.get_reverse(no_items)
             if opcode is Opcode.REVERSEN and no_items > 0:
                 self.convert_literal(no_items)
             op_info = OpcodeInfo.get_info(opcode)
             self.__insert1(op_info)
+            if opcode is Opcode.REVERSEN and no_items > 0:
+                self._stack_pop()
             if no_items > 0:
                 self._stack.reverse(-no_items)
+
+    def convert_init_user_class(self, class_type: ClassType):
+        # TODO: refactor when instance variables are implemented
+        if isinstance(class_type, UserClass):
+            # create an none-filled array with the size of the instance variables
+            no_instance_variables = len(class_type.instance_variables)
+            self.convert_new_empty_array(no_instance_variables, class_type)
+
+            self.__insert1(OpcodeInfo.UNPACK)  # unpack for array concatenation
+            value = self._stack_pop()
+            self._stack_append(Type.int)
+            self.remove_stack_top_item()
+
+            # copy the array that stores the class variables from that class
+            self.convert_user_class(class_type, class_type.identifier)
+
+            self.__insert1(OpcodeInfo.UNPACK)  # unpack for array concatenation
+            self._stack_append(value)
+            self.convert_literal(no_instance_variables)
+            self.convert_operation(BinaryOp.Add)
+
+            self.__insert1(OpcodeInfo.PACK)  # packs everything together
+            self._stack_pop()
+
+    def generate_implicit_init_user_class(self, init_method: Method):
+        if not init_method.is_called:
+            return
+
+        self.convert_begin_method(init_method)
+        class_type = init_method.return_type
+        for base in class_type.bases:
+            base_constructor = base.constructor_method()
+            num_args = len(base_constructor.args)
+
+            for arg_id, arg_var in reversed(list(init_method.args.items())):
+                self.convert_load_variable(arg_id, arg_var)
+
+            args_to_call = num_args - 1 if num_args > 0 else num_args
+            self.convert_method_call(base_constructor, args_to_call)
+            self.remove_stack_top_item()
+
+        self.convert_end_method()
```

### Comparing `neo3-boa-0.9.0/boa3/compiler/codegenerator/initstatementsvisitor.py` & `neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/initstatementsvisitor.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 import ast
 from typing import Dict, List, Tuple
 
-from boa3 import constants
-from boa3.analyser.astanalyser import IAstAnalyser
-from boa3.model.symbol import ISymbol
+from boa3.internal import constants
+from boa3.internal.analyser.astanalyser import IAstAnalyser
+from boa3.internal.model.symbol import ISymbol
 
 
 class InitStatementsVisitor(IAstAnalyser):
     """
     This class is separate the instructions that should be included in the '_deploy" internal method from those
     from the '_initialize' internal method.
 
     The methods with the name starting with 'visit_' are implementations of methods from the :class:`NodeVisitor` class.
     These methods are used to walk through the Python abstract syntax tree.
 
     """
 
-    def __init__(self, symbols: Dict[str, ISymbol]):
-        super().__init__(ast.parse(""), log=True)
+    def __init__(self, symbols: Dict[str, ISymbol], fail_fast: bool = True):
+        super().__init__(ast.parse(""), log=True, fail_fast=fail_fast)
         self.symbols = symbols.copy()
 
         self._deploy_instructions: List[ast.AST] = []
         self._init_instructions: List[ast.AST] = []
 
     @classmethod
     def separate_global_statements(cls,
```

### Comparing `neo3-boa-0.9.0/boa3/compiler/codegenerator/stackmemento.py` & `neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/stackmemento.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from __future__ import annotations
 
 from typing import Dict, List, Tuple, Union
 
-from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
-from boa3.model.type.itype import IType
-from boa3.neo.vm.VMCode import VMCode
+from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.VMCode import VMCode
 
 
 class StackMemento:
     """
     This class is responsible for managing the simulation of the blockchain stack during the code generation
     """
 
@@ -34,14 +34,29 @@
         else:
             return stacks[index]
 
     @property
     def current_stack(self) -> NeoStack:
         return self._current_stack
 
+    def restore_state(self, code_address):
+        stacks = self.stack_map
+        latest_stack = None
+        for address, stack in reversed(sorted(stacks.items())):
+            if address < code_address:
+                latest_stack = stack
+                break
+
+            vm_code = VMCodeMapping.instance().get_code(address)
+            if (vm_code, stack) in self._stacks:
+                self._stacks.remove((vm_code, stack))
+
+        if latest_stack is not None:
+            self._current_stack = latest_stack
+
     def append(self, value: IType, code: VMCode):
         states = self.stack_map
         index = VMCodeMapping.instance().get_start_address(code)
         if index in states:
             states[index].append(value)
 
         else:
@@ -50,14 +65,31 @@
             else:
                 stack = NeoStack()
             stack.append(value)
 
             self._stacks.append((code, stack))
             self._current_stack = stack
 
+    def pop(self, code: VMCode, index: int = -1):
+        states = self.stack_map
+        stack_index = VMCodeMapping.instance().get_start_address(code)
+        if stack_index in states:
+            stack = states[stack_index]
+        else:
+            if self._current_stack is not None:
+                stack = self._current_stack.copy()
+            else:
+                stack = NeoStack()
+
+            self._stacks.append((code, stack))
+            self._current_stack = stack
+
+        if len(stack) > 0:
+            return stack.pop(index)
+
 
 class NeoStack:
     def __init__(self):
         self._stack: List[IType] = []
 
     def append(self, value: IType):
         return self._stack.append(value)
```

### Comparing `neo3-boa-0.9.0/boa3/compiler/codegenerator/vmcodemapping.py` & `neo3-boa-1.0.0/boa3/internal/compiler/codegenerator/vmcodemapping.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,13 +1,19 @@
 from __future__ import annotations
 
 from typing import Dict, List, Optional, Union
 
-from boa3.neo.vm.VMCode import VMCode
-from boa3.neo.vm.opcode.OpcodeInformation import OpcodeInformation
+from boa3.internal.compiler.codegenerator.methodtokencollection import MethodTokenCollection
+from boa3.internal.compiler.codegenerator.vmcodemap import VMCodeMap
+from boa3.internal.compiler.compileroutput import CompilerOutput
+from boa3.internal.model.builtin.method import IBuiltinMethod
+from boa3.internal.neo.vm.VMCode import VMCode
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.OpcodeInformation import OpcodeInformation
+from boa3.internal.neo3.contracts.contracttypes import CallFlags
 
 
 class VMCodeMapping:
     """
     This class is responsible for managing the Neo VM instruction during the bytecode generation.
     """
     _instance: VMCodeMapping = None
@@ -18,51 +24,63 @@
         :return: the singleton instance
         """
         if cls._instance is None:
             cls._instance = cls()
         return cls._instance
 
     def __init__(self):
-        self._codes: Dict[int, VMCode] = {}
+        self._code_map: VMCodeMap = VMCodeMap()
+        self._method_tokens: MethodTokenCollection = MethodTokenCollection()
 
     @classmethod
     def reset(cls):
         """
         Resets the map to the first state
         """
         if cls._instance is not None:
-            cls._instance._codes.clear()
+            cls._instance._code_map.clear()
+            cls._instance._method_tokens.clear()
+
+    def add_method_token(self, method: IBuiltinMethod, call_flag: CallFlags) -> Optional[int]:
+        """
+        Creates a new method token if the method call another contract and return its id.
+        Otherwise, returns None
+        """
+        if hasattr(method, 'contract_script_hash'):
+            return self._method_tokens.append(method, call_flag)
+        return None
 
     @property
     def codes(self) -> List[VMCode]:
         """
         Gets a list with the included vm codes
 
         :return: a list of vm codes ordered by its address in the bytecode
         """
-        return list(self.code_map.values())
+        return self._code_map.get_code_list()
 
     @property
     def code_map(self) -> Dict[int, VMCode]:
         """
         Gets a dictionary that maps each vm code with its address.
 
         :return: a dictionary that maps each instruction with its address. The keys are ordered by the address.
         """
-        return {key: self._codes[key] for key in sorted(self._codes)}
+        return self._code_map.get_code_map()
 
     def targeted_address(self) -> Dict[int, List[int]]:
         """
         Gets a dictionary that maps each address to the opcodes that targets it
 
         :return: a dictionary that maps the targeted instructions to its source.
         """
         target_maps = {}
-        for address, code in self.code_map.items():
-            if code.opcode.has_target() and code.target is not None and code.target is not code:
+        for code in self._code_map.get_code_with_target_list():
+            if code.target is not None and code.target is not code:
+                address = self.get_start_address(code)
                 target = self.get_start_address(code.target)
                 if target not in target_maps:
                     target_maps[target] = [address]
                 else:
                     target_maps[target].append(address)
         return target_maps
 
@@ -78,77 +96,61 @@
         bytecode = bytearray()
         for code in self.codes:
             bytecode += code.opcode
             if code.data is not None:
                 bytecode += code.data
         return bytes(bytecode)
 
+    def result(self) -> CompilerOutput:
+        """
+        Gets the complete output of the translated code
+        """
+        bytecode = self.bytecode()
+        return CompilerOutput(bytecode, self._method_tokens.to_list())
+
     @property
     def bytecode_size(self) -> int:
-        if len(self._codes) < 1:
-            return 0
-
-        last_key = list(self.code_map)[-1]
-        return last_key + self._codes[last_key].size
+        return self._code_map.get_bytecode_size()
 
     def insert_code(self, vm_code: VMCode):
-        if vm_code not in self._codes.values():
-            self._codes[self.bytecode_size] = vm_code
+        return self._code_map.insert_code(vm_code, has_target=OpcodeHelper.has_target(vm_code.opcode))
 
     def get_code(self, address: int) -> Optional[VMCode]:
         """
         Gets the VM Opcode at the given position
 
         :param address: the position of the opcode
         :return: the opcode if it exists. None otherwise
         :rtype: VMCode or None
         """
-        if address in self._codes:
-            return self._codes[address]
-        elif address >= self.bytecode_size:
-            # the address is not in the bytecode
-            return None
-        else:
-            # if the address is not the start of a instruction, gets the last instruction before given address
-            code_address = 0
-            for addr in self._codes:
-                if addr > address:
-                    break
-                code_address = addr
-            return self._codes[code_address]
+        return self._code_map.get_code(address)
+
+    def get_addresses(self, start_address: int, end_address: int) -> List[int]:
+        return self._code_map.get_addresses(start_address, end_address)
 
     def get_start_address(self, vm_code: VMCode) -> int:
         """
         Gets the vm code's first byte address
 
         :param vm_code: the instruction to get the address
         :return: the vm code's address if it's in the map. Otherwise, return's zero.
         """
-        if vm_code not in self._codes.values():
-            return 0
-        return next(key for key, value in self._codes.items() if value == vm_code)
+        return self._code_map.get_start_address(vm_code)
 
     def get_end_address(self, vm_code: VMCode) -> int:
         """
         Gets the vm code's last byte address
 
         :param vm_code: the instruction to get the address
         :return: the vm code's last address if it's in the map. Otherwise, return's zero.
         """
-        if vm_code not in self._codes.values():
-            return 0
-        return self.get_start_address(vm_code) + vm_code.size - 1  # start + size returns next opcode address
+        return self._code_map.get_end_address(vm_code)
 
     def get_opcodes(self, addresses: List[int]) -> List[VMCode]:
-        codes = []
-        for index in sorted(addresses):
-            if index in self._codes:
-                codes.append(self._codes[index])
-
-        return codes
+        return self._code_map.get_opcodes(addresses)
 
     def update_vm_code(self, vm_code: VMCode, opcode: OpcodeInformation, data: bytes = bytes()):
         """
         Updates the information from an inserted code
 
         :param vm_code: code to be updated
         :param opcode: updated opcode information
@@ -162,67 +164,54 @@
 
     def _update_addresses(self, start_address: int = 0):
         """
         Updates the instruction map's keys when a opcode is changed
 
         :param start_address: the address from the changed opcode
         """
-        new_address = -1
-        last_code: VMCode = None
-        updated_codes: Dict[int, VMCode] = {}
-
-        for address, code in list(self.code_map.items()):
-            if address >= start_address:
-                if new_address < 0:
-                    new_address = self.get_start_address(last_code) if last_code is not None else 0
-
-                new_address += last_code.size if last_code is not None else 0
-                if new_address != address:
-                    updated_codes[new_address] = self._codes.pop(address)
-            last_code = code
-        self._codes.update(updated_codes)
+        return self._code_map.update_addresses(start_address)
 
     def _update_targets(self):
-        from boa3.neo.vm.type.Integer import Integer
-        for address, code in self.code_map.items():
-            if code.opcode.has_target() and code.target is None:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        for code in self._code_map.get_code_with_target_list():
+            if code.target is None:
                 relative = Integer.from_bytes(code.data)
-                absolute = address + relative
+                absolute = self._code_map.get_start_address(code) + relative
                 if absolute in self.code_map:
                     code.set_target(self.code_map[absolute])
 
     def _update_larger_codes(self):
         """
         Checks if each instruction data fits in its opcode maximum size and updates the opcode from those that don't
         """
         # gets a list with all instructions which its opcode has a larger equivalent, ordered by its address
-        instr_with_small_codes = [code for code in self._codes.values() if code.opcode.has_larger_opcode()]
+        instr_with_small_codes = [code for code in self._code_map.get_code_list() if OpcodeHelper.has_larger_opcode(code.opcode)]
         instr_with_small_codes.sort(key=lambda code: self.get_start_address(code), reverse=True)
 
-        from boa3.neo.vm.opcode.OpcodeInfo import OpcodeInfo
+        from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo
         # total_len is initialized with zero because the loop must run at least once
         total_len = 0
         current_size = self.bytecode_size
 
         # if any instruction is updated, the following instruction addresses and the total size will change as well
         # with the change, previous instruction data may have overflowed the opcode maximum value
         # to make sure, it must check the opcodes that haven't changed again
         while total_len != current_size:
             total_len = current_size
 
             # verifies each instruction data length
             for code in instr_with_small_codes.copy():  # it's a copy because the list may change during the iteration
                 if len(code.raw_data) > code.info.max_data_len:
                     # gets the shortest opcode equivalent that fits the instruction data
-                    info = OpcodeInfo.get_info(code.opcode.get_larger_opcode())
-                    while len(code.raw_data) > info.max_data_len and info.opcode.has_larger_opcode():
-                        info = OpcodeInfo.get_info(code.opcode.get_larger_opcode())
+                    info = OpcodeInfo.get_info(OpcodeHelper.get_larger_opcode(code.opcode))
+                    while len(code.raw_data) > info.max_data_len and OpcodeHelper.has_larger_opcode(info.opcode):
+                        info = OpcodeInfo.get_info(OpcodeHelper.get_larger_opcode(code.opcode))
 
                     self.update_vm_code(code, info)
-                    if info.opcode == info.opcode.get_larger_opcode():
+                    if info.opcode == OpcodeHelper.get_larger_opcode(info.opcode):
                         # if it's the largest equivalent, it won't be updated anymore
                         instr_with_small_codes.remove(code)
             current_size = self.bytecode_size
 
     def _validate_targets(self, code_or_address: Union[int, VMCode]):
         if isinstance(code_or_address, int):
             address = code_or_address
@@ -232,76 +221,52 @@
             address = self.get_start_address(code)
 
         targeted_addresses = self.targeted_address()
 
         if address in targeted_addresses:
             next_address = self.get_end_address(code) + 1
             if next_address < self.bytecode_size:
-                next_code = self._codes[next_address]
+                next_code = self._code_map.get_code(next_address)
                 for source in targeted_addresses[address]:
-                    self._codes[source].set_target(next_code)
+                    self._code_map.get_code(source).set_target(next_code)
 
-    def move_to_end(self, first_code_address: int, last_code_address: int):
+    def move_to_end(self, first_code_address: int, last_code_address: int) -> int:
         """
         Moves a set of instructions to the end of the current bytecode
 
         :param first_code_address: first instruction start address
         :param last_code_address: last instruction end address
         """
-        if last_code_address < first_code_address:
-            return
-
-        moved_codes: List[VMCode] = []
-        for address in list(self.code_map):
-            if first_code_address <= address <= last_code_address:
-                moved_codes.append(self._codes.pop(address))
-            elif address > last_code_address:
-                break
-
-        self._update_addresses(first_code_address)
+        result = self._code_map.move_to_end(first_code_address, last_code_address)
+        if not isinstance(result, int):
+            return self.bytecode_size
 
-        for code in moved_codes:
-            self.insert_code(code)
         self._update_targets()
+        return result
 
-    def remove_opcodes(self, first_code_address: int, last_code_address: int):
-        if last_code_address < first_code_address:
-            first_code_address, last_code_address = last_code_address, first_code_address
-
-        map_codes = self._codes.copy()
-        for index in sorted(map_codes):
-            if first_code_address <= index <= last_code_address:
-                self._validate_targets(index)
-                self._codes.pop(index)
-
-        self._update_addresses()
-
-    def remove_opcodes_by_addresses(self, addresses: List[int]):
-        for index in sorted(self._codes).copy():
-            if index in addresses:
-                self._validate_targets(index)
-                self._codes.pop(index)
-
-        self._update_addresses()
+    def remove_opcodes(self, first_code_address: int, last_code_address: int = None):
+        if not isinstance(last_code_address, int):
+            last_code_address = self.bytecode_size
+        addresses_to_remove = self._code_map.get_addresses(first_code_address, last_code_address)
+        for address in addresses_to_remove:
+            self._validate_targets(address)
+        return self._code_map.remove_opcodes_by_addresses(addresses_to_remove)
 
     def remove_opcodes_by_code(self, codes: List[VMCode]):
-        code_map = self.code_map
-        addresses = list(code_map.keys()).copy()
-        code_list = list(code_map.values()).copy()
-
-        for code in codes:
-            if code in code_list:
-                self._validate_targets(code)
-                self._codes.pop(addresses[code_list.index(code)])
-
-        self._update_addresses()
+        addresses_to_remove = self._code_map.get_addresses_from_codes(codes)
+        for address in addresses_to_remove:
+            self._validate_targets(address)
+        return self._code_map.remove_opcodes_by_addresses(addresses_to_remove)
 
     def _remove_empty_targets(self):
         """
         Checks if each instruction that requires a target has one set and remove those that don't
         """
-        for code in list(self._codes.values()).copy():
-            if code.opcode.has_target() and (code.target is None or code.target is code):
-                self._validate_targets(code)
-                index = self.get_start_address(code)
-                self._codes.pop(index)
-                self._update_addresses(index)
+        addresses_to_remove = []
+        for code in self._code_map.get_code_with_target_list():
+            if code.target is None or code.target is code:
+                address = self.get_start_address(code)
+                self._validate_targets(address)
+                addresses_to_remove.append(address)
+
+        if len(addresses_to_remove) > 0:
+            self._code_map.remove_opcodes_by_addresses(addresses_to_remove)
```

### Comparing `neo3-boa-0.9.0/boa3/exception/CompilerError.py` & `neo3-boa-1.0.0/boa3/internal/exception/CompilerError.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,27 +1,31 @@
 from abc import ABC
 from typing import Iterable, Optional, Union
 
-from boa3.model.builtin.internal.internalmethod import IInternalMethod
-from boa3.model.event import Event
-from boa3.model.method import Method
+from boa3.internal import constants
+from boa3.internal.model.builtin.internal.internalmethod import IInternalMethod
+from boa3.internal.model.event import Event
+from boa3.internal.model.method import Method
 
 
 class CompilerError(ABC, BaseException):
     """
     An interface for compilation errors
     """
 
     def __init__(self, line: int, col: int):
         self.line: int = line
         self.col: int = col
+        self.filepath: Optional[str] = None
 
     @property
     def message(self) -> str:
         message = '' if self._error_message is None else ' - ' + self._error_message
+        if isinstance(self.filepath, str):
+            message += f'\t <{self.filepath}>'
         return '{0}:{1}{2}'.format(self.line, self.col, message)
 
     @property
     def _error_message(self) -> Optional[str]:
         return None
 
     def __str__(self) -> str:
@@ -37,22 +41,51 @@
     """
     An error raised when circular imports are detected
     """
 
     def __init__(self, line: int, col: int, target_import: str, target_origin: str):
         import os
         self.target_import = target_import
-        self.target_origin = target_origin.replace(os.sep, '/')
+        self.target_origin = target_origin.replace(os.sep, constants.PATH_SEPARATOR)
         super().__init__(line, col)
 
     @property
     def _error_message(self) -> Optional[str]:
         return "Circular import with '%s' ('%s')" % (self.target_import, self.target_origin)
 
 
+class DuplicatedIdentifier(CompilerError):
+    """
+    An error raised when more than one symbol uses the same identifier in the same scope and cannot be overwritten.
+    """
+
+    def __init__(self, line: int, col: int, duplicated_id: str = None):
+        self._duplicated_id = duplicated_id
+        super().__init__(line, col)
+
+    @property
+    def _error_message(self) -> Optional[str]:
+        return f"Duplicate identifier: '{self._duplicated_id}'"
+
+
+class DuplicatedManifestIdentifier(CompilerError):
+    """
+    An error raised when more than one symbol uses the same identifier in the manifest.
+    """
+
+    def __init__(self, line: int, col: int, duplicated_id: str = None, duplicated_arg_count: int = None):
+        self._duplicated_id = duplicated_id
+        self._arg_count = duplicated_arg_count
+        super().__init__(line, col)
+
+    @property
+    def _error_message(self) -> Optional[str]:
+        return f"Duplicate manifest identifier: '{self._duplicated_id}' with {self._arg_count} argument(s)"
+
+
 class IncorrectNumberOfOperands(CompilerError):
     """
     An error raised when an operation is used with the wrong number of operands
     """
 
     def __init__(self, line: int, col: int, expected_count: int, actual_count: int):
         self.expected = expected_count
@@ -60,14 +93,31 @@
         super().__init__(line, col)
 
     @property
     def _error_message(self) -> Optional[str]:
         return "Incorrect number of operands: expected '%s', got '%s' instead" % (self.expected, self.actual)
 
 
+class InvalidUsage(CompilerError):
+    """
+    An error raised when a built-in function or decorator is incorrectly defined
+    """
+
+    def __init__(self, line: int, col: int, custom_error_message: str = None):
+        self.custom_error_message = custom_error_message
+        super().__init__(line, col)
+
+    @property
+    def _error_message(self) -> Optional[str]:
+        message = "Invalid usage"
+        if self.custom_error_message is not None:
+            message += f": {self.custom_error_message}"
+        return message
+
+
 class InvalidType(CompilerError):
     """
     An error raised when a type that is not supported by Neo VM is used
     """
 
     def __init__(self, line: int, col: int, symbol_id: str = None):
         self.symbol_id = symbol_id
@@ -129,18 +179,18 @@
         return "'{0}' requires '{1}' implementation".format(self.metadata_attr_id, self.symbol_id)
 
 
 class MetadataIncorrectImplementation(CompilerError):
     """
     An error raised when a metadata required function is incorrectly implemented
     """
-    from boa3.model.symbol import ISymbol
+    from boa3.internal.model.symbol import ISymbol
 
     def __init__(self, line: int, col: int, symbol_id: str, expected_symbol: ISymbol, actual_symbol: ISymbol):
-        from boa3.model.symbol import ISymbol
+        from boa3.internal.model.symbol import ISymbol
 
         self.symbol_id: str = symbol_id
         self.expected_symbol: ISymbol = expected_symbol
         self.actual_symbol: ISymbol = actual_symbol
         super().__init__(line, col)
 
     @property
@@ -184,14 +234,27 @@
     @property
     def _error_message(self) -> Optional[str]:
         expected_types = join_args(self.expected_types)
         actual_types = join_args(self.actual_types)
         return "Expected type '%s', got '%s' instead" % (expected_types, actual_types)
 
 
+class MissingInitCall(CompilerError):
+    """
+    An error raised when a custom class is created with inheritance and it's missing the base __init__ call
+    """
+
+    def __init__(self, line: int, col: int):
+        super().__init__(line, col)
+
+    @property
+    def _error_message(self) -> Optional[str]:
+        return "Call to __init__ of super class is missed"
+
+
 class MissingReturnStatement(CompilerError):
     """
     An error raised when a function with a return value is missing a return statement
     """
 
     def __init__(self, line: int, col: int, symbol_id: str):
         self.symbol_id = symbol_id
@@ -211,18 +274,17 @@
         self.standard = standard_id
         self.symbol_id = symbol_id
         self.symbol = symbol
         super().__init__(0, 0)
 
     @property
     def _error_message(self) -> Optional[str]:
-        return "'{0}': Missing '{1}' {2} definition '{3}'".format(self.standard,
-                                                                  self.symbol_id,
-                                                                  self.symbol.shadowing_name,
-                                                                  self.symbol)
+        safe_symbol_prefix = 'safe ' if self.symbol.is_safe else ''
+        return f"'{self.standard}': Missing '{self.symbol_id}' {self.symbol.shadowing_name} definition " \
+               f"'{safe_symbol_prefix}{self.symbol}'"
 
     @property
     def message(self) -> str:
         return self._error_message
 
 
 class NotSupportedOperation(CompilerError):
@@ -325,9 +387,22 @@
 
     @property
     def _error_message(self) -> Optional[str]:
         if self.symbol_id is not None:
             return "Type hint is missing for the symbol '%s'" % self.symbol_id
 
 
+class SelfArgumentError(CompilerError):
+    """
+    An error raised when the self argument is wrong
+    """
+
+    def __init__(self, line: int, col: int):
+        super().__init__(line, col)
+
+    @property
+    def _error_message(self) -> Optional[str]:
+        return "The self argument was not found or the annotation is incorrect"
+
+
 def join_args(iterable: Iterable[str]) -> str:
     return str.join("', '", iterable)
```

### Comparing `neo3-boa-0.9.0/boa3/exception/CompilerWarning.py` & `neo3-boa-1.0.0/boa3/internal/exception/CompilerWarning.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,18 +2,21 @@
 from typing import Iterable, Optional, Union
 
 
 class CompilerWarning(ABC, BaseException):
     def __init__(self, line: int, col: int):
         self.line: int = line
         self.col: int = col
+        self.filepath: Optional[str] = None
 
     @property
     def message(self) -> str:
         message = '' if self._warning_message is None else ' - ' + self._warning_message
+        if isinstance(self.filepath, str):
+            message += f'\t <{self.filepath}>'
         return '{0}:{1}{2}'.format(self.line, self.col, message)
 
     @property
     def _warning_message(self) -> Optional[str]:
         return None
 
     def __str__(self) -> str:
@@ -21,19 +24,36 @@
 
     def __eq__(self, other) -> bool:
         if not isinstance(other, type(self)):
             return False
         return self.message == other.message
 
 
+class InvalidArgument(CompilerWarning):
+    """
+    An warning raised when an attempt of method evaluation fails during optimization because an argument is invalid.
+    """
+
+    def __init__(self, line: int, col: int, custom_error_message: str = None):
+        self.custom_error_message = custom_error_message
+        super().__init__(line, col)
+
+    @property
+    def _warning_message(self) -> Optional[str]:
+        message = "One or more arguments are invalid values"
+        if self.custom_error_message is not None:
+            message += f": {self.custom_error_message}"
+        return message
+
+
 class NameShadowing(CompilerWarning):
     """
     A warning raised when a name from an outer scope symbol is used as the name of an inner scope symbol
     """
-    from boa3.model.symbol import ISymbol
+    from boa3.internal.model.symbol import ISymbol
 
     def __init__(self, line: int, col: int, outer_symbol: ISymbol, symbol_id: str):
         self.symbol_id: str = symbol_id
         self.existing_symbol = outer_symbol
         super().__init__(line, col)
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/builtin.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/builtin.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,31 +1,38 @@
 from enum import Enum
 from typing import Dict, List, Optional, Tuple, Union
 
-from boa3.model.builtin.builtincallable import IBuiltinCallable
-from boa3.model.builtin.classmethod import *
-from boa3.model.builtin.contract import *
-from boa3.model.builtin.decorator.metadatadecorator import MetadataDecorator
-from boa3.model.builtin.decorator.publicdecorator import PublicDecorator
-from boa3.model.builtin.internal.innerdeploymethod import InnerDeployMethod
-from boa3.model.builtin.interop.interop import Interop
-from boa3.model.builtin.method import *
-from boa3.model.builtin.neometadatatype import MetadataTypeSingleton as NeoMetadataType
-from boa3.model.callable import Callable
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.collection.sequence.ecpointtype import ECPointType
-from boa3.model.type.collection.sequence.uint160type import UInt160Type
-from boa3.model.type.collection.sequence.uint256type import UInt256Type
-from boa3.model.type.itype import IType
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.builtin.classmethod import *
+from boa3.internal.model.builtin.compile_time import *
+from boa3.internal.model.builtin.contract import *
+from boa3.internal.model.builtin.decorator import *
+from boa3.internal.model.builtin.internal import *
+from boa3.internal.model.builtin.interop.interop import Interop
+from boa3.internal.model.builtin.math import *
+from boa3.internal.model.builtin.method import *
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.event import Event as EventSymbol
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.imports.package import Package
+from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.math import Math
+from boa3.internal.model.type.neo import *
 
 
 class BoaPackage(str, Enum):
+    CompileTime = 'compile_time'
     Contract = 'contract'
     Interop = 'interop'
     Type = 'type'
+    TypeHelper = 'helper'
+    VM = 'vm'
 
 
 class Builtin:
     @classmethod
     def get_symbol(cls, symbol_id: str) -> Optional[Callable]:
         for method in cls._python_builtins:
             if isinstance(method, IBuiltinCallable) and method.identifier == symbol_id:
@@ -41,111 +48,180 @@
 
     # builtin method
     Abs = AbsMethod()
     Exit = ExitMethod()
     IsInstance = IsInstanceMethod()
     Len = LenMethod()
     NewEvent = CreateEventMethod()
-    Max = MaxMethod()
-    Min = MinMethod()
+    Max = MaxIntMethod()
+    Min = MinIntMethod()
     Print = PrintMethod()
-    ScriptHash = ScriptHashMethod()
-    Sqrt = SqrtMethod()
+    ScriptHashMethod_ = ScriptHashMethod()
     StrSplit = StrSplitMethod()
     Sum = SumMethod()
 
     # python builtin class constructor
+    Bool = BoolMethod()
     ByteArray = ByteArrayMethod()
+    ByteArrayEncoding = ByteArrayEncodingMethod()
+    Exception = ExceptionMethod()
+    IntByteString = IntByteStringMethod()
+    IntInt = IntIntMethod()
+    ListBytesString = ListBytesStringMethod()
+    ListGeneric = ListGenericMethod()
+    ListMapping = ListMappingMethod()
+    ListSequence = ListSequenceMethod()
     Range = RangeMethod()
     Reversed = ReversedMethod()
-    Exception = ExceptionMethod()
+    StrBool = StrBoolMethod()
+    StrBytes = StrBytesMethod()
+    StrInt = StrIntMethod()
+    Super = SuperMethod()
 
     # python class method
-    CountSequence = CountSequenceMethod()
+    BytesStringIndex = IndexBytesStringMethod()
+    BytesStringIsDigit = IsDigitMethod()
+    BytesStringJoin = JoinMethod()
+    BytesStringLower = LowerMethod()
+    BytesStringStartswith = StartsWithMethod()
+    BytesStringStrip = StripMethod()
+    BytesStringUpper = UpperMethod()
+    CountSequenceGeneric = CountSequenceGenericMethod()
+    CountSequencePrimitive = CountSequencePrimitiveMethod()
     CountStr = CountStrMethod()
+    Copy = CopyListMethod()
     SequenceAppend = AppendMethod()
     SequenceClear = ClearMethod()
     SequenceExtend = ExtendMethod()
+    SequenceIndex = IndexSequenceMethod()
     SequenceInsert = InsertMethod()
-    SequencePop = PopMethod()
+    SequencePop = PopSequenceMethod()
     SequenceRemove = RemoveMethod()
     SequenceReverse = ReverseMethod()
     DictKeys = MapKeysMethod()
+    DictPop = PopDictMethod()
+    DictPopDefault = PopDictDefaultMethod()
     DictValues = MapValuesMethod()
 
     # custom class methods
     ConvertToBytes = ToBytesMethod
     ConvertToInt = ToIntMethod
     ConvertToStr = ToStrMethod
     ConvertToBool = ToBoolMethod
 
+    # builtin decorator
+    ClassMethodDecorator = ClassMethodDecorator()
+    InstanceMethodDecorator = InstanceMethodDecorator()
+    PropertyDecorator = PropertyDecorator()
+    StaticMethodDecorator = StaticMethodDecorator()
+
     _python_builtins: List[IdentifiedSymbol] = [Abs,
                                                 ByteArray,
+                                                ByteArrayEncoding,
+                                                BytesStringIndex,
+                                                BytesStringIsDigit,
+                                                BytesStringJoin,
+                                                BytesStringLower,
+                                                BytesStringStartswith,
+                                                BytesStringStrip,
+                                                BytesStringUpper,
+                                                ClassMethodDecorator,
                                                 ConvertToBool,
                                                 ConvertToBytes,
                                                 ConvertToInt,
                                                 ConvertToStr,
-                                                CountSequence,
+                                                Copy,
+                                                CountSequenceGeneric,
+                                                CountSequencePrimitive,
                                                 CountStr,
                                                 DictKeys,
                                                 DictValues,
                                                 Exception,
                                                 Exit,
                                                 IsInstance,
                                                 Len,
                                                 Max,
                                                 Min,
                                                 Print,
+                                                PropertyDecorator,
                                                 Range,
                                                 Reversed,
-                                                ScriptHash,
+                                                ScriptHashMethod_,
                                                 SequenceAppend,
                                                 SequenceClear,
                                                 SequenceExtend,
+                                                SequenceIndex,
                                                 SequenceInsert,
                                                 SequencePop,
                                                 SequenceRemove,
                                                 SequenceReverse,
-                                                Sqrt,
+                                                StaticMethodDecorator,
                                                 StrSplit,
-                                                Sum
+                                                Sum,
+                                                Super,
                                                 ]
 
     @classmethod
     def interop_symbols(cls, package: str = None) -> Dict[str, IdentifiedSymbol]:
         return {symbol.raw_identifier if hasattr(symbol, 'raw_identifier') else symbol.identifier: symbol
                 for symbol in Interop.interop_symbols(package)}
 
-    # builtin decorator
+    # boa builtin decorator
+    ContractInterface = ContractDecorator()
+    ContractMethodDisplayName = DisplayNameDecorator()
     Metadata = MetadataDecorator()
     Public = PublicDecorator()
 
     # boa builtin type
     Event = EventType
     UInt160 = UInt160Type.build()
     UInt256 = UInt256Type.build()
     ECPoint = ECPointType.build()
+    NeoAccountState = NeoAccountStateType.build()
+    Opcode = OpcodeType.build()
+    Address = AddressType.build()
+    BlockHash = BlockHashType.build()
+    PublicKey = PublicKeyType.build()
+    ScriptHashType_ = ScriptHashType.build()
+    ScriptHashLittleEndian = ScriptHashLittleEndianType.build()
+    TransactionId = TransactionIdType.build()
 
     # boa events
     Nep5Transfer = Nep5TransferEvent()
+    Nep11Transfer = Nep11TransferEvent()
     Nep17Transfer = Nep17TransferEvent()
 
     # boa smart contract methods
     Abort = AbortMethod()
+    Env = EnvProperty.build()
+
+    # region boa builtin modules
+
+    BuiltinMathCeil = DecimalCeilingMethod()
+    BuiltinMathFloor = DecimalFloorMethod()
+
+    MathModule = Package(identifier='math',
+                         methods=[Math.Sqrt,
+                                  BuiltinMathCeil,
+                                  BuiltinMathFloor])
 
-    boa_builtins: List[IdentifiedSymbol] = [Public,
-                                            NewEvent,
-                                            Event,
-                                            Metadata,
-                                            NeoMetadataType,
-                                            ScriptHash
-                                            ]
+    _symbols = [Env]
+    _modules = [MathModule]
+
+    # endregion
+
+    boa_builtins: List[IdentifiedSymbol] = []
+    boa_builtins.extend(_modules)
+    boa_builtins.extend(_symbols)
 
     metadata_fields: Dict[str, Union[type, Tuple[type]]] = {
+        'name': str,
+        'source': (str, type(None)),
         'supported_standards': list,
+        'trusts': list,
         'author': (str, type(None)),
         'email': (str, type(None)),
         'description': (str, type(None)),
         'extras': dict
     }
 
     @classmethod
@@ -155,22 +231,59 @@
     @classmethod
     def package_symbols(cls, package: str = None) -> Dict[str, IdentifiedSymbol]:
         if package in BoaPackage.__members__.values():
             return {symbol.identifier: symbol for symbol in cls._boa_symbols[package]}
 
         return cls.boa_symbols()
 
+    @classmethod
+    def builtin_events(cls) -> List[EventSymbol]:
+        lst: List[EventSymbol] = [event for event in cls.boa_builtins if isinstance(event, EventSymbol)]
+
+        for symbols in cls._boa_symbols.values():
+            lst.extend([event for event in symbols if isinstance(event, EventSymbol)])
+
+        return lst
+
+    _builtin_type_package_symbols = [ECPoint,
+                                     UInt160,
+                                     UInt256,
+                                     Event,
+                                     Address,
+                                     BlockHash,
+                                     PublicKey,
+                                     ScriptHashType_,
+                                     ScriptHashLittleEndian,
+                                     TransactionId,
+                                     Package(identifier=BoaPackage.TypeHelper,
+                                             methods=[ConvertToBool,
+                                                      ConvertToBytes,
+                                                      ConvertToInt,
+                                                      ConvertToStr,
+                                                      ]
+                                             )
+                                     ]
+
     _boa_symbols: Dict[BoaPackage, List[IdentifiedSymbol]] = {
         BoaPackage.Contract: [Abort,
+                              NeoAccountState,
+                              Nep11Transfer,
                               Nep17Transfer,
                               Nep5Transfer,
+                              ScriptHashMethod_
                               ],
         BoaPackage.Interop: Interop.package_symbols,
-        BoaPackage.Type: [ECPoint,
-                          UInt160,
-                          UInt256
-                          ]
+        BoaPackage.Type: _builtin_type_package_symbols,
+        BoaPackage.VM: [Opcode
+                        ],
+        BoaPackage.CompileTime: [ContractInterface,
+                                 ContractMethodDisplayName,
+                                 Metadata,
+                                 NeoMetadataType,
+                                 Public,
+                                 NewEvent
+                                 ]
     }
 
     _internal_methods = [InnerDeployMethod.instance()
                          ]
     internal_methods = {method.raw_identifier: method for method in _internal_methods}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/builtincallable.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/builtincallable.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,31 +1,45 @@
 import ast
 from abc import ABC
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.callable import Callable
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.builtinsymbol import IBuiltinSymbol
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class IBuiltinCallable(Callable, IdentifiedSymbol, ABC):
+class IBuiltinCallable(Callable, IBuiltinSymbol, ABC):
     def __init__(self, identifier: str, args: Dict[str, Variable] = None,
                  vararg: Optional[Tuple[str, Variable]] = None,
+                 kwargs: Optional[Dict[str, Variable]] = None,
                  defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(args, vararg, defaults, return_type)
+        super().__init__(args, vararg, kwargs, defaults, return_type)
         self._identifier = identifier
+        self._generated_opcode = None
         self.defined_by_entry = False  # every builtin symbol must have this variable set as False
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
         """
         Gets the opcode for the method.
 
         :return: the opcode and its data if exists. None otherwise.
         """
+        # don't need to recalculate for every time this property is called
+        if self._generated_opcode is None:
+            self._generated_opcode = self._opcode
+        return self._generated_opcode
+
+    def reset(self):
+        # reset the opcodes to ensure the correct output when calling consecutive compilations
+        self._generated_opcode = None
+        self.reset_calls()
+
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return []
 
     @property
     def identifier(self) -> str:
         return self._identifier
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/appendmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/appendmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, Dict, List, Optional, Sized, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class AppendMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             self_arg = Variable(Type.mutableSequence)
             item_arg = Variable(Type.any)
         else:
             self_arg = Variable(sequence_type)
             item_arg = Variable(sequence_type.value_type)
 
         identifier = 'append'
@@ -31,26 +31,26 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 2:
             return False
         if not all(isinstance(param, IExpression) for param in params):
             return False
 
-        from boa3.model.type.itype import IType
+        from boa3.internal.model.type.itype import IType
         sequence_type: IType = params[0].type
         value_type: IType = params[1].type
 
         if not isinstance(sequence_type, MutableSequenceType):
             return False
         return sequence_type.value_type.is_type_of(value_type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.neo.vm.type.Integer import Integer
         return [
             (Opcode.OVER, b''),
             (Opcode.ISTYPE, Type.bytearray.stack_item),     # append opcode only works for array
             (Opcode.JMPIFNOT, Integer(5).to_byte_array(min_length=1)),  # when it's bytearray, concatenates the value
             (Opcode.CAT, b''),
             (Opcode.JMP, Integer(5).to_byte_array(min_length=1)),
             (Opcode.APPEND, b'')
@@ -64,12 +64,14 @@
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
-        if type(value) == type(self.args['self'].type):
+        if isinstance(value, Sized) and len(value) > 0:
+            value = value[0]
+        if value == self.args['self'].type:
             return self
         if isinstance(value, MutableSequenceType):
             return AppendMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/clearmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/clearmethod.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ClearMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         identifier = 'clear'
         args: Dict[str, Variable] = {'self': Variable(sequence_type)}
         super().__init__(identifier, args)
 
     @property
@@ -27,17 +27,17 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
         return isinstance(params[0], IExpression) and isinstance(params[0].type, MutableSequenceType)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.neo.vm.type.Integer import Integer
         return [
             (Opcode.DUP, b''),
             (Opcode.ISTYPE, Type.bytearray.stack_item),     # append opcode only works for array
             (Opcode.JMPIFNOT, Integer(9).to_byte_array(min_length=1)),  # when it's bytearray, concatenates the value
             (Opcode.DROP, b''),
             (Opcode.PUSHDATA1, b'\x00'),
             (Opcode.CONVERT, Type.bytearray.stack_item),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/countmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/indexmethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,45 @@
 import ast
 from typing import Any, Dict, List, Optional
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
 
 
-class CountMethod(IBuiltinMethod):
+class IndexMethod(IBuiltinMethod):
 
     def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
-        from boa3.model.type.type import Type
-        identifier = 'count'
+        from boa3.internal.model.type.type import Type
+        identifier = 'index'
         super().__init__(identifier, args, defaults=defaults, return_type=Type.int)
 
     @property
     def identifier(self) -> str:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
 
-        if self._arg_self.type is Type.sequence:    # CountSequenceMethod default value for self
+        if self._arg_self.type is Type.sequence:  # IndexSequenceMethod default value for self
             return self._identifier
 
         if self._arg_self.type is Type.str:
             return '-{0}_{1}'.format(self._identifier, Type.str.identifier)
 
         if Type.sequence.is_type_of(self._arg_self.type):
             return '-{0}_{1}'.format(self._identifier, Type.sequence.identifier)
 
         return self._identifier
 
     @property
+    def is_supported(self) -> bool:
+        # TODO: change when index() with only one argument is implemented for range
+        from boa3.internal.model.type.type import Type
+        if Type.range.is_type_of(self._arg_self.type):
+            return False
+        return True
+
+    @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     @property
     def _arg_value(self) -> Variable:
         return self.args['value']
 
@@ -43,20 +51,20 @@
     def _body(self) -> Optional[str]:
         return
 
     def build(self, value: Any) -> IBuiltinMethod:
         if not isinstance(value, list):
             value = [value]
 
-        from boa3.model.type.collection.sequence.mutable.listtype import ListType
-        from boa3.model.type.collection.sequence.tupletype import TupleType
-        from boa3.model.type.collection.sequence.rangetype import RangeType
+        from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
+        from boa3.internal.model.type.collection.sequence.tupletype import TupleType
+        from boa3.internal.model.type.collection.sequence.rangetype import RangeType
         if len(value) > 1 and isinstance(value[0], (ListType, TupleType, RangeType)):
-            from boa3.model.builtin.classmethod.countsequencemethod import CountSequenceMethod
-            return CountSequenceMethod(value[0], value[1])
+            from boa3.internal.model.builtin.classmethod.indexsequencemethod import IndexSequenceMethod
+            return IndexSequenceMethod(value[0], value[1])
 
-        from boa3.model.type.type import Type
-        if len(value) > 0 and Type.str.is_type_of(value[0]):
-            from boa3.model.builtin.builtin import Builtin
-            return Builtin.CountStr
+        from boa3.internal.model.type.type import Type
+        if len(value) > 0 and (Type.str.is_type_of(value[0]) or Type.bytes.is_type_of(value[0])):
+            from boa3.internal.model.builtin.classmethod.indexbytesstringmethod import IndexBytesStringMethod
+            return IndexBytesStringMethod(value[0])
 
         return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/countsequencemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countsequencemethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,65 +1,57 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.classmethod.countmethod import CountMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.classmethod.countmethod import CountMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class CountSequenceMethod(CountMethod):
 
     def __init__(self, sequence_type: Optional[SequenceType] = None, arg_value: Optional[IType] = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if not isinstance(sequence_type, SequenceType):
             sequence_type = Type.sequence
         if not isinstance(arg_value, IType):
             arg_value = Type.any
 
         args: Dict[str, Variable] = {
             'self': Variable(sequence_type),
             'value': Variable(arg_value)
         }
 
-        super().__init__(args)
-
-    @property
-    def is_supported(self) -> bool:
-        value_type: IType = self._arg_value.type
+        self._generic_verification_opcodes = None
 
-        # TODO: change when 'sequence.count(list or tuple)' is supported
-        from boa3.model.type.collection.sequence.mutable.listtype import ListType
-        from boa3.model.type.collection.sequence.tupletype import TupleType
-        if isinstance(value_type, (ListType, TupleType)):
-            return False
-        return True
+        super().__init__(args)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 2:
             return False
         if not all(isinstance(param, IExpression) for param in params):
             return False
 
-        from boa3.model.type.itype import IType
+        from boa3.internal.model.type.itype import IType
         sequence_type: IType = params[0].type
 
         if not isinstance(sequence_type, SequenceType):
             return False
-        from boa3.model.type.collection.sequence.mutable.listtype import ListType
-        from boa3.model.type.collection.sequence.tupletype import TupleType
-        from boa3.model.type.collection.sequence.rangetype import RangeType
+        from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
+        from boa3.internal.model.type.collection.sequence.tupletype import TupleType
+        from boa3.internal.model.type.collection.sequence.rangetype import RangeType
         if not isinstance(sequence_type, (ListType, TupleType, RangeType)):
             return False
         return True
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.compiler.codegenerator import get_bytes_count
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.compiler.codegenerator import get_bytes_count
 
         jmp_place_holder = (Opcode.JMP, b'\x01')
 
         # region Sequence logic
 
         repack_array = [  # recreates an array to not change the original one
             (Opcode.UNPACK, b''),
@@ -97,30 +89,33 @@
         sequence_count_inc = [  # increment count if element == value
             (Opcode.SWAP, b''),
             (Opcode.INC, b''),  # count++
             (Opcode.SWAP, b''),
         ]
 
         num_jmp_code = get_bytes_count(sequence_count_inc)
-        jmp_to_dec_statement = Opcode.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
+        jmp_to_dec_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
         sequence_equals[-1] = jmp_to_dec_statement
 
         list_tuple_count_index_dec = [  # decreases the index
             (Opcode.DEC, b''),  # index--
             # return to the while verification
         ]
 
+        in_depth_verification = self.generic_verification(get_bytes_count(sequence_count_inc),
+                                                          get_bytes_count(sequence_get_element + sequence_equals))
+
         num_jmp_code = -get_bytes_count(list_tuple_count_index_dec + sequence_count_inc + sequence_equals +
-                                        sequence_get_element + sequence_verify_while)
-        jmp_back_to_while_verify_statement = Opcode.get_jump_and_data(Opcode.JMP, num_jmp_code)
+                                        sequence_get_element + sequence_verify_while + in_depth_verification)
+        jmp_back_to_while_verify_statement = OpcodeHelper.get_jump_and_data(Opcode.JMP, num_jmp_code)
         list_tuple_count_index_dec.append(jmp_back_to_while_verify_statement)
 
         num_jmp_code = get_bytes_count(sequence_get_element + sequence_equals +
-                                       sequence_count_inc + list_tuple_count_index_dec)
-        jmp_to_clean_statement = Opcode.get_jump_and_data(Opcode.JMPLT, num_jmp_code, True)
+                                       sequence_count_inc + list_tuple_count_index_dec + in_depth_verification)
+        jmp_to_clean_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPLT, num_jmp_code, True)
         sequence_verify_while[-1] = jmp_to_clean_statement
 
         sequence_clean_stack = [
             (Opcode.DROP, b''),
             (Opcode.REVERSE3, b''),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
@@ -128,13 +123,21 @@
 
         # endregion
 
         return (
             repack_array +
             sequence_initialize +
             sequence_verify_while +
+            in_depth_verification +
             sequence_get_element +
             sequence_equals +
             sequence_count_inc +
             list_tuple_count_index_dec +
             sequence_clean_stack
         )
+
+    def generic_verification(self, inc_statement_bytes=None,
+                             get_equals_statement_bytes=None) -> List[Tuple[Opcode, bytes]]:
+        if self._generic_verification_opcodes is None:
+            self._generic_verification_opcodes = []
+
+        return self._generic_verification_opcodes
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/countstrmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countstrmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,20 @@
 import ast
 from typing import Dict, List, Tuple
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.classmethod.countmethod import CountMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.builtin.classmethod.countmethod import CountMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class CountStrMethod(CountMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
 
         args: Dict[str, Variable] = {
             'self': Variable(Type.str),
             'value': Variable(Type.str),
             'start': Variable(Type.int),
             'end': Variable(Type.union.build([Type.int, Type.none])),
         }
@@ -22,17 +23,17 @@
                                                     ).body[0].value)
         end_default = set_internal_call(ast.parse("{0}".format(Type.none.default_value)
                                                   ).body[0].value)
 
         super().__init__(args, [start_default, end_default])
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.compiler.codegenerator import get_bytes_count
-        from boa3.model.type.type import Type
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.compiler.codegenerator import get_bytes_count
+        from boa3.internal.model.type.type import Type
 
         jmp_place_holder = (Opcode.JMP, b'\x01')
 
         # region verify end
 
         verify_end_null = [     # verifies if end is null
             (Opcode.REVERSE4, b''),
@@ -46,15 +47,15 @@
             (Opcode.PUSH2, b''),
             (Opcode.PICK, b''),
             (Opcode.SIZE, b''),
             jmp_place_holder    # skip the other end verifications
         ]
 
         num_jmp_code = get_bytes_count(end_null)
-        jmp_str_end_null_statement = Opcode.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
+        jmp_str_end_null_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
         verify_end_null[-1] = jmp_str_end_null_statement
 
         verify_end_neg = [      # verifies if end is < 0
             (Opcode.DUP, b''),
             (Opcode.PUSH0, b''),
             jmp_place_holder
         ]
@@ -71,23 +72,23 @@
 
         end_still_neg = [       # if end is still < 0 after adding it to len(self), end = 0
             (Opcode.DROP, b''),
             (Opcode.PUSH0, b''),
         ]
 
         num_jmp_code = get_bytes_count(end_still_neg)
-        jmp_end_still_neg_statement = Opcode.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
+        jmp_end_still_neg_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
         end_neg[-1] = jmp_end_still_neg_statement
 
         skip_end_gt_size = [
             jmp_place_holder    # skip the other end verification
         ]
 
         num_jmp_code = get_bytes_count(end_still_neg + end_neg + skip_end_gt_size)
-        jmp_end_neg_statement = Opcode.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
+        jmp_end_neg_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
         verify_end_neg[-1] = jmp_end_neg_statement
 
         verify_end_gt_size = [  # verifies if end >= len(self)
             (Opcode.DUP, b''),
             (Opcode.PUSH4, b''),
             (Opcode.PICK, b''),
             (Opcode.SIZE, b''),
@@ -98,25 +99,25 @@
             (Opcode.DROP, b''),
             (Opcode.PUSH2, b''),
             (Opcode.PICK, b''),
             (Opcode.SIZE, b''),
         ]
 
         num_jmp_code = get_bytes_count(end_gt_size)
-        jmp_end_gt_size_statement = Opcode.get_jump_and_data(Opcode.JMPLE, num_jmp_code, True)
+        jmp_end_gt_size_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPLE, num_jmp_code, True)
         verify_end_gt_size[-1] = jmp_end_gt_size_statement
 
         num_jmp_code = get_bytes_count(end_gt_size + verify_end_gt_size)
-        jmp_whole_end_gt_size_statement = Opcode.get_jump_and_data(Opcode.JMP, num_jmp_code, True)
+        jmp_whole_end_gt_size_statement = OpcodeHelper.get_jump_and_data(Opcode.JMP, num_jmp_code, True)
         skip_end_gt_size[-1] = jmp_whole_end_gt_size_statement
 
         num_jmp_code = get_bytes_count(
             end_gt_size + verify_end_gt_size + skip_end_gt_size + end_still_neg + end_neg + verify_end_neg
         )
-        jmp_whole_end_gt_size_statement = Opcode.get_jump_and_data(Opcode.JMP, num_jmp_code, True)
+        jmp_whole_end_gt_size_statement = OpcodeHelper.get_jump_and_data(Opcode.JMP, num_jmp_code, True)
         end_null[-1] = jmp_whole_end_gt_size_statement
 
         verify_end = (
             verify_end_null +
             end_null +
             verify_end_neg +
             end_neg +
@@ -149,23 +150,23 @@
 
         start_still_neg = [     # if start is still < 0 after adding it to len(self), start = 0
             (Opcode.DROP, b''),
             (Opcode.PUSH0, b''),
         ]
 
         num_jmp_code = get_bytes_count(start_still_neg)
-        jmp_str_start_still_neg_statement = Opcode.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
+        jmp_str_start_still_neg_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
         start_neg[-1] = jmp_str_start_still_neg_statement
 
         correct_start_position = [  # put start on the correct position
             (Opcode.SWAP, b'')
         ]
 
         num_jmp_code = get_bytes_count(correct_start_position + start_still_neg + start_neg)
-        jmp_str_start_neg_statement = Opcode.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
+        jmp_str_start_neg_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPGE, num_jmp_code, True)
         verify_start_neg[-1] = jmp_str_start_neg_statement
 
         verify_start = (
             verify_start_neg +
             start_neg +
             start_still_neg +
             correct_start_position
@@ -209,30 +210,30 @@
         ]
 
         count_plusplus = [      # if self[index: index+substr_size] == substr
             (Opcode.INC, b''),  # count++
         ]
 
         num_jmp_code = get_bytes_count(count_plusplus)
-        jmp_count_plusplus_statement = Opcode.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
+        jmp_count_plusplus_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
         count_substring[-1] = jmp_count_plusplus_statement
 
         go_back_to_while = [    # go back to while verification
             (Opcode.REVERSE4, b''),
             (Opcode.INC, b''),  # index ++
             (Opcode.REVERSE4, b''),
             # jump back to while
         ]
 
         num_jmp_code = -get_bytes_count(go_back_to_while + count_plusplus + count_substring + verify_while)
-        jmp_back_to_while_statement = Opcode.get_jump_and_data(Opcode.JMP, num_jmp_code)
+        jmp_back_to_while_statement = OpcodeHelper.get_jump_and_data(Opcode.JMP, num_jmp_code)
         go_back_to_while.append(jmp_back_to_while_statement)
 
         num_jmp_code = get_bytes_count(go_back_to_while + count_plusplus + count_substring)
-        jmp_to_clean_stack_statement = Opcode.get_jump_and_data(Opcode.JMPGT, num_jmp_code, True)
+        jmp_to_clean_stack_statement = OpcodeHelper.get_jump_and_data(Opcode.JMPGT, num_jmp_code, True)
         verify_while[-1] = jmp_to_clean_stack_statement
 
         clean_stack = [         # remove auxiliary values
             (Opcode.REVERSE4, b''),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/extendmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/extendmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ExtendMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if not isinstance(sequence_type, MutableSequenceType):
             sequence_type = Type.mutableSequence
 
         self_arg = Variable(sequence_type)
         item_arg = Variable(Type.sequence.build_collection(sequence_type.value_type))
 
         identifier = 'extend'
@@ -27,32 +27,32 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 2:
             return False
         if not all(isinstance(param, IExpression) for param in params):
             return False
 
-        from boa3.model.type.itype import IType
+        from boa3.internal.model.type.itype import IType
         sequence_type: IType = params[0].type
         iterator_type: IType = params[1].type
 
         if not isinstance(sequence_type, MutableSequenceType):
             return False
         if not isinstance(iterator_type, SequenceType):
             return False
         return sequence_type.value_type.is_type_of(iterator_type.value_type)
 
     @property
     def stores_on_slot(self) -> bool:
         return True
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-        from boa3.neo.vm.type.StackItem import StackItemType
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        from boa3.internal.neo.vm.type.StackItem import StackItemType
         return [
             (Opcode.OVER, b''),
             (Opcode.ISTYPE, StackItemType.Array),
             (Opcode.JMPIF, Integer(5).to_byte_array(signed=True, min_length=1)),
             (Opcode.CAT, b''),
             (Opcode.JMP, Integer(18).to_byte_array(signed=True, min_length=1)),
             (Opcode.UNPACK, b''),       # get the values, top of stack will be the array size
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/insertmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/insertmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class InsertMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         self_arg = Variable(sequence_type)
         index_arg = Variable(sequence_type.valid_key)
         item_arg = Variable(sequence_type.value_type)
 
         identifier = 'insert'
@@ -29,29 +29,29 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 3:
             return False
         if not all(isinstance(param, IExpression) for param in params):
             return False
 
-        from boa3.model.type.itype import IType
+        from boa3.internal.model.type.itype import IType
         sequence_type: IType = params[0].type
         index_type: IType = params[1].type
         value_type: IType = params[2].type
 
         if not isinstance(sequence_type, MutableSequenceType):
             return False
         return sequence_type.key_type.is_type_of(index_type) and sequence_type.value_type.is_type_of(value_type)
 
     def validate_negative_arguments(self) -> List[int]:
         return [list(self.args).index('__index')]
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
         return [
             # insert(pos, index)
             (Opcode.PUSH2, b''),
             (Opcode.PICK, b''),     # array
             (Opcode.DUP, b''),
             (Opcode.SIZE, b''),     # array[-1]
             (Opcode.DEC, b''),
@@ -77,15 +77,15 @@
             (Opcode.PUSH4, b''),
             (Opcode.PICK, b''),
             (Opcode.REVERSE3, b''),
             (Opcode.SETITEM, b''),      # array[x] = value
             (Opcode.DUP, b''),          # value = aux
             (Opcode.PUSH4, b''),
             (Opcode.PICK, b''),
-            (Opcode.GE, b''),
+            (Opcode.GT, b''),
             (Opcode.JMPIF, Integer(-18).to_byte_array(signed=True, min_length=1)),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
             (Opcode.SWAP, b''),     # array[index] = y
             (Opcode.SETITEM, b''),
         ]
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/mapkeysmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/mapkeysmethod.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.mapping.mappingtype import MappingType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class MapKeysMethod(IBuiltinMethod):
     def __init__(self, mapping_type: MappingType = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if not isinstance(mapping_type, MappingType):
             self_arg = Variable(Type.mapping)
             return_type = Type.sequence
         else:
             self_arg = Variable(mapping_type)
             return_type = Type.sequence.build_collection(mapping_type.key_type)
 
@@ -27,15 +27,15 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1 or not isinstance(params[0], IExpression):
             return False
         return self._arg_self.type.is_type_of(params[0].type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [(Opcode.KEYS, b'')]
 
     def push_self_first(self) -> bool:
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/mapvaluesmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/mapvaluesmethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.mapping.mappingtype import MappingType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class MapValuesMethod(IBuiltinMethod):
     def __init__(self, mapping_type: MappingType = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if not isinstance(mapping_type, MappingType):
             self_arg = Variable(Type.mapping)
             return_type = Type.sequence
         else:
             self_arg = Variable(mapping_type)
             return_type = Type.sequence.build_collection(mapping_type.value_type)
 
@@ -27,15 +27,15 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1 or not isinstance(params[0], IExpression):
             return False
         return self._arg_self.type.is_type_of(params[0].type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [(Opcode.VALUES, b'')]
 
     def push_self_first(self) -> bool:
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/popmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/popmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,67 +1,69 @@
 import ast
-from typing import Any, Dict, Iterable, List, Optional, Tuple
+from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.mapping.mutable.dicttype import DictType
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class PopMethod(IBuiltinMethod):
-    def __init__(self, sequence_type: MutableSequenceType = None):
-        if not isinstance(sequence_type, MutableSequenceType):
-            from boa3.model.type.type import Type
-            sequence_type = Type.mutableSequence
-
+    def __init__(self, args: Dict[str, Variable] = None,
+                 defaults: List[ast.AST] = None, return_type: IType = None):
         identifier = 'pop'
-        args: Dict[str, Variable] = {'self': Variable(sequence_type),
-                                     'index': Variable(sequence_type.valid_key)
-                                     }
-        # TODO: change when dict.pop is implemented
-        index_default = ast.parse("-1").body[0].value.operand
-        index_default.n = -1
-        super().__init__(identifier, args, defaults=[index_default], return_type=sequence_type.value_type)
+
+        super().__init__(identifier, args, defaults=defaults, return_type=return_type)
 
     @property
-    def is_supported(self) -> bool:
-        """
-        Verifies if the builtin method is supported by the compiler
-
-        :return: True if it is supported. False otherwise.
-        """
-        # TODO: remove when bytearray.pop() is implemented
-        from boa3.model.type.type import Type
-        return not Type.bytearray.is_type_of(self._arg_self.type)
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
+
+        if self._arg_self.type is Type.mutableSequence:
+            return self._identifier
+
+        if Type.dict.is_type_of(self._arg_self.type):
+
+            if len(self.args) == 2:
+                return '-{0}_{1}'.format(self._identifier, Type.dict.identifier)
+
+            elif len(self.args) == 3:
+                return '-{0}_{1}_{2}'.format(self._identifier, Type.dict.identifier, 'default')
+
+        if Type.mutableSequence.is_type_of(self._arg_self.type):
+            return '-{0}_{1}'.format(self._identifier, Type.mutableSequence.identifier)
+
+        return self._identifier
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) < 0 or len(params) > 2:
             return False
 
         if any(not isinstance(param, (IExpression, IType)) for param in params):
             return False
 
-        sequence = params[0].type if isinstance(params[0], IExpression) else params[0]
-        if not isinstance(sequence, MutableSequenceType):
+        sequence_or_map = params[0].type if isinstance(params[0], IExpression) else params[0]
+        if not isinstance(sequence_or_map, MutableSequenceType) or not isinstance(sequence_or_map, DictType):
             return False
 
         if len(params) > 1:
             value = params[1].type if isinstance(params[1], IExpression) else params[1]
-            return sequence.valid_key.is_type_of(value)
+            return sequence_or_map.valid_key.is_type_of(value)
         return True
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
         return [
             (Opcode.DUP, b''),
             (Opcode.SIGN, b''),
             (Opcode.PUSHM1, b''),
             (Opcode.JMPNE, Integer(5).to_byte_array(min_length=1, signed=True)),
             (Opcode.OVER, b''),
             (Opcode.SIZE, b''),
@@ -82,18 +84,21 @@
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
     def build(self, value: Any) -> IBuiltinMethod:
-        if isinstance(value, Iterable) and len(value) > 0:
-            if len(value) == 1:
-                value = value[0]
-            elif self.validate_parameters(*value):
-                return PopMethod(value[0])
-
-        if type(value) == type(self.args['self'].type):
-            return self
-        if isinstance(value, MutableSequenceType):
-            return PopMethod(value)
-        return super().build(value)
+        if not isinstance(value, list):
+            value = [value]
+
+        from boa3.internal.model.builtin.classmethod.popdictmethod import PopDictMethod
+        from boa3.internal.model.builtin.classmethod.popsequencemethod import PopSequenceMethod
+        from boa3.internal.model.type.type import Type
+
+        if Type.dict.is_type_of(value[0]):
+            if len(value) == 3:
+                from boa3.internal.model.builtin.classmethod.popdictdefaultmethod import PopDictDefaultMethod
+                return PopDictDefaultMethod(value[0])
+            return PopDictMethod(value[0])
+
+        return PopSequenceMethod(value[0])
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/removemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/removemethod.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class RemoveMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         self_arg = Variable(sequence_type)
         item_arg = Variable(sequence_type.value_type)
 
         identifier = 'remove'
         args: Dict[str, Variable] = {'self': self_arg,
@@ -27,25 +27,25 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 2:
             return False
         if not all(isinstance(param, IExpression) for param in params):
             return False
 
-        from boa3.model.type.itype import IType
+        from boa3.internal.model.type.itype import IType
         sequence_type: IType = params[0].type
         value_type: IType = params[1].type
 
         if not isinstance(sequence_type, MutableSequenceType):
             return False
         return sequence_type.value_type.is_type_of(value_type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
         return [
             (Opcode.PUSH0, b''),  # need to find the index to use REMOVE opcode
             (Opcode.DUP, b''),      # while index < len(array):
             (Opcode.PUSH3, b''),
             (Opcode.PICK, b''),
             (Opcode.SIZE, b''),
             (Opcode.GE, b''),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/reversemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/reversemethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ReverseMethod(IBuiltinMethod):
     def __init__(self, sequence_type: MutableSequenceType = None):
         if not isinstance(sequence_type, MutableSequenceType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             sequence_type = Type.mutableSequence
 
         identifier = 'reverse'
         args: Dict[str, Variable] = {'self': Variable(sequence_type)}
         super().__init__(identifier, args)
 
     @property
@@ -23,15 +23,15 @@
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
         return isinstance(params[0], IExpression) and isinstance(params[0].type, MutableSequenceType)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [(Opcode.REVERSEITEMS, b'')]
 
     def push_self_first(self) -> bool:
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/toboolmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/toboolmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,41 +1,41 @@
 from abc import ABC
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ToBoolMethod(IBuiltinMethod, ABC):
     def __init__(self, self_type: IType):
         identifier = 'to_bool'
         if isinstance(self_type, IdentifiedSymbol):
             identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
 
         args: Dict[str, Variable] = {'self': Variable(self_type)}
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         super().__init__(identifier, args, return_type=Type.bool)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
         return isinstance(params[0], IExpression) and isinstance(params[0].type, BytesType)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
         return [
             (Opcode.CONVERT, Type.bool.stack_item)
         ]
 
     def push_self_first(self) -> bool:
         return self.has_self_argument
 
@@ -61,15 +61,15 @@
 
 ToBool = _ConvertToBoolMethod()
 
 
 class BytesToBoolMethod(ToBoolMethod):
     def __init__(self, self_type: IType = None):
         if not isinstance(self_type, BytesType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             self_type = Type.bytes
         super().__init__(self_type)
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, BytesType):
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/tobytesmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/countmethod.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,101 +1,84 @@
-from abc import ABC
-from typing import Any, Dict, List, Optional, Tuple
+import ast
+from typing import Any, Dict, List, Optional
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.type.primitive.inttype import IntType
-from boa3.model.type.primitive.strtype import StrType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-
-
-class ToBytesMethod(IBuiltinMethod, ABC):
-    def __init__(self, self_type: IType):
-        identifier = 'to_bytes'
-        if isinstance(self_type, IdentifiedSymbol):
-            identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
-
-        args: Dict[str, Variable] = {'self': Variable(self_type)}
-        from boa3.model.type.type import Type
-        super().__init__(identifier, args, return_type=Type.bytes)
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
 
-    @property
-    def _arg_self(self) -> Variable:
-        return self.args['self']
 
-    def validate_parameters(self, *params: IExpression) -> bool:
-        if len(params) != 1:
-            return False
-        return isinstance(params[0], IExpression) and isinstance(params[0].type, BytesType)
+class CountMethod(IBuiltinMethod):
+
+    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+        from boa3.internal.model.type.type import Type
+        identifier = 'count'
+        super().__init__(identifier, args, defaults=defaults, return_type=Type.int)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
-        return [
-            (Opcode.CONVERT, Type.bytes.stack_item)
-        ]
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
 
-    def push_self_first(self) -> bool:
-        return self.has_self_argument
+        if self._arg_self.type is Type.str:     # CountStrMethod
+            return '-{0}_{1}'.format(self._identifier, Type.str.identifier)
 
-    @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+        if Type.sequence.is_type_of(self._arg_self.type):
 
-    @property
-    def _body(self) -> Optional[str]:
-        return None
+            from boa3.internal.model.type.annotation.uniontype import UnionType
+            from boa3.internal.model.type.primitive.bytestype import BytesType
+            from boa3.internal.model.type.primitive.inttype import IntType
+            from boa3.internal.model.type.primitive.strtype import StrType
 
+            if isinstance(self._arg_self.type.value_type, (BytesType, IntType, StrType)) or\
+                    ((isinstance(self._arg_self.type.value_type, UnionType) and
+                      all(isinstance(type_, (BytesType, IntType, StrType)) for type_ in self._arg_self.type.value_type.union_types))):    # CountSequencePrimitiveValueMethod
+                return '-{0}_{1}'.format(self._identifier, 'primitive')
 
-class _ConvertToBytesMethod(ToBytesMethod):
-    def __init__(self):
-        super().__init__(None)
+            elif Type.mutableSequence.is_type_of(self._arg_self.type.value_type):    # CountSequenceGenericValueMethod
+                return self._identifier
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if isinstance(value, IntType):
-            return IntToBytesMethod(value)
-        elif isinstance(value, StrType):
-            return StrToBytesMethod(value)
-        # if it is not a valid type, show mismatched type with int
-        return IntToBytesMethod()
-
-
-ToBytes = _ConvertToBytesMethod()
-
-
-class IntToBytesMethod(ToBytesMethod):
-    def __init__(self, self_type: IType = None):
-        if not isinstance(self_type, IntType):
-            from boa3.model.type.type import Type
-            self_type = Type.int
-        super().__init__(self_type)
+        return self._identifier
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if type(value) == type(self.args['self'].type):
-            return self
-        if isinstance(value, IntType):
-            return IntToBytesMethod(value)
-        return super().build(value)
+    @property
+    def _arg_self(self) -> Variable:
+        return self.args['self']
 
+    @property
+    def _arg_value(self) -> Variable:
+        return self.args['value']
 
-class StrToBytesMethod(ToBytesMethod):
-    def __init__(self, self_type: IType = None):
-        if not isinstance(self_type, StrType):
-            from boa3.model.type.type import Type
-            self_type = Type.str
-        super().__init__(self_type)
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        # string and bytes' stack item are the same
-        return []
+    def _body(self) -> Optional[str]:
+        return
 
     def build(self, value: Any) -> IBuiltinMethod:
-        if type(value) == type(self.args['self'].type):
-            return self
-        if isinstance(value, StrType):
-            return StrToBytesMethod(value)
+        if not isinstance(value, list):
+            value = [value]
+
+        from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
+        from boa3.internal.model.type.collection.sequence.tupletype import TupleType
+        from boa3.internal.model.type.collection.sequence.rangetype import RangeType
+        if len(value) > 1 and isinstance(value[0], (ListType, TupleType, RangeType)):
+
+            from boa3.internal.model.type.primitive.bytestype import BytesType
+            from boa3.internal.model.type.primitive.inttype import IntType
+            from boa3.internal.model.type.primitive.strtype import StrType
+            from boa3.internal.model.type.annotation.uniontype import UnionType
+
+            if isinstance(value[0].value_type, (BytesType, IntType, StrType)) or\
+                    ((isinstance(value[0].value_type, UnionType) and
+                      all(isinstance(type_, (BytesType, IntType, StrType)) for type_ in value[0].value_type.union_types))):
+
+                from boa3.internal.model.builtin.classmethod.countsequenceprimitivemethod import CountSequencePrimitiveMethod
+                return CountSequencePrimitiveMethod(value[0], value[1])
+
+            from boa3.internal.model.builtin.classmethod.countsequencegenericmethod import CountSequenceGenericMethod
+            return CountSequenceGenericMethod(value[0], value[1])
+
+        from boa3.internal.model.type.type import Type
+        if len(value) > 0 and Type.str.is_type_of(value[0]):
+            from boa3.internal.model.builtin.builtin import Builtin
+            return Builtin.CountStr
+
         return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/tointmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/tostrmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,77 +1,77 @@
 from abc import ABC
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ToIntMethod(IBuiltinMethod, ABC):
+class ToStrMethod(IBuiltinMethod, ABC):
     def __init__(self, self_type: IType):
-        identifier = 'to_int'
+        identifier = 'to_str'
         if isinstance(self_type, IdentifiedSymbol):
             identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
 
         args: Dict[str, Variable] = {'self': Variable(self_type)}
-        from boa3.model.type.type import Type
-        super().__init__(identifier, args, return_type=Type.int)
+        from boa3.internal.model.type.type import Type
+        super().__init__(identifier, args, return_type=Type.str)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
         return isinstance(params[0], IExpression) and isinstance(params[0].type, BytesType)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
         return [
-            (Opcode.CONVERT, Type.int.stack_item)
+            (Opcode.CONVERT, Type.str.stack_item)
         ]
 
     def push_self_first(self) -> bool:
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
 
-class _ConvertToIntMethod(ToIntMethod):
+class _ConvertToStrMethod(ToStrMethod):
     def __init__(self):
         super().__init__(None)
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, BytesType):
-            return BytesToIntMethod(value)
+            return BytesToStrMethod(value)
         # if it is not a valid type, show mismatched type with bytes
-        return BytesToIntMethod()
+        return BytesToStrMethod()
 
 
-ToInt = _ConvertToIntMethod()
+ToStr = _ConvertToStrMethod()
 
 
-class BytesToIntMethod(ToIntMethod):
+class BytesToStrMethod(ToStrMethod):
     def __init__(self, self_type: IType = None):
         if not isinstance(self_type, BytesType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             self_type = Type.bytes
         super().__init__(self_type)
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, BytesType):
-            return BytesToIntMethod(value)
+            return BytesToStrMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/classmethod/tostrmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/tointmethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,77 +1,77 @@
 from abc import ABC
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ToStrMethod(IBuiltinMethod, ABC):
+class ToIntMethod(IBuiltinMethod, ABC):
     def __init__(self, self_type: IType):
-        identifier = 'to_str'
+        identifier = 'to_int'
         if isinstance(self_type, IdentifiedSymbol):
             identifier = '-{0}_{1}'.format(self_type.identifier, identifier)
 
         args: Dict[str, Variable] = {'self': Variable(self_type)}
-        from boa3.model.type.type import Type
-        super().__init__(identifier, args, return_type=Type.str)
+        from boa3.internal.model.type.type import Type
+        super().__init__(identifier, args, return_type=Type.int)
 
     @property
     def _arg_self(self) -> Variable:
         return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
         return isinstance(params[0], IExpression) and isinstance(params[0].type, BytesType)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
         return [
-            (Opcode.CONVERT, Type.str.stack_item)
+            (Opcode.CONVERT, Type.int.stack_item)
         ]
 
     def push_self_first(self) -> bool:
         return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
 
-class _ConvertToStrMethod(ToStrMethod):
+class _ConvertToIntMethod(ToIntMethod):
     def __init__(self):
         super().__init__(None)
 
     def build(self, value: Any) -> IBuiltinMethod:
         if isinstance(value, BytesType):
-            return BytesToStrMethod(value)
+            return BytesToIntMethod(value)
         # if it is not a valid type, show mismatched type with bytes
-        return BytesToStrMethod()
+        return BytesToIntMethod()
 
 
-ToStr = _ConvertToStrMethod()
+ToInt = _ConvertToIntMethod()
 
 
-class BytesToStrMethod(ToStrMethod):
+class BytesToIntMethod(ToIntMethod):
     def __init__(self, self_type: IType = None):
         if not isinstance(self_type, BytesType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             self_type = Type.bytes
         super().__init__(self_type)
 
     def build(self, value: Any) -> IBuiltinMethod:
         if type(value) == type(self.args['self'].type):
             return self
         if isinstance(value, BytesType):
-            return BytesToStrMethod(value)
+            return BytesToIntMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/contract/abortmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/contract/abortmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class AbortMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'abort'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=Type.none)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [(Opcode.ABORT, b'')]
 
     @property
     def _args_on_stack(self) -> int:
         return 0
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/contract/nep17transferevent.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/contract/nep17transferevent.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from typing import Dict
 
-from boa3.model.builtin.method.builtinevent import IBuiltinEvent
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
+from boa3.internal.model.variable import Variable
 
 
 class Nep17TransferEvent(IBuiltinEvent):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = 'Nep17TransferEvent'
         args: Dict[str, Variable] = {
             'from_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
             'to_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
             'amount': Variable(Type.int)
         }
         super().__init__(identifier, args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/contract/nep5transferevent.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/contract/nep5transferevent.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from typing import Dict
 
-from boa3.model.builtin.method.builtinevent import IBuiltinEvent
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
+from boa3.internal.model.variable import Variable
 
 
 class Nep5TransferEvent(IBuiltinEvent):
 
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'Nep5TransferEvent'
         args: Dict[str, Variable] = {
             'from_addr': Variable(Type.bytes),
             'to_addr': Variable(Type.bytes),
             'amount': Variable(Type.int)
         }
         super().__init__(identifier, args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/decorator/builtindecorator.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/decorator/builtindecorator.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,25 +1,21 @@
 import ast
-from abc import ABC, abstractmethod
-from typing import Dict, List
+from abc import ABC
+from typing import Any, Dict, List
 
-from boa3.model.builtin.builtincallable import IBuiltinCallable
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.decorator import IDecorator
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
-class IBuiltinDecorator(IBuiltinCallable, Method, ABC):
+class IBuiltinDecorator(IBuiltinCallable, IDecorator, ABC):
     def __init__(self, identifier: str, args: Dict[str, Variable] = None,
                  defaults: List[ast.AST] = None, return_type: IType = None):
         super().__init__(identifier, args, defaults, return_type)
 
-    @abstractmethod
     def validate_parameters(self, *params: IExpression) -> bool:
-        """
-        Verifies if the given parameters are valid to the method
+        return len(params) == len(self.args)
 
-        :param params: arguments of the method
-        :return: True if all arguments are valid. False otherwise.
-        """
-        pass
+    def validate_values(self, *params: Any) -> List[Any]:
+        return []
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/internal/innerdeploymethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/internal/innerdeploymethod.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from __future__ import annotations
 
 import ast
 from typing import Dict, Optional
 
-from boa3 import constants
-from boa3.model import set_internal_call
-from boa3.model.builtin.internal.internalmethod import IInternalMethod
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.method import Method
-from boa3.model.symbol import ISymbol
-from boa3.model.variable import Variable
+from boa3.internal import constants
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.builtin.internal.internalmethod import IInternalMethod
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.method import Method
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.variable import Variable
 
 
 class InnerDeployMethod(IInternalMethod):
 
     @classmethod
     def instance(cls) -> InnerDeployMethod:
         return _INNER_DEPLOY_METHOD
 
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = constants.DEPLOY_METHOD_ID
         args: Dict[str, Variable] = {
             'data': Variable(Type.any),
             'update': Variable(Type.bool)
         }
         super().__init__(identifier, args, return_type=Type.none)
 
@@ -54,15 +54,15 @@
         if not isinstance(symbol, Method):
             return False
         else:
             if not symbol.is_public:
                 return False
 
             reference_args = list(_INNER_DEPLOY_METHOD.args.values())
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             if symbol.return_type is not Type.none:
                 return False
 
             if len(symbol.args) != len(reference_args):
                 return False
 
             for index, arg in enumerate(symbol.args.values()):
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/internal/internalmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/internal/internalmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,25 +1,24 @@
 from __future__ import annotations
 
 import abc
 import ast
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
 class IInternalMethod(IBuiltinMethod, abc.ABC):
 
     def __init__(self, identifier: str, args: Dict[str, Variable] = None,
                  defaults: List[ast.AST] = None, return_type: IType = None,
                  vararg: Optional[Tuple[str, Variable]] = None):
-
         super().__init__(identifier, args, defaults, return_type, vararg)
 
     @classmethod
     @abc.abstractmethod
     def instance(cls) -> IInternalMethod:
         pass
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/blocktype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/blocktype.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,30 +1,31 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal import constants
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class BlockType(ClassArrayType):
     """
     A class used to represent Neo Block class
     """
 
     def __init__(self):
         super().__init__('Block')
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 
         uint256 = UInt256Type.build()
 
         self._variables: Dict[str, Variable] = {
             'hash': Variable(uint256),
             'version': Variable(Type.int),
             'previous_hash': Variable(uint256),
@@ -35,22 +36,30 @@
             'primary_index': Variable(Type.int),
             'next_consensus': Variable(UInt160Type.build()),
             'transaction_count': Variable(Type.int)
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
 
@@ -80,19 +89,19 @@
         args: Dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
 
-        uint160_default = Integer(20).to_byte_array() + bytes(20)
-        uint256_default = Integer(32).to_byte_array() + bytes(32)
+        uint160_default = Integer(constants.SIZE_OF_INT160).to_byte_array() + bytes(constants.SIZE_OF_INT160)
+        uint256_default = Integer(constants.SIZE_OF_INT256).to_byte_array() + bytes(constants.SIZE_OF_INT256)
 
         return [
             (Opcode.PUSH0, b''),  # transaction_count
             (Opcode.PUSHDATA1, uint160_default),  # next_consensus
             (Opcode.PUSH0, b''),  # primary_index
             (Opcode.PUSH0, b''),  # index
             (Opcode.PUSH0, b''),  # nonce
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/currenthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/vote.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,20 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.nativecontract import LedgerMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.variable import Variable
 
 
-class CurrentHashMethod(LedgerMethod):
-    def __init__(self):
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
-        identifier = '-get_current_hash'
-        syscall = 'currentHash'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=UInt256Type.build())
-
+class VoteMethod(NeoContractMethod):
 
-class CurrentHashProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'current_hash'
-        getter = CurrentHashMethod()
-        super().__init__(identifier, getter)
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'vote'
+        native_identifier = 'vote'
+        args: Dict[str, Variable] = {
+            'account': Variable(UInt160Type.build()),
+            'vote_to': Variable(ECPointType.build())
+        }
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/currentindexmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/currentindexmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.nativecontract import LedgerMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
+from boa3.internal.model.variable import Variable
 
 
-class CurrentIndexMethod(LedgerMethod):
+class GetCurrentIndexMethod(LedgerMethod):
     def __init__(self):
-        identifier = '-get_current_index'
+        identifier = 'get_current_index'
         syscall = 'currentIndex'
         args: Dict[str, Variable] = {}
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
 
 class CurrentIndexProperty(IBuiltinProperty):
     def __init__(self):
         identifier = 'current_index'
-        getter = CurrentIndexMethod()
+        getter = GetCurrentIndexMethod()
         super().__init__(identifier, getter)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/getblockmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/contract_management/hasmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.blockchain.blocktype import BlockType
-from boa3.model.builtin.interop.nativecontract import LedgerMethod
-from boa3.model.variable import Variable
-
-
-class GetBlockMethod(LedgerMethod):
-
-    def __init__(self, block_type: BlockType):
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
-        from boa3.model.type.type import Type
-
-        identifier = 'get_block'
-        syscall = 'getBlock'
-        args: Dict[str, Variable] = {'index': Variable(Type.union.build([Type.int,
-                                                                         UInt256Type.build()]))}
-        super().__init__(identifier, syscall, args, return_type=block_type)
+from boa3.internal.model.builtin.interop.nativecontract import ContractManagementMethod
+from boa3.internal.model.variable import Variable
+
+
+class HasMethod(ContractManagementMethod):
+
+    def __init__(self):
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.type import Type
+
+        identifier = 'has_method'
+        syscall = 'hasMethod'
+        args: Dict[str, Variable] = {
+            'hash': Variable(UInt160Type.build()),
+            'method': Variable(Type.str),
+            'parameter_count': Variable(Type.int)
+        }
+
+        super().__init__(identifier, syscall, args, return_type=Type.bool)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/getcontractmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/getcontractmethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.contract.contracttype import ContractType
-from boa3.model.builtin.interop.nativecontract.ContractManagement.contractmanagementmethod import \
+from boa3.internal.model.builtin.interop.contract.contracttype import ContractType
+from boa3.internal.model.builtin.interop.nativecontract.ContractManagement.contractmanagementmethod import \
     ContractManagementMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.variable import Variable
 
 
 class GetContractMethod(ContractManagementMethod):
 
     def __init__(self, contract_type: ContractType):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.type import Type
         identifier = 'get_contract'
         syscall = 'getContract'
         args: Dict[str, Variable] = {'hash': Variable(UInt160Type.build())}
-        super().__init__(identifier, syscall, args, return_type=contract_type)
+        super().__init__(identifier, syscall, args, return_type=Type.optional.build(contract_type))
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/getcurrentheightmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/totalsupplymethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,21 +1,15 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
+from boa3.internal.model.variable import Variable
 
 
-class GetCurrentHeightMethod(InteropMethod):
-    def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = '-get_current_height'
-        syscall = 'System.Blockchain.GetHeight'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+class TotalSupplyMethod(Nep17Method):
 
+    def __init__(self, contract_script_hash: bytes):
+        from boa3.internal.model.type.type import Type
 
-class CurrentHeightProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'current_height'
-        getter = GetCurrentHeightMethod()
-        super().__init__(identifier, getter)
+        identifier = 'totalSupply'
+        native_identifier = 'totalSupply'
+        args: Dict[str, Variable] = {}
+        super().__init__(identifier, native_identifier, args, return_type=Type.int, script_hash=contract_script_hash)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/gettransactionfromblockmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionfromblockmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.blockchain.transactiontype import TransactionType
-from boa3.model.builtin.interop.nativecontract import LedgerMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.blockchain.transactiontype import TransactionType
+from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetTransactionFromBlockMethod(LedgerMethod):
 
     def __init__(self, transaction_type: TransactionType):
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
+        from boa3.internal.model.type.type import Type
 
         identifier = 'get_transaction_from_block'
         syscall = 'getTransactionFromBlock'
         args: Dict[str, Variable] = {'block_hash_or_height': Variable(Type.union.build([UInt256Type.build(),
                                                                                         Type.int])),
                                      'tx_index': Variable(Type.int)}
-        super().__init__(identifier, syscall, args, return_type=transaction_type)
+        super().__init__(identifier, syscall, args, return_type=Type.optional.build(transaction_type))
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/gettransactionheightmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionheightmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract import LedgerMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetTransactionHeightMethod(LedgerMethod):
 
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
+        from boa3.internal.model.type.type import Type
 
         identifier = 'get_transaction_height'
         syscall = 'getTransactionHeight'
         args: Dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
         super().__init__(identifier, syscall, args, return_type=Type.int)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/gettransactionmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/gettransactionsignersmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.blockchain.transactiontype import TransactionType
-from boa3.model.builtin.interop.nativecontract import LedgerMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.blockchain.signertype import SignerType
+from boa3.internal.model.builtin.interop.nativecontract import LedgerMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetTransactionMethod(LedgerMethod):
+class GetTransactionSignersMethod(LedgerMethod):
 
-    def __init__(self, transaction_type: TransactionType):
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
+    def __init__(self, signer_type: SignerType):
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
+        from boa3.internal.model.type.type import Type
 
-        identifier = 'get_transaction'
-        syscall = 'getTransaction'
+        identifier = 'get_transaction_signers'
+        syscall = 'getTransactionSigners'
         args: Dict[str, Variable] = {'hash_': Variable(UInt256Type.build())}
-        super().__init__(identifier, syscall, args, return_type=transaction_type)
+        super().__init__(identifier, syscall, args, return_type=Type.list.build([signer_type]))
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/blockchain/transactiontype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/transactiontype.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,52 +1,61 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal import constants
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class TransactionType(ClassArrayType):
     """
     A class used to represent Neo Transaction class
     """
 
     def __init__(self):
         super().__init__('Transaction')
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.type.collection.sequence.uint256type import UInt256Type
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
 
         self._variables: Dict[str, Variable] = {
             'hash': Variable(UInt256Type.build()),
             'version': Variable(Type.int),
             'nonce': Variable(Type.int),
             'sender': Variable(UInt160Type.build()),
             'system_fee': Variable(Type.int),
             'network_fee': Variable(Type.int),
             'valid_until_block': Variable(Type.int),
             'script': Variable(Type.bytes),
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
 
@@ -76,19 +85,19 @@
         args: Dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
 
-        uint160_default = Integer(20).to_byte_array() + bytes(20)
-        uint256_default = Integer(32).to_byte_array() + bytes(32)
+        uint160_default = Integer(constants.SIZE_OF_INT160).to_byte_array() + bytes(constants.SIZE_OF_INT160)
+        uint256_default = Integer(constants.SIZE_OF_INT256).to_byte_array() + bytes(constants.SIZE_OF_INT256)
 
         return [
             (Opcode.PUSHDATA1, Integer(0).to_byte_array()),  # script
             (Opcode.PUSH0, b''),  # valid_until_block
             (Opcode.PUSH0, b''),  # network_fee
             (Opcode.PUSH0, b''),  # system_fee
             (Opcode.PUSHDATA1, uint160_default),  # sender
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/__init__.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 __all__ = ['CallFlagsType',
            'CallMethod',
            'ContractType',
            'CreateMethod',
            'CreateMultisigAccountMethod',
            'CreateStandardAccountMethod',
            'DestroyMethod',
-           'GasProperty',
+           'GasToken',
            'GetCallFlagsMethod',
            'GetMinimumDeploymentFeeMethod',
-           'NeoProperty',
+           'NeoToken',
            'UpdateMethod'
            ]
 
-from boa3.model.builtin.interop.contract.callflagstype import CallFlagsType
-from boa3.model.builtin.interop.contract.callmethod import CallMethod
-from boa3.model.builtin.interop.contract.contracttype import ContractType
-from boa3.model.builtin.interop.contract.createmethod import CreateMethod
-from boa3.model.builtin.interop.contract.createmultisigaccountmethod import CreateMultisigAccountMethod
-from boa3.model.builtin.interop.contract.createstandardaccountmethod import CreateStandardAccountMethod
-from boa3.model.builtin.interop.contract.destroymethod import DestroyMethod
-from boa3.model.builtin.interop.contract.getcallflagsmethod import GetCallFlagsMethod
-from boa3.model.builtin.interop.contract.getgasscripthashmethod import GasProperty
-from boa3.model.builtin.interop.contract.getminimumdeploymentfeemethod import GetMinimumDeploymentFeeMethod
-from boa3.model.builtin.interop.contract.getneoscripthashmethod import NeoProperty
-from boa3.model.builtin.interop.contract.updatemethod import UpdateMethod
+from boa3.internal.model.builtin.interop.contract.callflagstype import CallFlagsType
+from boa3.internal.model.builtin.interop.contract.callmethod import CallMethod
+from boa3.internal.model.builtin.interop.contract.contracttype import ContractType
+from boa3.internal.model.builtin.interop.contract.createmethod import CreateMethod
+from boa3.internal.model.builtin.interop.contract.createmultisigaccountmethod import CreateMultisigAccountMethod
+from boa3.internal.model.builtin.interop.contract.createstandardaccountmethod import CreateStandardAccountMethod
+from boa3.internal.model.builtin.interop.contract.destroymethod import DestroyMethod
+from boa3.internal.model.builtin.interop.contract.getcallflagsmethod import GetCallFlagsMethod
+from boa3.internal.model.builtin.interop.contract.getgasscripthashmethod import GasToken
+from boa3.internal.model.builtin.interop.contract.getminimumdeploymentfeemethod import GetMinimumDeploymentFeeMethod
+from boa3.internal.model.builtin.interop.contract.getneoscripthashmethod import NeoToken
+from boa3.internal.model.builtin.interop.contract.updatemethod import UpdateMethod
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/callflagstype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/callflagstype.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, Dict
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class CallFlagsType(IntType):
     """
     A class used to represent Neo interop CallFlags type
     """
 
@@ -33,25 +33,29 @@
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.contract import CallFlags
-        from boa3.model.variable import Variable
+        from boa3.internal.model.variable import Variable
 
-        return {name: Variable(self) for name in CallFlags.__members__.keys()}
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in CallFlags.__members__.keys()})
+
+        return _symbols
 
     def get_value(self, symbol_id) -> Any:
         """
         Gets the literal value of a symbol
 
         :return: the value if this type has this symbol. None otherwise.
         """
-        if symbol_id in self.symbols:
-            from boa3.builtin.interop.contract import CallFlags
+        from boa3.builtin.interop.contract import CallFlags
+
+        if symbol_id in self.symbols and symbol_id in CallFlags.__members__:
             return CallFlags.__members__[symbol_id]
 
         return None
 
 
 _CallFlags = CallFlagsType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/callmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/callmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 import ast
 from typing import Dict, List
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class CallMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.builtin.interop.contract.callflagstype import CallFlagsType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.builtin.interop.contract.callflagstype import CallFlagsType
+        from boa3.internal.model.type.type import Type
         identifier = 'call_contract'
         syscall = 'System.Contract.Call'
 
         call_flags = CallFlagsType.build()
         args: Dict[str, Variable] = {
             'script_hash': Variable(UInt160Type.build()),
             'method': Variable(Type.str),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/__init__.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,19 +6,19 @@
            'ContractMethodDescriptorType',
            'ContractParameterDefinitionType',
            'ContractParameterType',
            'ContractPermissionDescriptorType',
            'ContractPermissionType'
            ]
 
-from boa3.model.builtin.interop.contract.contractmanifest.contractabitype import ContractAbiType
-from boa3.model.builtin.interop.contract.contractmanifest.contracteventdescriptortype import ContractEventDescriptorType
-from boa3.model.builtin.interop.contract.contractmanifest.contractgrouptype import ContractGroupType
-from boa3.model.builtin.interop.contract.contractmanifest.contractmanifesttype import ContractManifestType
-from boa3.model.builtin.interop.contract.contractmanifest.contractmethoddescriptortype import \
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractabitype import ContractAbiType
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contracteventdescriptortype import ContractEventDescriptorType
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractgrouptype import ContractGroupType
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractmanifesttype import ContractManifestType
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractmethoddescriptortype import \
     ContractMethodDescriptorType
-from boa3.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
     ContractParameterDefinitionType
-from boa3.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
-from boa3.model.builtin.interop.contract.contractmanifest.contractpermissiondescriptortype import \
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractpermissiondescriptortype import \
     ContractPermissionDescriptorType
-from boa3.model.builtin.interop.contract.contractmanifest.contractpermissiontype import ContractPermissionType
+from boa3.internal.model.builtin.interop.contract.contractmanifest.contractpermissiontype import ContractPermissionType
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractabitype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractabitype.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,45 +1,53 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
 
 class ContractAbiType(ClassStructType):
     """
     A class used to represent Neo ContractAbi class
     """
 
     def __init__(self):
         super().__init__('ContractAbi')
-        from boa3.model.builtin.interop.contract.contractmanifest.contractmethoddescriptortype import \
+        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractmethoddescriptortype import \
             ContractMethodDescriptorType
-        from boa3.model.builtin.interop.contract.contractmanifest.contracteventdescriptortype import \
+        from boa3.internal.model.builtin.interop.contract.contractmanifest.contracteventdescriptortype import \
             ContractEventDescriptorType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
 
         self._variables: Dict[str, Variable] = {
             'methods': Variable(Type.list.build_collection(ContractMethodDescriptorType.build())),
             'events': Variable(Type.list.build_collection(ContractEventDescriptorType.build()))
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contracteventdescriptortype.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,43 +1,51 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
 
 class ContractEventDescriptorType(ClassStructType):
     """
     A class used to represent Neo ContractEventDescriptor class
     """
 
     def __init__(self):
         super().__init__('ContractEventDescriptor')
-        from boa3.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
+        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
             ContractParameterDefinitionType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
 
         self._variables: Dict[str, Variable] = {
             'name': Variable(Type.str),
             'parameters': Variable(Type.list.build_collection(ContractParameterDefinitionType.build()))
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractgrouptype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractgrouptype.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,50 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
 
 class ContractGroupType(ClassStructType):
     """
     A class used to represent Neo ContractGroup class
     """
 
     def __init__(self):
         super().__init__('ContractGroup')
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.type import Type
 
         self._variables: Dict[str, Variable] = {
             'pubkey': Variable(ECPointType.build()),
             'signature': Variable(Type.bytes)
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmanifesttype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,47 +1,55 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
 
 class ContractManifestType(ClassStructType):
     """
     A class used to represent Neo ContractManifest class
     """
 
     def __init__(self):
         super().__init__('ContractManifest')
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
 
         self._variables: Dict[str, Variable] = {
             'name': Variable(Type.str),
             'groups': Variable(Type.list),
             '-features': Variable(Type.dict),  # TODO: rename this variable when features are implemented in neo3-boa
             'supported_standards': Variable(Type.list.build_collection([Type.str])),
             'abi': Variable(Type.any),
             'permissions': Variable(Type.list),
             'trusts': Variable(Type.optional.build(Type.list)),
             'extras': Variable(Type.str)
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractmethoddescriptortype.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,47 +1,55 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
 
 class ContractMethodDescriptorType(ClassStructType):
     """
     A class used to represent Neo ContractMethodDescriptor class
     """
 
     def __init__(self):
         super().__init__('ContractMethodDescriptor')
-        from boa3.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
+        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparameterdefinitiontype import \
             ContractParameterDefinitionType
-        from boa3.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
+        from boa3.internal.model.type.type import Type
 
         self._variables: Dict[str, Variable] = {
             'name': Variable(Type.str),
             'parameters': Variable(Type.list.build_collection(ContractParameterDefinitionType.build())),
             'return_type': Variable(ContractParameterType.build()),
             'offset': Variable(Type.int),
             'safe': Variable(Type.bool)
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/exceptionmethod.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,56 +1,70 @@
-from __future__ import annotations
+import ast
+from typing import Any, Dict, List, Optional, Tuple
 
-from typing import Any, Dict, Optional
-
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
-
-
-class ContractParameterDefinitionType(ClassStructType):
-    """
-    A class used to represent Neo ContractParameterDefinition class
-    """
-
-    def __init__(self):
-        super().__init__('ContractParameterDefinition')
-        from boa3.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
-        from boa3.model.type.type import Type
-
-        self._variables: Dict[str, Variable] = {
-            'name': Variable(Type.str),
-            'type': Variable(ContractParameterType.build())
-        }
-        self._constructor: Method = None
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+
+
+class ExceptionMethod(IBuiltinMethod):
+
+    def __init__(self, argument_type: IType = None):
+        from boa3.internal.model.type.type import Type
+        if argument_type is None or not self.validate_parameters(argument_type):
+            argument_type = Type.str
+
+        identifier = '-Exception'
+        args: Dict[str, Variable] = {'message': Variable(argument_type)}
+        default_message = "'{0}'".format(self.default_message) if argument_type is Type.str else "{0}"
+        default = ast.parse(default_message.format(argument_type.default_value)
+                            ).body[0].value
+        super().__init__(identifier, args, [default], return_type=Type.exception)
 
     @property
-    def variables(self) -> Dict[str, Variable]:
-        return self._variables.copy()
+    def _arg_message(self) -> Variable:
+        return self.args['message']
 
     @property
-    def properties(self) -> Dict[str, Property]:
-        return {}
+    def default_message(self) -> str:
+        return 'usererror'
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
+    def identifier(self) -> str:
+        return self._identifier
 
-    @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
+    def validate_parameters(self, *params: IExpression) -> bool:
+        if len(params) > 1:
+            return False
+        if len(params) == 0:
+            return True
+
+        from boa3.internal.model.type.itype import IType
+        if not isinstance(params[0], (IExpression, IType)):
+            return False
 
-    def constructor_method(self) -> Optional[Method]:
-        return self._constructor
+        param_type: IType = params[0].type if isinstance(params[0], IExpression) else params[0]
+        return isinstance(param_type, PrimitiveType)
 
-    @classmethod
-    def build(cls, value: Any = None) -> ContractParameterDefinitionType:
-        if value is None or cls._is_type_of(value):
-            return _ContractParameterDefinition
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return []
 
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return isinstance(value, ContractParameterDefinitionType)
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
+    @property
+    def _body(self) -> Optional[str]:
+        return
 
-_ContractParameterDefinition = ContractParameterDefinitionType()
+    def build(self, value: Any) -> IBuiltinMethod:
+        if type(value) == type(self._arg_message.type):
+            return self
+        if isinstance(value, list):
+            value = value[0] if len(value) > 0 else None
+        if self.validate_parameters(value):
+            return ExceptionMethod(value)
+        return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractparametertype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparametertype.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,57 +1,61 @@
 from typing import Any, Dict
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class ContractParameterType(IntType):
     """
     A class used to represent Neo interop ContractParameterType type
     """
 
     def __init__(self):
         super().__init__()
         self._identifier = 'ContractParameterType'
 
     @property
     def default_value(self) -> Any:
-        from boa3.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
+        from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
         return ContractParameter.ALL
 
     @classmethod
     def build(cls, value: Any = None) -> IType:
         if value is None or cls._is_type_of(value):
             return _ContractParameterType
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        from boa3.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
+        from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
         return isinstance(value, (ContractParameter, ContractParameterType))
 
     @property
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
-        from boa3.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
-        from boa3.model.variable import Variable
+        from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
+        from boa3.internal.model.variable import Variable
 
-        return {name: Variable(self) for name in ContractParameter.__members__.keys()}
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in ContractParameter.__members__.keys()})
+
+        return _symbols
 
     def get_value(self, symbol_id) -> Any:
         """
         Gets the literal value of a symbol
 
         :return: the value if this type has this symbol. None otherwise.
         """
-        if symbol_id in self.symbols:
-            from boa3.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
+        from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType as ContractParameter
+
+        if symbol_id in self.symbols and symbol_id in ContractParameter.__members__:
             return ContractParameter.__members__[symbol_id]
 
         return None
 
 
 _ContractParameterType = ContractParameterType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiondescriptortype.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,43 +1,51 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classstructtype import ClassStructType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
 
 class ContractPermissionDescriptorType(ClassStructType):
     """
     A class used to represent Neo ContractPermissionDescriptor class
     """
 
     def __init__(self):
         super().__init__('ContractPermissionDescriptor')
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.type import Type
 
         self._variables: Dict[str, Variable] = {
             'hash': Variable(Type.optional.build(UInt160Type.build())),
             'group': Variable(Type.optional.build(ECPointType.build()))
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/genericcollectiontype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,55 +1,48 @@
-from __future__ import annotations
+from typing import Any, Set
 
-from typing import Any, Dict, Optional
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.itype import IType
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.variable import Variable
 
-
-class ContractPermissionType(ClassArrayType):
+class GenericCollectionType(ICollectionType):
     """
-    A class used to represent Neo ContractPermission class
+    An class used to represent a generic Python collection type
     """
 
-    def __init__(self):
-        super().__init__('ContractPermission')
-        from boa3.model.type.type import Type
-
-        self._variables: Dict[str, Variable] = {
-            'contract': Variable(Type.str),
-            'methods': Variable(Type.optional.build(Type.list.build_collection([Type.str])))
-        }
-        self._constructor: Method = None
-
-    @property
-    def variables(self) -> Dict[str, Variable]:
-        return self._variables.copy()
+    def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
+        identifier: str = 'collection'
+        keys_type = self.filter_types(keys_type)
+        values_type = self.filter_types(values_type)
+        super().__init__(identifier, keys_type, values_type)
 
-    @property
-    def properties(self) -> Dict[str, Property]:
-        return {}
+    def is_valid_key(self, key_type: IType) -> bool:
+        return key_type == self.valid_key
 
     @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
+    def valid_key(self) -> IType:
+        return self.key_type
 
     @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
-
-    def constructor_method(self) -> Optional[Method]:
-        return self._constructor
-
-    @classmethod
-    def build(cls, value: Any = None) -> ContractPermissionType:
-        if value is None or cls._is_type_of(value):
-            return _ContractPermission
+    def is_generic(self) -> bool:
+        return True
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, ContractPermissionType)
+        return isinstance(value, ICollectionType)
 
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            if isinstance(value, dict):
+                keys = list(value.keys())
+                values = list(value.values())
+            else:
+                keys = value.key_type
+                values = value.value_type
+
+            keys_types: Set[IType] = cls.get_types(keys)
+            values_types: Set[IType] = cls.get_types(values)
+            return cls(keys_types, values_types)
 
-_ContractPermission = ContractPermissionType()
+    def __hash__(self):
+        return hash(self.identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/contracttype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contracttype.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,49 +1,58 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal import constants
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ContractType(ClassArrayType):
     """
     A class used to represent Neo Contract class
     """
 
     def __init__(self):
         super().__init__('Contract')
-        from boa3.model.builtin.interop.contract.contractmanifest import ContractManifestType
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.builtin.interop.contract.contractmanifest import ContractManifestType
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
         self._variables: Dict[str, Variable] = {
             'id': Variable(Type.int),
             'update_counter': Variable(Type.int),
             'hash': Variable(UInt160Type.build()),
             'nef': Variable(Type.bytes),
             'manifest': Variable(ContractManifestType.build())
         }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
 
@@ -73,20 +82,23 @@
         args: Dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+
+        uint160_default = Integer(constants.SIZE_OF_INT160).to_byte_array() + bytes(constants.SIZE_OF_INT160)
+
         return [
             (Opcode.NEWMAP, b''),
             (Opcode.PUSHDATA1, Integer(0).to_byte_array()),
-            (Opcode.PUSHDATA1, Integer(20).to_byte_array() + bytes(20)),
+            (Opcode.PUSHDATA1, uint160_default),
             (Opcode.PUSH0, b''),
             (Opcode.PUSH0, b''),
             (Opcode.PUSH5, b''),
             (Opcode.PACK, b'')
         ]
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/createmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/createmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 import ast
 from typing import Dict
 
-from boa3.model.builtin.interop.contract.contracttype import ContractType
-from boa3.model.builtin.interop.nativecontract import ContractManagementMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.contract.contracttype import ContractType
+from boa3.internal.model.builtin.interop.nativecontract import ContractManagementMethod
+from boa3.internal.model.variable import Variable
 
 
 class CreateMethod(ContractManagementMethod):
 
     def __init__(self, contract_type: ContractType):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'create_contract'
         syscall = 'deploy'
         args: Dict[str, Variable] = {
             'nef_file': Variable(Type.bytes),
             'manifest': Variable(Type.bytes),
             'data': Variable(Type.any)
         }
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/createmultisigaccountmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/createstandardaccountmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,20 +1,18 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
-class CreateMultisigAccountMethod(InteropMethod):
+class CreateStandardAccountMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        identifier = 'create_multisig_account'
-        syscall = 'System.Contract.CreateMultisigAccount'
+        identifier = 'create_standard_account'
+        syscall = 'System.Contract.CreateStandardAccount'
         args: Dict[str, Variable] = {
-            'm': Variable(Type.int),
-            'pub_keys': Variable(Type.list.build_collection([ECPointType.build()]))
+            'pub_key': Variable(ECPointType.build())
         }
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/createstandardaccountmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/createmultisigaccountmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
-class CreateStandardAccountMethod(InteropMethod):
+class CreateMultisigAccountMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.type import Type
 
-        identifier = 'create_standard_account'
-        syscall = 'System.Contract.CreateStandardAccount'
+        identifier = 'create_multisig_account'
+        syscall = 'System.Contract.CreateMultisigAccount'
         args: Dict[str, Variable] = {
-            'pub_key': Variable(ECPointType.build())
+            'm': Variable(Type.int),
+            'pub_keys': Variable(Type.list.build_collection([ECPointType.build()]))
         }
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getcallflagsmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/getcallflagsmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.contract.callflagstype import CallFlagsType
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.contract.callflagstype import CallFlagsType
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetCallFlagsMethod(InteropMethod):
 
     def __init__(self, call_flags_type: CallFlagsType):
         identifier = 'get_call_flags'
         syscall = 'System.Contract.GetCallFlags'
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getgasscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/uint160type.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,39 +1,60 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Any, List, Optional, Tuple
 
-from boa3.constants import GAS_SCRIPT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal import constants
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class GetGasScriptHashMethod(IBuiltinMethod):
+class UInt160Type(BytesType):
+    """
+    A class used to represent Neo's UInt160 type
+    """
+
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_gas'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+        super().__init__()
+        self._identifier = 'UInt160'
+        from boa3.internal.model.builtin.method.uint160method import UInt160Method
+        self._constructor = UInt160Method(self)
 
     @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+    def identifier(self) -> str:
+        return self._identifier
 
     @property
-    def _body(self) -> Optional[str]:
-        return None
+    def abi_type(self) -> AbiType:
+        return AbiType.Hash160
+
+    def constructor_method(self) -> Optional[Method]:
+        return self._constructor
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def default_value(self) -> Any:
+        return bytes(constants.SIZE_OF_INT160)
+
+    @classmethod
+    def build(cls, value: Any = None) -> IType:
+        return _UInt160
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, UInt160Type)
+
+    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        return super(PythonClass, self).is_instance_opcodes()
+
+    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
+        push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_INT160)
 
-        value = GAS_SCRIPT
         return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
+            (Opcode.SIZE, b''),  # return len(value) == 20
+            (push_int_opcode, size_data),
+            (Opcode.NUMEQUAL, b'')
         ]
 
 
-class GasProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'GAS'
-        getter = GetGasScriptHashMethod()
-        super().__init__(identifier, getter)
+_UInt160 = UInt160Type()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/getneoscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/math/powmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,39 +1,37 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.constants import NEO_SCRIPT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class GetNeoScriptHashMethod(IBuiltinMethod):
+class PowMethod(IBuiltinMethod):
+
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_neo'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+        from boa3.internal.model.type.type import Type
+        identifier = 'pow'
+        args: Dict[str, Variable] = {
+            'base': Variable(Type.int),
+            'exponent': Variable(Type.int),
+        }
+        super().__init__(identifier, args, return_type=Type.int)
 
     @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+    def requires_reordering(self) -> bool:
+        return True
 
-    @property
-    def _body(self) -> Optional[str]:
-        return None
+    def reorder(self, arguments: list):
+        # swap base and exponent  positions
+        arguments[0], arguments[1] = arguments[1], arguments[0]
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-
-        value = NEO_SCRIPT
-        return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
-        ]
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.POW, b'')]
 
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
-class NeoProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'NEO'
-        getter = GetNeoScriptHashMethod()
-        super().__init__(identifier, getter)
+    @property
+    def _body(self) -> Optional[str]:
+        return
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/contract/updatemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/itoamethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 import ast
 from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract import ContractManagementMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.variable import Variable
 
 
-class UpdateMethod(ContractManagementMethod):
+class ItoaMethod(StdLibMethod):
 
-    def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'update_contract'
-        syscall = 'update'
+    def __init__(self, internal_call_args: int = None):
+        from boa3.internal.model.type.type import Type
+        identifier = 'itoa'
+        syscall = 'itoa'
         args: Dict[str, Variable] = {
-            'nef_file': Variable(Type.bytes),
-            'manifest': Variable(Type.bytes),
-            'data': Variable(Type.any)
+            'value': Variable(Type.int),
+            'base': Variable(Type.int)
         }
-        data_default = ast.parse("{0}".format(Type.any.default_value)
-                                 ).body[0].value
-        super().__init__(identifier, syscall, args, defaults=[data_default], return_type=Type.none)
+        args_default = ast.parse("{0}".format(10)).body[0].value
+
+        super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.str,
+                         internal_call_args=internal_call_args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/checkmultisigmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/checkmultisigmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class CheckMultisigMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
         identifier = 'check_multisig'
         syscall = 'System.Crypto.CheckMultisig'
         args: Dict[str, Variable] = {
             'pubkeys': Variable(Type.list.build_collection([ECPointType.build()])),
             'signatures': Variable(Type.list.build_collection([Type.bytes]))
         }
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/checksigmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getcallingscripthashmethod.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,19 +1,21 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
-class CheckSigMethod(InteropMethod):
-
+class GetCallingScriptHashMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        identifier = '-get_calling_script_hash'
+        syscall = 'System.Runtime.GetCallingScriptHash'
+        args: Dict[str, Variable] = {}
+        super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
+
 
-        identifier = 'check_sig'
-        syscall = 'System.Crypto.CheckSig'
-        args: Dict[str, Variable] = {
-            'pubkeys': Variable(ECPointType.build()),
-            'signatures': Variable(Type.bytes)
-        }
-        super().__init__(identifier, syscall, args, return_type=Type.bool)
+class CallingScriptHashProperty(IBuiltinProperty):
+    def __init__(self):
+        identifier = 'calling_script_hash'
+        getter = GetCallingScriptHashMethod()
+        super().__init__(identifier, getter)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/hash160method.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,24 +1,41 @@
-from typing import Dict, List, Tuple
+from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.interop.nativecontract import CryptoLibMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Hash160Method(CryptoLibMethod):
+class StorageMapDeleteMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'hash160'
-        native_identifier = ''  # hash160 is not neo native
-        args: Dict[str, Variable] = {'key': Variable(Type.any)}
-        super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
+        from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
+        from boa3.internal.model.type.type import Type
+
+        identifier = 'delete'
+        args: Dict[str, Variable] = {'self': Variable(_StorageMap),
+                                     'key': Variable(Type.bytes)}
+
+        super().__init__(identifier, args, return_type=Type.none)
+
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
+
+    @property
+    def _body(self) -> Optional[str]:
+        return None
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.builtin.interop.interop import Interop
-        return (Interop.Sha256.opcode
-                + [(Opcode.PUSH1, b''),
-                   (Opcode.PACK, b'')
-                   ]
-                + Interop.Ripemd160.opcode)
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.builtin.interop.interop import Interop
+        return [
+            (Opcode.SWAP, b''),
+            (Opcode.OVER, b''),
+            (Opcode.PUSH1, b''),
+            (Opcode.PICKITEM, b''),
+            (Opcode.SWAP, b''),
+            (Opcode.CAT, b''),
+            (Opcode.SWAP, b''),
+            (Opcode.PUSH0, b''),
+            (Opcode.PICKITEM, b''),
+        ] + Interop.StorageDelete.opcode
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/crypto/hash256method.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/crypto/verifywithecdsa.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-from typing import Dict, List, Tuple
+from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract import CryptoLibMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.interop.nativecontract import CryptoLibMethod
+from boa3.internal.model.variable import Variable
 
 
-class Hash256Method(CryptoLibMethod):
+class VerifyWithECDsaMethod(CryptoLibMethod):
+
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'hash256'
-        native_identifier = ''  # hash256 is not neo native
-        args: Dict[str, Variable] = {'key': Variable(Type.any)}
-        super().__init__(identifier, native_identifier, args, return_type=Type.bytes)
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.builtin.interop.crypto.namedcurvetype import NamedCurveType
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.builtin.interop.interop import Interop
-        return (Interop.Sha256.opcode
-                + [(Opcode.PUSH1, b''),
-                   (Opcode.PACK, b'')
-                   ]
-                + Interop.Sha256.opcode)
+        identifier = 'verify_with_ecdsa'
+        native_identifier = 'verifyWithECDsa'
+        args: Dict[str, Variable] = {
+            'data': Variable(Type.bytes),
+            'pubkey': Variable(ECPointType.build()),
+            'signature': Variable(Type.bytes),
+            'curve': Variable(NamedCurveType.build())
+        }
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/interopevent.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/strintmethod.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,30 +1,21 @@
-import ast
-from abc import ABC
 from typing import Dict, List, Tuple
 
-from boa3.model.builtin.method.builtinevent import IBuiltinEvent
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.interop.stdlib import ItoaMethod
+from boa3.internal.model.builtin.method.strmethod import StrMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class InteropEvent(IBuiltinEvent, ABC):
+class StrIntMethod(StrMethod):
 
-    def __init__(self, identifier: str, sys_call: str,
-                 args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
-        self._sys_call: str = sys_call
-        super().__init__(identifier, args, defaults)
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        args: Dict[str, Variable] = {
+            'object': Variable(Type.int),
+        }
 
-    @property
-    def interop_method_hash(self) -> bytes:
-        return self._method_hash(self._sys_call)
-
-    def _method_hash(self, method_name: str) -> bytes:
-        from boa3.constants import SIZE_OF_INT32
-        from boa3.neo import cryptography
-        from boa3.neo.vm.type.String import String
-
-        return cryptography.sha256(String(method_name).to_bytes())[:SIZE_OF_INT32]
+        super().__init__(args)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.SYSCALL, self.interop_method_hash)]
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return ItoaMethod(internal_call_args=1).opcode
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/interopinterfacetype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interopinterfacetype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from abc import ABC
 
-from boa3.model.type.classes.classtype import ClassType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class InteropInterfaceType(ClassType, ABC):
     """
     An abstract class used to represent a Python class that is implemented internally as a Neo Interop Interface
     """
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/interopmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interopmethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import ast
 from abc import ABC
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class InteropMethod(IBuiltinMethod, ABC):
 
     def __init__(self, identifier: str, sys_call: str, args: Dict[str, Variable] = None,
                  defaults: List[ast.AST] = None, return_type: IType = None):
         self._sys_call: str = sys_call
@@ -26,22 +26,22 @@
         return all(args[index].is_type_of(params[index]) for index in range(len(args)))
 
     @property
     def interop_method_hash(self) -> bytes:
         return self._method_hash(self._sys_call)
 
     def _method_hash(self, method_name: str) -> bytes:
-        from boa3.constants import SIZE_OF_INT32
-        from boa3.neo import cryptography
-        from boa3.neo.vm.type.String import String
+        from boa3.internal.constants import SIZE_OF_INT32
+        from boa3.internal.neo import cryptography
+        from boa3.internal.neo.vm.type.String import String
 
         return cryptography.sha256(String(method_name).to_bytes())[:SIZE_OF_INT32]
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [(Opcode.SYSCALL, self.interop_method_hash)]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/getiteratorvalue.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/getiteratorvalue.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,42 @@
 from typing import Dict, List, Tuple
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.interop.iterator.iteratortype import IteratorType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class GetIteratorValue(InteropMethod):
     def __init__(self, iterator: IteratorType):
         syscall = 'System.Iterator.Value'
         identifier = '-get_iterator_value'
         args: Dict[str, Variable] = {'self': Variable(iterator)}
 
         result_type = iterator.item_type
-        from boa3.model.type.collection.mapping.mappingtype import MappingType
+        from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
         if isinstance(iterator._origin_collection, MappingType):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             result_type = Type.tuple.build((iterator.key_type, iterator.item_type))
         super().__init__(identifier, syscall, args, return_type=result_type)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def self_arg(self) -> Variable:
         return self.args['self']
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.StackItem import StackItemType
-        from boa3.neo.vm.type.Integer import Integer
-        return super().opcode + [
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.StackItem import StackItemType
+        from boa3.internal.neo.vm.type.Integer import Integer
+        return super()._opcode + [
             (Opcode.DUP, b''),
             (Opcode.ISTYPE, StackItemType.Struct),
             (Opcode.JMPIFNOT, Integer(3).to_byte_array()),
             (Opcode.CONVERT, StackItemType.Array),
         ]
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/iteratorinitmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/iteratorinitmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 from typing import Any, Dict, Optional, Sequence
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.interop.iterator.iteratortype import IteratorType
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.iterator.iteratortype import IteratorType
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.variable import Variable
 
 
 class IteratorMethod(InteropMethod):
 
     def __init__(self, return_type: IteratorType):
         identifier = '-Iterator__init__'
         syscall = 'System.Iterator.Create'
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         args: Dict[str, Variable] = {'entry': Variable(Type.collection)}
         super().__init__(identifier, syscall, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/iterator/iteratortype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/iterator/iteratortype.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,29 +1,28 @@
 from __future__ import annotations
 
-from typing import Any, Dict, Optional
+from typing import Any, List, Optional, Tuple
 
-from boa3.model.builtin.interop.interopinterfacetype import InteropInterfaceType
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopinterfacetype import InteropInterfaceType
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IteratorType(InteropInterfaceType, ICollectionType):
     """
     A class used to represent Neo Iterator class
     """
 
     def __init__(self, collection: ICollectionType = None):
         super().__init__('Iterator')
 
         if collection is None:
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             collection = Type.collection
 
         self._constructor: Method = None
         self._origin_collection: ICollectionType = collection
 
         self._methods = None
         self._properties = None
@@ -31,42 +30,14 @@
         self.key_type = self._origin_collection.valid_key
         self.item_type = self._origin_collection.item_type
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}, {2}]'.format(self._identifier, self.valid_key.identifier, self.item_type.identifier)
 
-    @property
-    def variables(self) -> Dict[str, Variable]:
-        return {}
-
-    @property
-    def properties(self) -> Dict[str, Property]:
-        if self._properties is None:
-            from boa3.model.builtin.interop.iterator.getiteratorvalue import IteratorValueProperty
-            self._properties = {
-                'value': IteratorValueProperty(self)
-            }
-
-        return self._properties.copy()
-
-    @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
-
-    @property
-    def instance_methods(self) -> Dict[str, Method]:
-        if self._methods is None:
-            from boa3.model.builtin.interop.iterator.iteratornextmethod import IteratorNextMethod
-
-            self._methods = {
-                'next': IteratorNextMethod()
-            }
-        return self._methods.copy()
-
     def constructor_method(self) -> Optional[Method]:
         return self._constructor
 
     @property
     def value_type(self) -> IType:
         return self._origin_collection.item_type
 
@@ -84,14 +55,28 @@
         else:
             return _Iterator
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return isinstance(value, IteratorType)
 
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+
+        from boa3.internal.model.builtin.interop.iterator.iteratornextmethod import IteratorNextMethod
+        from boa3.internal.model.builtin.interop.iterator.getiteratorvalue import IteratorValueProperty
+
+        self._instance_methods['next'] = IteratorNextMethod()
+
+        self._properties['value'] = IteratorValueProperty(self)
+
+    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        return super(PythonClass, self).is_instance_opcodes()
+
     def __eq__(self, other) -> bool:
         if not isinstance(other, IteratorType):
             return False
         return self.valid_key == other.valid_key and self.value_type == other.value_type
 
     def __hash__(self) -> int:
         return self._origin_collection.__hash__()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 import ast
 from typing import Dict, List
 
-from boa3.model.builtin.interop.nativecontract.ContractManagement.getcontractmanagementscripthashmethod import \
-    ContractManagement
-from boa3.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract.PolicyContract.getpolicycontractscripthashmethod import PolicyContract
+from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
-class ContractManagementMethod(NativeContractMethod):
+class PolicyContractMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(ContractManagement.getter, identifier, syscall, args, defaults, return_type)
+    def __init__(self, identifier: str, native_identifier: str, args: Dict[str, Variable] = None,
+                 defaults: List[ast.AST] = None, return_type: IType = None,
+                 internal_call_args: int = None):
+        super().__init__(PolicyContract.getter, identifier, native_identifier,
+                         args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/getcryptolibscripthashmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,42 +1,32 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Dict, Optional
 
-from boa3.constants import MANAGEMENT_SCRIPT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetContractManagementScriptHashMethod(IBuiltinMethod):
+class GetCryptoLibScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_management_contract'
+        from boa3.internal.constants import CRYPTO_SCRIPT
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        identifier = '-get_crypto_lib_contract'
         args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+        super().__init__(CRYPTO_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-
-        value = MANAGEMENT_SCRIPT
-        return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
-        ]
-
 
-class ContractManagementProperty(IBuiltinProperty):
+class CryptoLibContractProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'ManagementContract'
-        getter = GetContractManagementScriptHashMethod()
+        identifier = 'CryptoLib'
+        getter = GetCryptoLibScriptHashMethod()
         super().__init__(identifier, getter)
 
 
-ContractManagement = ContractManagementProperty()
+CryptoLibContract = CryptoLibContractProperty()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Ledger/getledgerscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/type/classes/contractinterfacehash.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,42 +1,27 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Dict, Optional
 
-from boa3.constants import LEDGER_SCRIPT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
+from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+from boa3.internal.model.variable import Variable
 
 
-class GetLedgerScriptHashMethod(IBuiltinMethod):
-    def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_ledger_contract'
+class ContractInterfaceGetScriptHashMethod(ContractGetHashMethod):
+    def __init__(self, identifier: str, contract_script: bytes):
+        identifier = f'-get_{identifier}'
         args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+        super().__init__(contract_script, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-
-        value = LEDGER_SCRIPT
-        return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
-        ]
-
 
-class LedgerContractProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'LedgerContract'
-        getter = GetLedgerScriptHashMethod()
+class ContractHashProperty(IBuiltinProperty):
+    def __init__(self, identifier: str, contract_script: bytes):
+        getter = ContractInterfaceGetScriptHashMethod(identifier, contract_script)
         super().__init__(identifier, getter)
-
-
-LedgerContract = LedgerContractProperty()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Oracle/getoraclescripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/getcontractmanagementscripthashmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,42 +1,32 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Dict, Optional
 
-from boa3.constants import ORACLE_SCRIPT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetOracleScriptHashMethod(IBuiltinMethod):
+class GetContractManagementScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_oracle_contract'
+        from boa3.internal.constants import MANAGEMENT_SCRIPT
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        identifier = '-get_management_contract'
         args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+        super().__init__(MANAGEMENT_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-
-        value = ORACLE_SCRIPT
-        return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
-        ]
-
 
-class OracleProperty(IBuiltinProperty):
+class ContractManagementProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'Oracle'
-        getter = GetOracleScriptHashMethod()
+        identifier = 'ManagementContract'
+        getter = GetContractManagementScriptHashMethod()
         super().__init__(identifier, getter)
 
 
-OracleContract = OracleProperty()
+ContractManagement = ContractManagementProperty()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/Oracle/oraclemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/Neo/neocontractmethod.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,14 +1,16 @@
 import ast
 from typing import Dict, List
 
-from boa3.model.builtin.interop.nativecontract.Oracle.getoraclescripthashmethod import OracleContract
-from boa3.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract.Neo.getneoscripthashmethod import NeoContract
+from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
-class OracleMethod(NativeContractMethod):
+class NeoContractMethod(NativeContractMethod):
 
-    def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(OracleContract.getter, identifier, syscall, args, defaults, return_type)
+    def __init__(self, identifier: str, native_identifier: str, args: Dict[str, Variable] = None,
+                 defaults: List[ast.AST] = None, return_type: IType = None,
+                 internal_call_args: int = None):
+        super().__init__(NeoContract.getter, identifier, native_identifier,
+                         args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/lenmethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,42 +1,50 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Any, Dict, List, Optional, Sized, Tuple
 
-from boa3.constants import POLICY_SCRIPT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+
+
+class LenMethod(IBuiltinMethod):
+
+    def __init__(self, collection_type: IType = None):
+        from boa3.internal.model.type.type import Type
+        if not isinstance(collection_type, ICollectionType):
+            collection_type = Type.sequence
+
+        identifier = 'len'
+        args: Dict[str, Variable] = {'__o': Variable(collection_type)}
+        super().__init__(identifier, args, return_type=Type.int)
+
+    def validate_parameters(self, *params: IExpression) -> bool:
+        if len(params) != 1:
+            return False
+        if not isinstance(params[0], IExpression):
+            return False
+        return isinstance(params[0].type, SequenceType)
 
-
-class GetPolicyContractScriptHashMethod(IBuiltinMethod):
-    def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_policy_contract'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.SIZE, b'')]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-
-        value = POLICY_SCRIPT
-        return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
-        ]
-
-
-class PolicyContractProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'PolicyContract'
-        getter = GetPolicyContractScriptHashMethod()
-        super().__init__(identifier, getter)
-
-
-PolicyContract = PolicyContractProperty()
+    def build(self, value: Any) -> IBuiltinMethod:
+        if type(value) == type(self.args['__o'].type):
+            return self
+
+        if isinstance(value, Sized) and len(value) == 1:
+            value = value[0]
+        if isinstance(value, ICollectionType):
+            return LenMethod(value)
+        return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/PolicyContract/policycontractmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/getaccountstatemethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,14 +1,18 @@
-import ast
-from typing import Dict, List
+from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract.PolicyContract.getpolicycontractscripthashmethod import PolicyContract
-from boa3.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.contract import NeoAccountStateType
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.variable import Variable
 
 
-class PolicyContractMethod(NativeContractMethod):
+class GetAccountStateMethod(NeoContractMethod):
 
-    def __init__(self, identifier: str, native_identifier: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(PolicyContract.getter, identifier, native_identifier, args, defaults, return_type)
+    def __init__(self, neo_account_state: NeoAccountStateType):
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'get_account_state'
+        native_identifier = 'getAccountState'
+        args: Dict[str, Variable] = {
+            'account': Variable(UInt160Type.build())
+        }
+        super().__init__(identifier, native_identifier, args, return_type=neo_account_state)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/RoleManagement/getrolemanagementscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/PolicyContract/getpolicycontractscripthashmethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,42 +1,32 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Dict, Optional
 
-from boa3.constants import ROLE_MANAGEMENT
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.contractgethashmethod import ContractGetHashMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetRoleManagementScriptHashMethod(IBuiltinMethod):
+class GetPolicyContractScriptHashMethod(ContractGetHashMethod):
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_role-management'
+        from boa3.internal.constants import POLICY_SCRIPT
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        identifier = '-get_policy_contract'
         args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=UInt160Type.build())
+        super().__init__(POLICY_SCRIPT, identifier, args, return_type=UInt160Type.build())
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-
-        value = ROLE_MANAGEMENT
-        return [
-            (Opcode.PUSHDATA1, Integer(len(value)).to_byte_array() + value)
-        ]
-
 
-class RoleManagementProperty(IBuiltinProperty):
+class PolicyContractProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'RoleManagement'
-        getter = GetRoleManagementScriptHashMethod()
+        identifier = 'PolicyContract'
+        getter = GetPolicyContractScriptHashMethod()
         super().__init__(identifier, getter)
 
 
-RoleManagement = RoleManagementProperty()
+PolicyContract = PolicyContractProperty()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/RoleManagement/rolemanagementmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/ContractManagement/contractmanagementmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 import ast
 from typing import Dict, List
 
-from boa3.model.builtin.interop.nativecontract.RoleManagement.getrolemanagementscripthashmethod import \
-    RoleManagement
-from boa3.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract.ContractManagement.getcontractmanagementscripthashmethod import \
+    ContractManagement
+from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
-class RoleManagementMethod(NativeContractMethod):
+class ContractManagementMethod(NativeContractMethod):
 
     def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(RoleManagement.getter, identifier, syscall, args, defaults, return_type)
+                 defaults: List[ast.AST] = None, return_type: IType = None,
+                 internal_call_args: int = None):
+        super().__init__(ContractManagement.getter, identifier, syscall,
+                         args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/nativecontract/StdLib/stdlibmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/nativecontract/CryptoLib/cryptolibmethod.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import ast
 from typing import Dict, List
 
-from boa3.model.builtin.interop.nativecontract.StdLib.getstdlibscripthashmethod import StdLibContract
-from boa3.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract.CryptoLib.getcryptolibscripthashmethod import CryptoLibContract
+from boa3.internal.model.builtin.interop.nativecontract.nativecontractmethod import NativeContractMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
-class StdLibMethod(NativeContractMethod):
+class CryptoLibMethod(NativeContractMethod):
 
     def __init__(self, identifier: str, syscall: str, args: Dict[str, Variable] = None,
-                 defaults: List[ast.AST] = None, return_type: IType = None):
-        super().__init__(StdLibContract.getter, identifier, syscall, args, defaults, return_type)
+                 defaults: List[ast.AST] = None, return_type: IType = None,
+                 internal_call_args: int = None):
+        super().__init__(CryptoLibContract.getter, identifier, syscall, args, defaults, return_type, internal_call_args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oraclegetpricemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/absmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,23 +1,25 @@
-from typing import Dict, Optional
+from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.interop.nativecontract import OracleMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class OracleGetPriceMethod(OracleMethod):
+class AbsMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
+        identifier = 'abs'
+        args: Dict[str, Variable] = {'val': Variable(Type.int)}
+        super().__init__(identifier, args, return_type=Type.int)
 
-        identifier = 'get_price'
-        syscall = 'getPrice'
-        args: Dict[str, Variable] = {}
-
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.ABS, b'')]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oraclerequestmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/oraclerequestmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from typing import Dict, Optional
 
-from boa3.model.builtin.interop.nativecontract import OracleMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import OracleMethod
+from boa3.internal.model.variable import Variable
 
 
 class OracleRequestMethod(OracleMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
 
         identifier = 'request'
         syscall = 'request'
         args: Dict[str, Variable] = {'url': Variable(Type.str),
                                      'request_filter': Variable(Type.union.build([Type.str,
                                                                                   Type.none])),
                                      'callback': Variable(Type.str),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oracleresponsecodetype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/oracleresponsecodetype.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, Dict
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class OracleResponseCodeType(IntType):
     """
     A class used to represent Neo's OracleResponseCode.
     """
 
@@ -28,25 +28,29 @@
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets the class symbols of this type.
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.role.roletype import Role
-        from boa3.model.variable import Variable
+        from boa3.internal.model.variable import Variable
 
-        return {name: Variable(self) for name in Role.__members__.keys()}
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in Role.__members__.keys()})
+
+        return _symbols
 
     def get_value(self, symbol_id) -> Any:
         """
         Gets the literal value of a symbol.
 
         :return: the value if this type has this symbol. None otherwise
         """
-        if symbol_id in self.symbols:
-            from boa3.builtin.interop.oracle.oracleresponsecode import OracleResponseCode
+        from boa3.builtin.interop.oracle.oracleresponsecode import OracleResponseCode
+
+        if symbol_id in self.symbols and symbol_id in OracleResponseCode.__members__:
             return OracleResponseCode.__members__[symbol_id]
 
         return None
 
 
 _OracleResponseCode = OracleResponseCodeType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/oracle/oracletype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractpermissiontype.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,61 +1,63 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.variable import Variable
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.variable import Variable
 
 
-class OracleType(ClassArrayType):
+class ContractPermissionType(ClassArrayType):
     """
-    A class used to represent Oracle class
+    A class used to represent Neo ContractPermission class
     """
 
     def __init__(self):
-        super().__init__('Oracle')
+        super().__init__('ContractPermission')
+        from boa3.internal.model.type.type import Type
 
-        self._variables: Dict[str, Variable] = {}
-        self._class_methods: Dict[str, Method] = {}
+        self._variables: Dict[str, Variable] = {
+            'contract': Variable(Type.str),
+            'methods': Variable(Type.optional.build(Type.list.build_collection([Type.str])))
+        }
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
-        # avoid recursive import
-        from boa3.model.builtin.interop.oracle.oraclegetpricemethod import OracleGetPriceMethod
-        from boa3.model.builtin.interop.oracle.oraclerequestmethod import OracleRequestMethod
-
-        if len(self._class_methods) == 0:
-            self._class_methods = {
-                'get_price': OracleGetPriceMethod(),
-                'request': OracleRequestMethod()
-            }
-        return self._class_methods
+        return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
 
     def constructor_method(self) -> Optional[Method]:
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> OracleType:
+    def build(cls, value: Any = None) -> ContractPermissionType:
         if value is None or cls._is_type_of(value):
-            return _Oracle
+            return _ContractPermission
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, OracleType)
+        return isinstance(value, ContractPermissionType)
 
 
-_Oracle = OracleType()
+_ContractPermission = ContractPermissionType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/policy/isblockedmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/atoimethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,18 +1,22 @@
+import ast
 from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract import PolicyContractMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import StdLibMethod
+from boa3.internal.model.variable import Variable
 
 
-class IsBlockedMethod(PolicyContractMethod):
+class AtoiMethod(StdLibMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-
-        identifier = 'is_blocked'
-        native_identifier = 'isBlocked'
+        from boa3.internal.model.type.type import Type
+        identifier = 'atoi'
+        syscall = 'atoi'
         args: Dict[str, Variable] = {
-            'account': Variable(UInt160Type.build())
+            'value': Variable(Type.str),
+            'base': Variable(Type.int)
         }
-        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
+
+        args_default = ast.parse("{0}".format(10)
+                                 ).body[0].value
+
+        super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.int)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/role/getdesignatedbyrolemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/role/getdesignatedbyrolemethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract import RoleManagementMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import RoleManagementMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetDesignatedByRoleMethod(RoleManagementMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.builtin.interop.role.roletype import RoleType
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.builtin.interop.role.roletype import RoleType
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
         identifier = 'get_designated_by_role'
         native_identifier = 'getDesignatedByRole'
 
         role_type = RoleType.build()
         args: Dict[str, Variable] = {
             'role': Variable(role_type),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/role/roletype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/role/roletype.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, Dict
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class RoleType(IntType):
     """
     A class used to represent Neo's Role type.
     """
 
@@ -28,25 +28,29 @@
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets the class symbols of this type.
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.role.roletype import Role
-        from boa3.model.variable import Variable
+        from boa3.internal.model.variable import Variable
 
-        return {name: Variable(self) for name in Role.__members__.keys()}
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in Role.__members__.keys()})
+
+        return _symbols
 
     def get_value(self, symbol_id) -> Any:
         """
         Gets the literal value of a symbol.
 
         :return: the value if this type has this symbol. None otherwise
         """
-        if symbol_id in self.symbols:
-            from boa3.builtin.interop.role.roletype import Role
+        from boa3.builtin.interop.role.roletype import Role
+
+        if symbol_id in self.symbols and symbol_id in Role.__members__:
             return Role.__members__[symbol_id]
 
         return None
 
 
 _Role = RoleType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/checkwitnessmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/checkwitnessmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class CheckWitnessMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.type.collection.sequence.ecpointtype import ECPointType
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
 
         identifier = 'check_witness'
         syscall = 'System.Runtime.CheckWitness'
         args: Dict[str, Variable] = {'hash_or_pubkey': Variable(Type.union.build([ECPointType.build(),
                                                                                   UInt160Type.build()
                                                                                   ]))}
         super().__init__(identifier, syscall, args, return_type=Type.bool)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getblocktimemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getaddressversionmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetBlockTimeMethod(InteropMethod):
+class GetAddressVersionMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = '-get_time'
-        syscall = 'System.Runtime.GetTime'
+        from boa3.internal.model.type.type import Type
+        identifier = '-get_address_version'
+        syscall = 'System.Runtime.GetAddressVersion'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
 
-class BlockTimeProperty(IBuiltinProperty):
+class AddressVersionProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'time'
-        getter = GetBlockTimeMethod()
+        identifier = 'address_version'
+        getter = GetAddressVersionMethod()
         super().__init__(identifier, getter)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getcallingscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getentryscripthashmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetCallingScriptHashMethod(InteropMethod):
+class GetEntryScriptHashMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_calling_script_hash'
-        syscall = 'System.Runtime.GetCallingScriptHash'
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+        identifier = '-get_entry_script_hash'
+        syscall = 'System.Runtime.GetEntryScriptHash'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
 
 
-class CallingScriptHashProperty(IBuiltinProperty):
+class EntryScriptHashProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'calling_script_hash'
-        getter = GetCallingScriptHashMethod()
+        identifier = 'entry_script_hash'
+        getter = GetEntryScriptHashMethod()
         super().__init__(identifier, getter)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getentryscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/scriptcontainermethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
-class GetEntryScriptHashMethod(InteropMethod):
+class ScriptContainerMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        identifier = '-get_entry_script_hash'
-        syscall = 'System.Runtime.GetEntryScriptHash'
+        from boa3.internal.model.type.type import Type
+        identifier = '-get_script_container'
+        syscall = 'System.Runtime.GetScriptContainer'
         args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
+        super().__init__(identifier, syscall, args, return_type=Type.any)
 
 
-class EntryScriptHashProperty(IBuiltinProperty):
+class ScriptContainerProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'entry_script_hash'
-        getter = GetEntryScriptHashMethod()
+        identifier = 'script_container'
+        getter = ScriptContainerMethod()
         super().__init__(identifier, getter)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getexecutingscripthashmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getexecutingscripthashmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetExecutingScriptHashMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
         identifier = '-get_executing_script_hash'
         syscall = 'System.Runtime.GetExecutingScriptHash'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=UInt160Type.build())
 
 
 class ExecutingScriptHashProperty(IBuiltinProperty):
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getgasleftmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getgasleftmethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetGasLeftMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = '-get_gas_left'
         syscall = 'System.Runtime.GasLeft'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=Type.int)
 
 
 class GasLeftProperty(IBuiltinProperty):
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getinvocationcountermethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/gettriggermethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,14 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.runtime.triggertype import TriggerType
+from boa3.internal.model.variable import Variable
 
 
-class GetInvocationCounterMethod(InteropMethod):
-    def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = '-get_invocation_counter'
-        syscall = 'System.Runtime.GetInvocationCounter'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.int)
-
+class GetTriggerMethod(InteropMethod):
 
-class InvocationCounterProperty(IBuiltinProperty):
-    def __init__(self):
-        identifier = 'invocation_counter'
-        getter = GetInvocationCounterMethod()
-        super().__init__(identifier, getter)
+    def __init__(self, trigger_type: TriggerType):
+        identifier = 'get_trigger'
+        syscall = 'System.Runtime.GetTrigger'
+        args: Dict[str, Variable] = {}
+        super().__init__(identifier, syscall, args, return_type=trigger_type)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getnotificationsmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/unvote.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,44 +1,37 @@
-import ast
 from typing import Dict, List, Tuple
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.interop.runtime.notificationtype import NotificationType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+
+
+class UnVoteMethod(NeoContractMethod):
+
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'un_vote'
+        native_identifier = 'vote'  # un_vote is not neo native
+        args: Dict[str, Variable] = {
+            'account': Variable(UInt160Type.build()),
+        }
+
+        neo_internal_args = {
+            'account': Variable(UInt160Type.build()),
+            'vote_to': Variable(ECPointType.build())
+        }
 
-
-class GetNotificationsMethod(InteropMethod):
-
-    def __init__(self, notification_type: NotificationType):
-        from boa3.model.type.collection.sequence.uint160type import UInt160Type
-        from boa3.model.type.type import Type
-
-        identifier = 'get_notifications'
-        syscall = 'System.Runtime.GetNotifications'
-        uint160 = UInt160Type.build()
-
-        args: Dict[str, Variable] = {'script_hash': Variable(uint160)}
-        args_default = set_internal_call(ast.parse("{0}()".format(uint160.raw_identifier)
-                                                   ).body[0].value)
-
-        super().__init__(identifier, syscall, args, [args_default],
-                         return_type=Type.list.build([notification_type]))
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool,
+                         internal_call_args=len(neo_internal_args))
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        # TODO: Change when Optional or Union is implemented
-        from boa3.neo.vm.type.Integer import Integer
-        from boa3.model.type.type import Type
-        opcodes = [
-            (Opcode.DUP, b''),
-            (Opcode.CONVERT, Type.int.stack_item),
-            (Opcode.PUSH0, b''),
-            (Opcode.NUMEQUAL, b''),
-            (Opcode.JMPIFNOT, Integer(4).to_byte_array(signed=True)),
-            (Opcode.DROP, b''),
-            (Opcode.PUSHNULL, b'')
-        ]
-        opcodes.extend(super().opcode)
-
-        return opcodes
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return (
+            [
+                (Opcode.PUSHNULL, b''),
+                (Opcode.SWAP, b''),
+            ] +
+            super()._opcode
+        )
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/getplatformmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/getplatformmethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from typing import Dict
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class GetPlatformMethod(InteropMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = '-get_platform'
         syscall = 'System.Runtime.Platform'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, syscall, args, return_type=Type.str)
 
 
 class PlatformProperty(IBuiltinProperty):
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/notificationtype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/contract/neoaccountstatetype.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,89 +1,98 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.type.collection.sequence.uint160type import UInt160Type
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NotificationType(ClassArrayType):
+class NeoAccountStateType(ClassArrayType):
     """
-    A class used to represent Neo Notification class
+    A class used to represent Neo NeoAccountState class
     """
 
     def __init__(self):
-        super().__init__('Notification')
+        super().__init__('NeoAccountState')
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
 
-        from boa3.model.type.type import Type
         self._variables: Dict[str, Variable] = {
-            'script_hash': Variable(UInt160Type.build()),
-            'event_name': Variable(Type.str),
-            'state': Variable(Type.tuple)
+            'balance': Variable(Type.int),
+            'height': Variable(Type.int),
+            'vote_to': Variable(ECPointType.build()),
         }
-        self._constructor: Method = None
+        self._constructor: Optional[Method] = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         return {}
 
     def constructor_method(self) -> Optional[Method]:
         # was having a problem with recursive import
         if self._constructor is None:
-            self._constructor: Method = NotificationMethod(self)
+            self._constructor: Method = NeoAccountStateMethod(self)
         return self._constructor
 
     @classmethod
-    def build(cls, value: Any = None) -> NotificationType:
+    def build(cls, value: Any = None) -> NeoAccountStateType:
         if value is None or cls._is_type_of(value):
-            return _Notification
+            return _NeoAccountState
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, NotificationType)
+        return isinstance(value, NeoAccountStateType)
 
 
-_Notification = NotificationType()
+_NeoAccountState = NeoAccountStateType()
 
 
-class NotificationMethod(IBuiltinMethod):
+class NeoAccountStateMethod(IBuiltinMethod):
 
-    def __init__(self, return_type: NotificationType):
-        identifier = '-Notification__init__'
+    def __init__(self, return_type: NeoAccountStateType):
+        identifier = '-NeoAccountState__init__'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
         return [
-            (Opcode.NEWARRAY0, b''),
-            (Opcode.PUSHDATA1, Integer(0).to_byte_array()),
-            (Opcode.PUSHDATA1, Integer(20).to_byte_array() + bytes(20)),
+            OpcodeHelper.get_pushdata_and_data(ECPointType.build().default_value),  # vote_to
+            (Opcode.PUSH0, b''),  # height
+            (Opcode.PUSH0, b''),  # balance
             (Opcode.PUSH3, b''),
             (Opcode.PACK, b'')
         ]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/notifymethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/notifymethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopevent import InteropEvent
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopevent import InteropEvent
+from boa3.internal.model.variable import Variable
 
 
 class NotifyMethod(InteropEvent):
 
     def __init__(self):
         self._event_name_key = 'notification_name'
 
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'notify'
         syscall = 'System.Runtime.Notify'
         args: Dict[str, Variable] = {'state': Variable(Type.any),
                                      self._event_name_key: Variable(Type.str)
                                      }
         import ast
         event_name_default = ast.parse("'{0}'".format(identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/scriptcontainermethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/getgasscripthashmethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,21 +1,29 @@
-from typing import Dict
+from typing import Optional
 
-from boa3.model.builtin.builtinproperty import IBuiltinProperty
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtinproperty import IBuiltinProperty
+from boa3.internal.model.builtin.interop.nativecontract.Nep17.getnep17scripthashmethod import GetNep17ScriptHashMethod
 
 
-class ScriptContainerMethod(InteropMethod):
+class GetGasScriptHashMethod(GetNep17ScriptHashMethod):
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = '-get_script_container'
-        syscall = 'System.Runtime.GetScriptContainer'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, syscall, args, return_type=Type.any)
+        from boa3.internal.constants import GAS_SCRIPT
+        identifier = '-get_gas'
+        super().__init__(GAS_SCRIPT, identifier)
 
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
-class ScriptContainerProperty(IBuiltinProperty):
+    @property
+    def _body(self) -> Optional[str]:
+        return None
+
+
+class GasProperty(IBuiltinProperty):
     def __init__(self):
-        identifier = 'script_container'
-        getter = ScriptContainerMethod()
+        identifier = 'GAS'
+        getter = GetGasScriptHashMethod()
         super().__init__(identifier, getter)
+
+
+GasToken = GasProperty()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/runtime/triggertype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/runtime/triggertype.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, Dict
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class TriggerType(IntType):
     """
     A class used to represent Neo interop Trigger type
     """
 
@@ -18,15 +18,15 @@
     def default_value(self) -> Any:
         from boa3.builtin.interop.runtime import TriggerType as Trigger
         return Trigger.ALL
 
     @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            from boa3.model.builtin.interop.interop import Interop
+            from boa3.internal.model.builtin.interop.interop import Interop
             return Interop.TriggerType
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.runtime import TriggerType as Trigger
         return isinstance(value, (Trigger, TriggerType))
 
@@ -34,17 +34,20 @@
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.runtime import TriggerType as Trigger
-        from boa3.model.variable import Variable
+        from boa3.internal.model.variable import Variable
 
-        return {name: Variable(self) for name in Trigger.__members__.keys()}
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in Trigger.__members__.keys()})
+
+        return _symbols
 
     def get_value(self, symbol_id) -> Any:
         """
         Gets the literal value of a symbol
 
         :return: the value if this type has this symbol. None otherwise.
         """
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/__init__.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/stdlib/__init__.py`

 * *Files 9% similar despite different names*

```diff
@@ -9,19 +9,19 @@
            'ItoaMethod',
            'MemoryCompareMethod',
            'MemorySearchMethod',
            'SerializeMethod',
            'SerializeMethod'
            ]
 
-from boa3.model.builtin.interop.stdlib.atoimethod import AtoiMethod
-from boa3.model.builtin.interop.stdlib.base58checkdecodemethod import Base58CheckDecodeMethod
-from boa3.model.builtin.interop.stdlib.base58checkencodemethod import Base58CheckEncodeMethod
-from boa3.model.builtin.interop.stdlib.base58decodemethod import Base58DecodeMethod
-from boa3.model.builtin.interop.stdlib.base58encodemethod import Base58EncodeMethod
-from boa3.model.builtin.interop.stdlib.base64decodemethod import Base64DecodeMethod
-from boa3.model.builtin.interop.stdlib.base64encodemethod import Base64EncodeMethod
-from boa3.model.builtin.interop.stdlib.deserializemethod import DeserializeMethod
-from boa3.model.builtin.interop.stdlib.itoamethod import ItoaMethod
-from boa3.model.builtin.interop.stdlib.memorycomparemethod import MemoryCompareMethod
-from boa3.model.builtin.interop.stdlib.memorysearchmethod import MemorySearchMethod
-from boa3.model.builtin.interop.stdlib.serializemethod import SerializeMethod
+from boa3.internal.model.builtin.interop.stdlib.atoimethod import AtoiMethod
+from boa3.internal.model.builtin.interop.stdlib.base58checkdecodemethod import Base58CheckDecodeMethod
+from boa3.internal.model.builtin.interop.stdlib.base58checkencodemethod import Base58CheckEncodeMethod
+from boa3.internal.model.builtin.interop.stdlib.base58decodemethod import Base58DecodeMethod
+from boa3.internal.model.builtin.interop.stdlib.base58encodemethod import Base58EncodeMethod
+from boa3.internal.model.builtin.interop.stdlib.base64decodemethod import Base64DecodeMethod
+from boa3.internal.model.builtin.interop.stdlib.base64encodemethod import Base64EncodeMethod
+from boa3.internal.model.builtin.interop.stdlib.deserializemethod import DeserializeMethod
+from boa3.internal.model.builtin.interop.stdlib.itoamethod import ItoaMethod
+from boa3.internal.model.builtin.interop.stdlib.memorycomparemethod import MemoryCompareMethod
+from boa3.internal.model.builtin.interop.stdlib.memorysearchmethod import MemorySearchMethod
+from boa3.internal.model.builtin.interop.stdlib.serializemethod import SerializeMethod
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/atoimethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/intintmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,22 +1,25 @@
 import ast
-from typing import Dict
+from typing import Dict, List, Tuple
 
-from boa3.model.builtin.interop.nativecontract import StdLibMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.intmethod import IntMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class AtoiMethod(StdLibMethod):
+class IntIntMethod(IntMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'atoi'
-        syscall = 'atoi'
+        from boa3.internal.model.type.type import Type
         args: Dict[str, Variable] = {
-            'value': Variable(Type.str),
-            'base': Variable(Type.int)
+            'value': Variable(Type.int),
         }
 
-        args_default = ast.parse("{0}".format(10)
-                                 ).body[0].value
+        value_default = ast.parse("{0}".format(Type.int.default_value)
+                                  ).body[0].value
 
-        super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.int)
+        super().__init__(args, [value_default])
+
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        # returns the same int
+        return []
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/itoamethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/strbytestringmethod.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,20 +1,23 @@
 import ast
-from typing import Dict
+from typing import Dict, List, Tuple
 
-from boa3.model.builtin.interop.nativecontract import StdLibMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.strmethod import StrMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ItoaMethod(StdLibMethod):
+class StrBytesMethod(StrMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'itoa'
-        syscall = 'itoa'
+        from boa3.internal.model.type.type import Type
+
         args: Dict[str, Variable] = {
-            'value': Variable(Type.int),
-            'base': Variable(Type.int)
+            'object': Variable(Type.union.build([Type.bytes, Type.str])),
         }
-        args_default = ast.parse("{0}".format(10)).body[0].value
+        object_default = ast.parse("'{0}'".format(Type.str.default_value)).body[0].value
+
+        super().__init__(args, [object_default])
 
-        super().__init__(identifier, syscall, args, defaults=[args_default], return_type=Type.str)
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return []
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/memorycomparemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/contract/nep11transferevent.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,18 +1,23 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.nativecontract import StdLibMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
+from boa3.internal.model.variable import Variable
 
 
-class MemoryCompareMethod(StdLibMethod):
+class Nep11TransferEvent(IBuiltinEvent):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'memory_compare'
-        syscall = 'memoryCompare'
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'Nep11TransferEvent'
+        type_token_id = Type.union.build([Type.str, Type.bytes])
+
         args: Dict[str, Variable] = {
-            'mem1': Variable(Type.union.build([Type.bytes, Type.str])),
-            'mem2': Variable(Type.union.build([Type.bytes, Type.str]))
+            'from_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
+            'to_addr': Variable(Type.union.build([Type.none, UInt160Type.build()])),
+            'amount': Variable(Type.int),
+            'tokenId': Variable(type_token_id),
         }
-
-        super().__init__(identifier, syscall, args, return_type=Type.int)
+        super().__init__(identifier, args)
+        self.name = 'Transfer'
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/stdlib/memorysearchmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/nep17_methods/transfermethod.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 import ast
 from typing import Dict
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.interop.nativecontract import StdLibMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import Nep17Method
+from boa3.internal.model.variable import Variable
 
 
-class MemorySearchMethod(StdLibMethod):
+class TransferMethod(Nep17Method):
 
-    def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'memory_search'
-        native_identifier = 'memorySearch'
+    def __init__(self, contract_script_hash: bytes):
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+
+        identifier = 'transfer'
+        native_identifier = 'transfer'
         args: Dict[str, Variable] = {
-            'mem': Variable(Type.union.build([Type.str, Type.bytes])),
-            'value': Variable(Type.union.build([Type.str, Type.bytes])),
-            'start': Variable(Type.int),
-            'backward': Variable(Type.bool),
+            'from_address': Variable(UInt160Type.build()),
+            'to_address': Variable(UInt160Type.build()),
+            'amount': Variable(Type.int),
+            'data': Variable(Type.any),
         }
 
-        start_default = set_internal_call(ast.parse("{0}".format(Type.int.default_value)
-                                                    ).body[0].value)
-        backward_default = set_internal_call(ast.parse("{0}".format(Type.bool.default_value)
-                                                       ).body[0].value)
+        data_default = ast.parse("{0}".format(Type.any.default_value)
+                                 ).body[0].value
 
-        super().__init__(identifier, native_identifier, args, defaults=[start_default, backward_default], return_type=Type.int)
+        super().__init__(identifier, native_identifier, args, defaults=[data_default],
+                         return_type=Type.bool, script_hash=contract_script_hash)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/__init__.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,16 +5,16 @@
            'StorageGetContextMethod',
            'StorageGetReadOnlyContextMethod',
            'StorageGetMethod',
            'StorageMapType',
            'StoragePutMethod'
            ]
 
-from boa3.model.builtin.interop.storage.findoptionstype import FindOptionsType
-from boa3.model.builtin.interop.storage.storagecontext import StorageContextType
-from boa3.model.builtin.interop.storage.storagedeletemethod import StorageDeleteMethod
-from boa3.model.builtin.interop.storage.storagefindmethod import StorageFindMethod
-from boa3.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
-from boa3.model.builtin.interop.storage.storagegetmethod import StorageGetMethod
-from boa3.model.builtin.interop.storage.storagegetreadonlycontextmethod import StorageGetReadOnlyContextMethod
-from boa3.model.builtin.interop.storage.storagemap.storagemaptype import StorageMapType
-from boa3.model.builtin.interop.storage.storageputmethod import StoragePutMethod
+from boa3.internal.model.builtin.interop.storage.findoptionstype import FindOptionsType
+from boa3.internal.model.builtin.interop.storage.storagecontext import StorageContextType
+from boa3.internal.model.builtin.interop.storage.storagedeletemethod import StorageDeleteMethod
+from boa3.internal.model.builtin.interop.storage.storagefindmethod import StorageFindMethod
+from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
+from boa3.internal.model.builtin.interop.storage.storagegetmethod import StorageGetMethod
+from boa3.internal.model.builtin.interop.storage.storagegetreadonlycontextmethod import StorageGetReadOnlyContextMethod
+from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import StorageMapType
+from boa3.internal.model.builtin.interop.storage.storageputmethod import StoragePutMethod
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/findoptionstype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/findoptionstype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, Dict
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.inttype import IntType
 
 
 class FindOptionsType(IntType):
     """
     A class used to represent Neo interop FindOptions type
     """
 
@@ -18,15 +18,15 @@
     def default_value(self) -> Any:
         from boa3.builtin.interop.storage import FindOptions
         return FindOptions.NONE
 
     @classmethod
     def build(cls, value: Any = None) -> IType:
         if cls._is_type_of(value) or value is None:
-            from boa3.model.builtin.interop.interop import Interop
+            from boa3.internal.model.builtin.interop.interop import Interop
             return Interop.FindOptionsType
 
     @classmethod
     def _is_type_of(cls, value: Any):
         from boa3.builtin.interop.storage import FindOptions
         return isinstance(value, (FindOptions, FindOptionsType))
 
@@ -34,22 +34,26 @@
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets the class symbols of this type
 
         :return: a dictionary that maps each symbol in the module with its name
         """
         from boa3.builtin.interop.storage import FindOptions
-        from boa3.model.variable import Variable
+        from boa3.internal.model.variable import Variable
 
-        return {name: Variable(self) for name in FindOptions.__members__.keys()}
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in FindOptions.__members__.keys()})
+
+        return _symbols
 
     def get_value(self, symbol_id) -> Any:
         """
         Gets the literal value of a symbol
 
         :return: the value if this type has this symbol. None otherwise.
         """
-        if symbol_id in self.symbols:
-            from boa3.builtin.interop.storage import FindOptions
+        from boa3.builtin.interop.storage import FindOptions
+
+        if symbol_id in self.symbols and symbol_id in FindOptions.__members__:
             return FindOptions.__members__[symbol_id]
 
         return None
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextasreadonlymethod.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.variable import Variable
 
 
 class StorageContextAsReadOnlyMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext
+        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext
 
         identifier = 'as_read_only'
         syscall = 'System.Storage.AsReadOnly'
         args: Dict[str, Variable] = {'self': Variable(_StorageContext)}
         super().__init__(identifier, syscall, args, return_type=_StorageContext)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontextcreatemapmethod.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class StorageContextCreateMapMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext
-        from boa3.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
-        from boa3.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext
+        from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
+        from boa3.internal.model.type.type import Type
 
         identifier = 'create_map'
+        byte_string_type = Type.bytes
+
         args: Dict[str, Variable] = {'self': Variable(_StorageContext),
-                                     'prefix': Variable(Type.union.build([Type.bytes,
-                                                                          Type.str
-                                                                          ]))}
+                                     'prefix': Variable(byte_string_type)}
 
         super().__init__(identifier, args, return_type=_StorageMap)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap as StorageMapType
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap as StorageMapType
         return StorageMapType.constructor_method().opcode
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagecontext/storagecontexttype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagecontext/storagecontexttype.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Optional
 
-from boa3.model.builtin.interop.interopinterfacetype import InteropInterfaceType
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopinterfacetype import InteropInterfaceType
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.variable import Variable
 
 
 class StorageContextType(InteropInterfaceType):
     """
     A class used to represent Neo StorageContext class
     """
 
@@ -17,32 +17,41 @@
         super().__init__('StorageContext')
 
         self._variables: Dict[str, Variable] = {}
         self._instance_methods: Dict[str, Method] = {}
         self._constructor: Method = None
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         # avoid recursive import
         if len(self._instance_methods) == 0:
-            from boa3.model.builtin.interop.storage.storagecontext.storagecontextcreatemapmethod import \
+            from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontextcreatemapmethod import \
                 StorageContextCreateMapMethod
-            from boa3.model.builtin.interop.storage.storagecontext.storagecontextasreadonlymethod import StorageContextAsReadOnlyMethod
+            from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontextasreadonlymethod import \
+                StorageContextAsReadOnlyMethod
 
             self._instance_methods = {
                 'create_map': StorageContextCreateMapMethod(),
                 'as_read_only': StorageContextAsReadOnlyMethod()
             }
         return self._instance_methods
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagedeletemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagefindmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,54 +1,67 @@
 import ast
 from typing import Any, Dict, Iterable, List, Sized
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-
-
-class StorageDeleteMethod(InteropMethod):
-
-    def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.storage import FindOptionsType
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+
+
+class StorageFindMethod(InteropMethod):
+
+    def __init__(self, find_options_type: FindOptionsType, prefix_type: IType = None):
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
 
-        identifier = 'delete'
-        syscall = 'System.Storage.Delete'
+        identifier = 'find'
+        syscall = 'System.Storage.Find'
         context_type = StorageContextType.build()
 
-        args: Dict[str, Variable] = {'key': Variable(Type.union.build([Type.bytes,
-                                                                       Type.str
-                                                                       ])),
-                                     'context': Variable(context_type)}
+        if prefix_type is None:
+            prefix_type = Type.bytes
 
-        from boa3.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
+        args: Dict[str, Variable] = {'prefix': Variable(prefix_type),
+                                     'context': Variable(context_type),
+                                     'options': Variable(find_options_type)}
+
+        from boa3.internal.model.builtin.interop.iterator import IteratorType
+        return_type = IteratorType.build(Type.dict.build([prefix_type,  # return an Iterator[prefix, bytes]
+                                                          Type.bytes]))
+
+        from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
         default_id = StorageGetContextMethod(context_type).identifier
         context_default = set_internal_call(ast.parse("{0}()".format(default_id)
                                                       ).body[0].value)
-        super().__init__(identifier, syscall, args, defaults=[context_default], return_type=Type.none)
+        options_default = set_internal_call(ast.parse("{0}.{1}".format(find_options_type.identifier,
+                                                                       find_options_type.default_value.name)
+                                                      ).body[0].value)
+
+        defaults = [context_default, options_default]
+
+        super().__init__(identifier, syscall, args, defaults=defaults, return_type=return_type)
+
+    @property
+    def identifier(self) -> str:
+        return '-{0}_{1}'.format(self._identifier, self.prefix_arg.type.identifier)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if any(not isinstance(param, IExpression) for param in params):
             return False
 
         args: List[IType] = [arg.type for arg in self.args.values()]
-        # TODO: refactor when default arguments are implemented
-        if len(params) != len(args):
+        if len(params) > len(args):
+            return False
+        if len(params) < len(self.args_without_default):
             return False
 
-        return self._validate_key_type(params[0].type)
-
-    def _validate_key_type(self, key_type: IType):
-        # TODO: refactor when `Union` type is implemented
-        from boa3.model.type.type import Type
-        return Type.str.is_type_of(key_type) or Type.bytes.is_type_of(key_type)
+        return self.prefix_arg.type.is_type_of(params[0].type)
 
     @property
     def generation_order(self) -> List[int]:
         """
         Gets the indexes order that need to be used during code generation.
         If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
 
@@ -61,37 +74,35 @@
             # context must be the last generated argument
             indexes.remove(context_index)
             indexes.append(context_index)
 
         return indexes
 
     @property
-    def storage_context_hash(self) -> bytes:
-        # TODO: refactor when default arguments are implemented
-        return self._method_hash(self._storage_context)
+    def prefix_arg(self) -> Variable:
+        return self.args['prefix']
 
     @property
-    def key_arg(self) -> Variable:
-        return self.args['key']
+    def options_arg(self) -> Variable:
+        return self.args['options']
 
     def build(self, value: Any) -> IBuiltinMethod:
         exp: List[IExpression] = []
         if isinstance(value, Sized):
-            if len(value) > 2 or not isinstance(value, Iterable):
+            if len(value) > 1 or not isinstance(value, Iterable):
                 return self
             exp = [exp if isinstance(exp, IExpression) else Variable(exp)
                    for exp in value if isinstance(exp, (IExpression, IType))]
 
         elif isinstance(exp, (IExpression, IType)):
             exp = [value if isinstance(value, IExpression) else Variable(value)]
         else:
             return self
 
         if not self.validate_parameters(*exp):
             return self
 
         method = self
-        key_type: IType = exp[0].type
-        if not method.key_arg.type.is_type_of(key_type):
-            method = StorageDeleteMethod()
-            method.args['key'] = Variable(key_type)
+        prefix_type: IType = exp[0].type
+        if type(method.prefix_arg.type) != type(prefix_type):
+            method = StorageFindMethod(self.options_arg.type, prefix_type)
         return method
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagefindmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/type/typingmethod/casttypemethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,108 +1,121 @@
-import ast
-from typing import Any, Dict, Iterable, List, Sized
+from typing import Any, Dict, List, Optional, Sized, Tuple
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.interop.storage import FindOptionsType
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-
-
-class StorageFindMethod(InteropMethod):
-
-    def __init__(self, find_options_type: FindOptionsType, prefix_type: IType = None):
-        from boa3.model.type.type import Type
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
-
-        identifier = 'find'
-        syscall = 'System.Storage.Find'
-        context_type = StorageContextType.build()
-
-        if prefix_type is None:
-            prefix_type = Type.union.build([Type.bytes,
-                                            Type.str
-                                            ])
-        args: Dict[str, Variable] = {'prefix': Variable(prefix_type),
-                                     'context': Variable(context_type),
-                                     'options': Variable(find_options_type)}
-
-        from boa3.model.builtin.interop.iterator import IteratorType
-        return_type = IteratorType.build(Type.dict.build([prefix_type,  # return an Iterator[prefix, bytes]
-                                                          Type.bytes]))
-
-        from boa3.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
-        default_id = StorageGetContextMethod(context_type).identifier
-        context_default = set_internal_call(ast.parse("{0}()".format(default_id)
-                                                      ).body[0].value)
-        options_default = set_internal_call(ast.parse("{0}.{1}".format(find_options_type.identifier,
-                                                                       find_options_type.default_value.name)
-                                                      ).body[0].value)
-
-        defaults = [context_default, options_default]
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.annotation.metatype import MetaType, metaType
+from boa3.internal.model.type.anytype import anyType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+
+
+class CastTypeMethod(IBuiltinMethod):
+
+    def __init__(self, cast_to_type: IType = None, origin_type: IType = None):
+        # if the type to be casted is not value, there's an error in the signature
+        if cast_to_type is None:
+            type_value = metaType
+        elif isinstance(cast_to_type, MetaType):
+            type_value = cast_to_type if cast_to_type.has_meta_type else metaType
+        else:
+            type_value = MetaType.build(cast_to_type)
 
-        super().__init__(identifier, syscall, args, defaults=defaults, return_type=return_type)
+        if origin_type is None:
+            origin_type = anyType
+        elif isinstance(origin_type, MetaType):
+            origin_type = origin_type.meta_type if origin_type.has_meta_type else anyType
+
+        identifier = 'cast'
+        args: Dict[str, Variable] = {'typ': Variable(type_value),
+                                     'val': Variable(anyType)}
+        super().__init__(identifier, args,
+                         return_type=cast_to_type.meta_type if isinstance(cast_to_type, MetaType) else anyType)
+        self._origin_type: IType = origin_type
 
     @property
     def identifier(self) -> str:
-        return '-{0}_{1}'.format(self._identifier, self.prefix_arg.type.identifier)
+        if self.is_supported:
+            identifier = (self.typ_arg.type.meta_id
+                          if hasattr(self.typ_arg.type, 'meta_id')
+                          else self.typ_arg.type.identifier)
+            return '-{0}_{1}'.format(self._identifier, identifier)
+        else:
+            return self._identifier
 
     def validate_parameters(self, *params: IExpression) -> bool:
-        if any(not isinstance(param, IExpression) for param in params):
+        if len(params) != 1:
             return False
-
-        args: List[IType] = [arg.type for arg in self.args.values()]
-        # TODO: refactor when default arguments are implemented
-        if len(params) != len(args):
+        if not isinstance(params[0], IExpression):
             return False
+        return isinstance(params[0].type, SequenceType)
 
-        return self.prefix_arg.type.is_type_of(params[0].type)
+    @property
+    def is_supported(self) -> bool:
+        return (isinstance(self.typ_arg, Variable)
+                and isinstance(self.typ_arg.type, MetaType)
+                and self.typ_arg.type.has_meta_type)
+
+    def not_supported_str(self, callable_id: str) -> str:
+        return '{0}({1})'.format(callable_id,
+                                 ','.join([arg.type.identifier if isinstance(arg, Variable) else 'unknown'
+                                           for arg in self.args.values()]))
 
     @property
-    def generation_order(self) -> List[int]:
-        """
-        Gets the indexes order that need to be used during code generation.
-        If the order for generation is the same as inputted in code, returns reversed(range(0,len_args))
+    def is_cast(self) -> bool:
+        return True
 
-        :return: Index order for code generation
-        """
-        indexes = super().generation_order
-        context_index = list(self.args).index('context')
+    @property
+    def cast_types(self) -> Optional[Tuple[IType, IType]]:
+        origin_type = self._origin_type
+        target_type = (self.typ_arg.type.meta_type
+                       if hasattr(self.typ_arg.type, 'meta_type')
+                       else self.typ_arg.type)
+        return origin_type, target_type
 
-        if indexes[-1] != context_index:
-            # context must be the last generated argument
-            indexes.remove(context_index)
-            indexes.append(context_index)
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return []
 
-        return indexes
+    @property
+    def _args_on_stack(self) -> int:
+        return 1  # the implementation is the same as x = arg
 
     @property
-    def prefix_arg(self) -> Variable:
-        return self.args['prefix']
+    def args_on_stack(self) -> int:
+        return 1  # the implementation is the same as x = arg
 
     @property
-    def options_arg(self) -> Variable:
-        return self.args['options']
+    def generation_order(self) -> List[int]:
+        # type should not be converted
+        indexes = super().generation_order
+        typ_index = list(self.args).index('typ')
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        exp: List[IExpression] = []
-        if isinstance(value, Sized):
-            if len(value) > 1 or not isinstance(value, Iterable):
-                return self
-            exp = [exp if isinstance(exp, IExpression) else Variable(exp)
-                   for exp in value if isinstance(exp, (IExpression, IType))]
+        if typ_index in indexes:
+            indexes.remove(typ_index)
 
-        elif isinstance(exp, (IExpression, IType)):
-            exp = [value if isinstance(value, IExpression) else Variable(value)]
-        else:
-            return self
+        return indexes
 
-        if not self.validate_parameters(*exp):
-            return self
+    @property
+    def _body(self) -> Optional[str]:
+        return None
 
-        method = self
-        prefix_type: IType = exp[0].type
-        if type(method.prefix_arg.type) != type(prefix_type):
-            method = StorageFindMethod(self.options_arg.type, prefix_type)
-        return method
+    @property
+    def typ_arg(self) -> Variable:
+        return self.args['typ'] if isinstance(self.args['typ'], Variable) else Variable(anyType)
+
+    @property
+    def val_arg(self) -> Variable:
+        return self.args['val']
+
+    def build(self, value: Any) -> IBuiltinMethod:
+        if isinstance(value, Sized) and len(value) == len(self.args):
+            cast_to = value[0]
+            cast_from = value[1]
+
+            if isinstance(cast_to, IType):
+                if isinstance(cast_from, IType):
+                    return CastTypeMethod(cast_to, cast_from)
+                else:
+                    return CastTypeMethod(cast_to)
+        return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagegetcontextmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagegetreadonlycontextmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
+from boa3.internal.model.variable import Variable
 
 
-class StorageGetContextMethod(InteropMethod):
+class StorageGetReadOnlyContextMethod(InteropMethod):
 
     def __init__(self, storage_context_type: StorageContextType):
-        identifier = 'get_context'
+        identifier = 'get_read_only_context'
         native_identifier = 'System.Storage.GetContext'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, native_identifier, args, return_type=storage_context_type)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagegetmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagegetmethod.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,63 +1,49 @@
 import ast
 from typing import Any, Dict, Iterable, List, Sized, Tuple
 
-from boa3.model import set_internal_call
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class StorageGetMethod(InteropMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
 
         identifier = 'get'
         syscall = 'System.Storage.Get'
         context_type = StorageContextType.build()
-        args: Dict[str, Variable] = {'key': Variable(Type.union.build([Type.bytes,
-                                                                       Type.str
-                                                                       ])),
+
+        args: Dict[str, Variable] = {'key': Variable(Type.bytes),
                                      'context': Variable(context_type)}
 
-        from boa3.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
+        from boa3.internal.model.builtin.interop.storage.storagegetcontextmethod import StorageGetContextMethod
         default_id = StorageGetContextMethod(context_type).identifier
         context_default = set_internal_call(ast.parse("{0}()".format(default_id)
                                                       ).body[0].value)
         super().__init__(identifier, syscall, args, defaults=[context_default], return_type=Type.bytes)
 
-    def validate_parameters(self, *params: IExpression) -> bool:
-        if any(not isinstance(param, IExpression) for param in params):
-            return False
-
-        args: List[IType] = [arg.type for arg in self.args.values()]
-        # TODO: refactor when default arguments are implemented
-        if len(params) != len(args):
-            return False
-
-        return self.key_arg.type.is_type_of(params[0].type)
-
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
-        from boa3.neo.vm.type.Integer import Integer
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
 
-        opcodes = super().opcode
+        opcodes = super()._opcode
         opcodes.extend([
             (Opcode.DUP, b''),
             (Opcode.ISNULL, b''),
-            (Opcode.JMPIFNOT, Integer(7).to_byte_array(signed=True, min_length=1)),
+            (Opcode.JMPIFNOT, Integer(5).to_byte_array(signed=True, min_length=1)),
             (Opcode.DROP, b''),
             (Opcode.PUSHDATA1, b'\x00'),
-            (Opcode.CONVERT, Type.bytes.stack_item),
         ])
         return opcodes
 
     @property
     def generation_order(self) -> List[int]:
         """
         Gets the indexes order that need to be used during code generation.
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagegetreadonlycontextmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagegetcontextmethod.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from typing import Dict
 
-from boa3.model.builtin.interop.interopmethod import InteropMethod
-from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.interopmethod import InteropMethod
+from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import StorageContextType
+from boa3.internal.model.variable import Variable
 
 
-class StorageGetReadOnlyContextMethod(InteropMethod):
+class StorageGetContextMethod(InteropMethod):
 
     def __init__(self, storage_context_type: StorageContextType):
-        identifier = 'get_read_only_context'
+        identifier = 'get_context'
         native_identifier = 'System.Storage.GetContext'
         args: Dict[str, Variable] = {}
         super().__init__(identifier, native_identifier, args, return_type=storage_context_type)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemapdeletemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapgetmethod.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,43 +1,41 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class StorageMapDeleteMethod(IBuiltinMethod):
+class StorageMapGetMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
-        from boa3.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
+        from boa3.internal.model.type.type import Type
 
-        identifier = 'delete'
+        identifier = 'get'
         args: Dict[str, Variable] = {'self': Variable(_StorageMap),
-                                     'key': Variable(Type.union.build([Type.bytes,
-                                                                       Type.str
-                                                                       ]))}
+                                     'key': Variable(Type.bytes)}
 
-        super().__init__(identifier, args, return_type=Type.none)
+        super().__init__(identifier, args, return_type=Type.bytes)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.builtin.interop.interop import Interop
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.builtin.interop.interop import Interop
         return [
             (Opcode.SWAP, b''),
             (Opcode.OVER, b''),
             (Opcode.PUSH1, b''),
             (Opcode.PICKITEM, b''),
             (Opcode.SWAP, b''),
             (Opcode.CAT, b''),
             (Opcode.SWAP, b''),
             (Opcode.PUSH0, b''),
             (Opcode.PICKITEM, b''),
-        ] + Interop.StorageDelete.opcode
+        ] + Interop.StorageGet.opcode
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemapgetmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemapputmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,43 +1,47 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class StorageMapGetMethod(IBuiltinMethod):
+class StorageMapPutMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
-        from boa3.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
+        from boa3.internal.model.type.type import Type
+
+        identifier = 'put'
+        storage_value_type = Type.union.build([Type.bytes,
+                                               Type.int,
+                                               Type.str,
+                                               ])
 
-        identifier = 'get'
         args: Dict[str, Variable] = {'self': Variable(_StorageMap),
-                                     'key': Variable(Type.union.build([Type.bytes,
-                                                                       Type.str
-                                                                       ]))}
+                                     'key': Variable(Type.bytes),
+                                     'value': Variable(storage_value_type)}
 
-        super().__init__(identifier, args, return_type=Type.bytes)
+        super().__init__(identifier, args, return_type=Type.none)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.builtin.interop.interop import Interop
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.builtin.interop.interop import Interop
         return [
             (Opcode.SWAP, b''),
             (Opcode.OVER, b''),
             (Opcode.PUSH1, b''),
             (Opcode.PICKITEM, b''),
             (Opcode.SWAP, b''),
             (Opcode.CAT, b''),
             (Opcode.SWAP, b''),
             (Opcode.PUSH0, b''),
             (Opcode.PICKITEM, b''),
-        ] + Interop.StorageGet.opcode
+        ] + Interop.StoragePut.opcode
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemapputmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/summethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,47 +1,51 @@
+import ast
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class StorageMapPutMethod(IBuiltinMethod):
+class SumMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.builtin.interop.storage.storagemap.storagemaptype import _StorageMap
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
+        identifier = 'sum'
+        args: Dict[str, Variable] = {'__iterable': Variable(Type.sequence.build_collection(Type.int)),
+                                     '__start': Variable(Type.int)}
+
+        start_default = ast.parse("{0}".format(Type.int.default_value)
+                                  ).body[0].value
+        super().__init__(identifier, args, defaults=[start_default], return_type=Type.int)
 
-        identifier = 'put'
-        args: Dict[str, Variable] = {'self': Variable(_StorageMap),
-                                     'key': Variable(Type.union.build([Type.bytes,
-                                                                       Type.str
-                                                                       ])),
-                                     'value': Variable(Type.union.build([Type.bytes,
-                                                                         Type.str,
-                                                                         Type.int
-                                                                         ]))}
-
-        super().__init__(identifier, args, return_type=Type.none)
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        return [
+            (Opcode.PUSH0, b''),    # index = 0
+            (Opcode.DUP, b''),
+            (Opcode.PUSH2, b''),    # len(iterable)
+            (Opcode.PICK, b''),
+            (Opcode.SIZE, b''),
+            (Opcode.GE, b''),       # index > len(iterable)
+            (Opcode.JMPIF, Integer(12).to_byte_array(signed=True, min_length=1)),
+            (Opcode.REVERSE3, b''),
+            (Opcode.OVER, b''),
+            (Opcode.PUSH3, b''),    # x = iterable[index]
+            (Opcode.PICK, b''),
+            (Opcode.PICKITEM, b''),
+            (Opcode.ADD, b''),      # result += x
+            (Opcode.REVERSE3, b''),
+            (Opcode.INC, b''),      # index += 1
+            (Opcode.JMP, Integer(-15).to_byte_array(signed=True, min_length=1)),
+            (Opcode.DROP, b''),
+            (Opcode.DROP, b''),
+        ]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
         return None
-
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.builtin.interop.interop import Interop
-        return [
-            (Opcode.SWAP, b''),
-            (Opcode.OVER, b''),
-            (Opcode.PUSH1, b''),
-            (Opcode.PICKITEM, b''),
-            (Opcode.SWAP, b''),
-            (Opcode.CAT, b''),
-            (Opcode.SWAP, b''),
-            (Opcode.PUSH0, b''),
-            (Opcode.PICKITEM, b''),
-        ] + Interop.StoragePut.opcode
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/interop/storage/storagemap/storagemaptype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/storage/storagemap/storagemaptype.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classarraytype import ClassArrayType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classarraytype import ClassArrayType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class StorageMapType(ClassArrayType):
     """
     A class used to represent Neo StorageMap class
     """
 
@@ -20,47 +20,54 @@
         super().__init__('StorageMap')
 
         self._variables: Dict[str, Variable] = {}
         self._constructor: Method = None
         self._instance_methods: Dict[str, Method] = {}
 
     @property
-    def variables(self) -> Dict[str, Variable]:
+    def instance_variables(self) -> Dict[str, Variable]:
         return self._variables.copy()
 
     @property
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
+
+    @property
     def _all_variables(self) -> Dict[str, Variable]:
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext as StorageContextType
-        from boa3.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import \
+            _StorageContext as StorageContextType
+        from boa3.internal.model.type.type import Type
 
         private_variables = {
             '_context': Variable(StorageContextType),
-            '_prefix': Variable(Type.union.build([Type.bytes,
-                                                  Type.str
-                                                  ]))
+            '_prefix': Variable(Type.bytes)
         }
-        variables = self.variables.copy()
+        variables = super()._all_variables
         variables.update(private_variables)
         return variables
 
     @property
     def properties(self) -> Dict[str, Property]:
         return {}
 
     @property
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
+
+    @property
     def class_methods(self) -> Dict[str, Method]:
         return {}
 
     @property
     def instance_methods(self) -> Dict[str, Method]:
         # avoid recursive import
         if len(self._instance_methods) == 0:
-            from boa3.model.builtin.interop.storage.storagemap.storagemapdeletemethod import StorageMapDeleteMethod
-            from boa3.model.builtin.interop.storage.storagemap.storagemapgetmethod import StorageMapGetMethod
-            from boa3.model.builtin.interop.storage.storagemap.storagemapputmethod import StorageMapPutMethod
+            from boa3.internal.model.builtin.interop.storage.storagemap.storagemapdeletemethod import StorageMapDeleteMethod
+            from boa3.internal.model.builtin.interop.storage.storagemap.storagemapgetmethod import StorageMapGetMethod
+            from boa3.internal.model.builtin.interop.storage.storagemap.storagemapputmethod import StorageMapPutMethod
 
             self._instance_methods = {
                 'get': StorageMapGetMethod(),
                 'put': StorageMapPutMethod(),
                 'delete': StorageMapDeleteMethod()
             }
         return self._instance_methods
@@ -83,31 +90,30 @@
 
 _StorageMap = StorageMapType()
 
 
 class StorageMapMethod(IBuiltinMethod):
 
     def __init__(self, return_type: StorageMapType):
-        from boa3.model.type.type import Type
-        from boa3.model.builtin.interop.storage.storagecontext.storagecontexttype import _StorageContext as StorageContextType
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.builtin.interop.storage.storagecontext.storagecontexttype import \
+            _StorageContext as StorageContextType
 
         identifier = '-StorageMap__init__'
         args: Dict[str, Variable] = {
             'context': Variable(StorageContextType),
-            'prefix': Variable(Type.union.build([Type.bytes,
-                                                 Type.str
-                                                 ]))
+            'prefix': Variable(Type.bytes)
         }
         super().__init__(identifier, args, return_type=return_type)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         return len(params) == 0
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [
             (Opcode.PUSH2, b''),
             (Opcode.PACK, b'')
         ]
 
     @property
     def _args_on_stack(self) -> int:
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/absmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/math/sqrtmethod.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class AbsMethod(IBuiltinMethod):
+class SqrtMethod(IBuiltinMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'abs'
+        from boa3.internal.model.type.type import Type
+        identifier = 'sqrt'
         args: Dict[str, Variable] = {'val': Variable(Type.int)}
         super().__init__(identifier, args, return_type=Type.int)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.ABS, b'')]
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.SQRT, b'')]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
-        return None
+        return
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/builtinevent.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/builtinevent.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 import ast
 from abc import ABC
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.builtincallable import IBuiltinCallable
-from boa3.model.event import Event
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.event import Event
+from boa3.internal.model.variable import Variable
 
 
 class IBuiltinEvent(IBuiltinCallable, Event, ABC):
     def __init__(self, identifier: str, args: Dict[str, Variable] = None,
                  defaults: List[ast.AST] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None):
-        from boa3.model.type.type import Type
-        super().__init__(identifier, args, vararg, defaults, Type.none)
+                 vararg: Optional[Tuple[str, Variable]] = None,
+                 kwargs: Optional[Dict[str, Variable]] = None):
+        from boa3.internal.model.type.type import Type
+        super().__init__(identifier, args, vararg, kwargs, defaults, Type.none)
 
         # constructor of IBuiltinCallable and Event classes are conflicting
         self._identifier = identifier
         self.name = identifier
         self.args = args if args is not None else {}
         self.defaults = defaults if defaults is not None else []
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/builtinmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/builtinmethod.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,24 +1,25 @@
 from __future__ import annotations
 
 import ast
 from abc import ABC, abstractmethod
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.builtincallable import IBuiltinCallable
-from boa3.model.method import Method
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
 class IBuiltinMethod(IBuiltinCallable, Method, ABC):
     def __init__(self, identifier: str, args: Dict[str, Variable] = None,
                  defaults: List[ast.AST] = None, return_type: IType = None,
-                 vararg: Optional[Tuple[str, Variable]] = None):
-        super().__init__(identifier, args, vararg, defaults, return_type)
+                 vararg: Optional[Tuple[str, Variable]] = None,
+                 kwargs: Optional[Dict[str, Variable]] = None):
+        super().__init__(identifier, args, vararg, kwargs, defaults, return_type)
 
     @property
     def is_supported(self) -> bool:
         """
         Verifies if the builtin method is supported by the compiler
 
         :return: True if it is supported. False otherwise.
@@ -162,14 +163,24 @@
         """
         Return whether this method requires its parameters to be packed into an array
 
         :return: whether this method requires an array
         """
         return False
 
+    def evaluate_literal(self, *args: Any) -> Any:
+        """
+        Tries to evaluate the result during compile time. If it cannot be evaluated, returns Undefined.
+
+        :return: arguments to try to run the method
+        :rtype: Any
+        """
+        from boa3.internal.analyser.model.optimizer import Undefined
+        return Undefined
+
     @property
     def body(self) -> Optional[str]:
         """
         Gets the body of the method.
 
         :return: Return the code of the method body if there is no opcode. None otherwise.
         """
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/bytearraymethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/contract/contractmanifest/contractparameterdefinitiontype.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,76 +1,64 @@
-from typing import Any, Dict, List, Optional, Tuple
+from __future__ import annotations
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from typing import Any, Dict, Optional
 
+from boa3.internal.model.method import Method
+from boa3.internal.model.property import Property
+from boa3.internal.model.type.classes.classstructtype import ClassStructType
+from boa3.internal.model.variable import Variable
 
-class ByteArrayMethod(IBuiltinMethod):
 
-    def __init__(self, argument_type: IType = None):
-        from boa3.model.type.type import Type
-        if argument_type is None or not self.validate_parameters(argument_type):
-            argument_type = Type.none
+class ContractParameterDefinitionType(ClassStructType):
+    """
+    A class used to represent Neo ContractParameterDefinition class
+    """
 
-        identifier = 'bytearray'
-        args: Dict[str, Variable] = {'object': Variable(argument_type)}
-        super().__init__(identifier, args, return_type=Type.bytearray)
+    def __init__(self):
+        super().__init__('ContractParameterDefinition')
+        from boa3.internal.model.builtin.interop.contract.contractmanifest.contractparametertype import ContractParameterType
+        from boa3.internal.model.type.type import Type
 
-    @property
-    def _arg_object(self) -> Variable:
-        return self.args['object']
+        self._variables: Dict[str, Variable] = {
+            'name': Variable(Type.str),
+            'type': Variable(ContractParameterType.build())
+        }
+        self._constructor: Method = None
 
     @property
-    def identifier(self) -> str:
-        from boa3.model.type.type import Type
-        if self._arg_object.type is Type.none:
-            return self._identifier
-        return '-{0}_from_{1}'.format(self._identifier, self._arg_object.type._identifier)
-
-    def validate_parameters(self, *params: IExpression) -> bool:
-        if len(params) > 1:
-            return False
-        if len(params) == 0:
-            return True
+    def class_variables(self) -> Dict[str, Variable]:
+        return {}
 
-        from boa3.model.type.itype import IType
-        if not isinstance(params[0], (IExpression, IType)):
-            return False
-
-        param_type: IType = params[0].type if isinstance(params[0], IExpression) else params[0]
-        from boa3.model.type.type import Type
-        # TODO: change when building bytearray given size is implemented
-        return (isinstance(param_type, SequenceType)
-                and (param_type is Type.str
-                     or isinstance(param_type.value_type, type(Type.int))
-                     ))
+    @property
+    def instance_variables(self) -> Dict[str, Variable]:
+        return self._variables.copy()
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return []
+    def properties(self) -> Dict[str, Property]:
+        return {}
 
     @property
-    def is_supported(self) -> bool:
-        # TODO: change when building bytearray from string and int iterators are implemented
-        from boa3.model.type.type import Type
-        return self._arg_object.type is Type.bytes
+    def static_methods(self) -> Dict[str, Method]:
+        return {}
 
     @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+    def class_methods(self) -> Dict[str, Method]:
+        return {}
 
     @property
-    def _body(self) -> Optional[str]:
-        return
+    def instance_methods(self) -> Dict[str, Method]:
+        return {}
+
+    def constructor_method(self) -> Optional[Method]:
+        return self._constructor
+
+    @classmethod
+    def build(cls, value: Any = None) -> ContractParameterDefinitionType:
+        if value is None or cls._is_type_of(value):
+            return _ContractParameterDefinition
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, ContractParameterDefinitionType)
+
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if type(value) == type(self._arg_object.type):
-            return self
-        if isinstance(value, list):
-            value = value[0] if len(value) > 0 else None
-        if self.validate_parameters(value):
-            return ByteArrayMethod(value)
-        return super().build(value)
+_ContractParameterDefinition = ContractParameterDefinitionType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/createeventmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/createeventmethod.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 from typing import Any, Optional
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.type.AbiType import AbiType
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
 class CreateEventMethod(IBuiltinMethod):
     def __init__(self):
         import ast
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'CreateNewEvent'
         args = {
             'arguments': Variable(Type.list.build(Type.tuple)),
             'event_name': Variable(Type.str)
         }
         event_name_default = ast.parse("'{0}'".format(Type.str.default_value)
                                        ).body[0].value
@@ -34,15 +34,15 @@
 
 class __EventType(IType):
     """
     A class used to represent an Neo event
     """
 
     def __init__(self):
-        identifier = 'event'
+        identifier = 'Event'
         super().__init__(identifier)
 
     @property
     def abi_type(self) -> AbiType:
         return AbiType.Void
 
     @classmethod
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/ecpointmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/ecpointmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,77 +1,78 @@
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.compiler.codegenerator import get_bytes_count
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.ecpointtype import ECPointType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.compiler.codegenerator import get_bytes_count
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ECPointMethod(IBuiltinMethod):
 
     def __init__(self, return_type: ECPointType, argument_type: IType = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if argument_type is None or not self.validate_parameters(argument_type):
             argument_type = Type.none
 
         identifier = 'ECPoint'
         args: Dict[str, Variable] = {'arg': Variable(argument_type)}
 
         super().__init__(identifier, args, return_type=return_type)
 
     @property
     def _arg_arg(self) -> Variable:
         return self.args['arg']
 
     @property
     def identifier(self) -> str:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if self._arg_arg.type is Type.none:
             return self._identifier
         return '-{0}_from_{1}'.format(self._identifier, self._arg_arg.type._identifier)
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) > 1:
             return False
         if len(params) == 0:
             return True
 
-        from boa3.model.type.itype import IType
+        from boa3.internal.model.type.itype import IType
         if not isinstance(params[0], (IExpression, IType)):
             return False
 
         param_type: IType = params[0].type if isinstance(params[0], IExpression) else params[0]
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return Type.bytes.is_type_of(param_type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-        from boa3.neo.vm.type.StackItem import StackItemType
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        from boa3.internal.neo.vm.type.StackItem import StackItemType
 
         ECPOINT_SIZE = 33
 
         throw_if_invalid = [
             (Opcode.THROW, b''),
         ]
         check_bytestr_size = [
             (Opcode.DUP, b''),
             (Opcode.SIZE, b''),
             (Opcode.PUSHINT8, Integer(ECPOINT_SIZE).to_byte_array(signed=True)),
-            Opcode.get_jump_and_data(Opcode.JMPEQ, get_bytes_count(throw_if_invalid), jump_through=True),
+            OpcodeHelper.get_jump_and_data(Opcode.JMPEQ, get_bytes_count(throw_if_invalid), jump_through=True),
         ]
 
         return [
             (Opcode.CONVERT, StackItemType.ByteString),  # convert to ECPoint
             (Opcode.DUP, b''),
             (Opcode.ISNULL, b''),
-            Opcode.get_jump_and_data(Opcode.JMPIF, get_bytes_count(check_bytestr_size), jump_through=True),
+            OpcodeHelper.get_jump_and_data(Opcode.JMPIF, get_bytes_count(check_bytestr_size), jump_through=True),
         ] + check_bytestr_size + throw_if_invalid
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/exceptionmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/reversedtype.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,70 +1,53 @@
-import ast
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-
-
-class ExceptionMethod(IBuiltinMethod):
-
-    def __init__(self, argument_type: IType = None):
-        from boa3.model.type.type import Type
-        if argument_type is None or not self.validate_parameters(argument_type):
-            argument_type = Type.str
-
-        identifier = '-Exception'
-        args: Dict[str, Variable] = {'message': Variable(argument_type)}
-        default_message = "'{0}'".format(self.default_message) if argument_type is Type.str else "{0}"
-        default = ast.parse(default_message.format(argument_type.default_value)
-                            ).body[0].value
-        super().__init__(identifier, args, [default], return_type=Type.exception)
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
 
-    @property
-    def _arg_message(self) -> Variable:
-        return self.args['message']
+
+class ReversedType(SequenceType):
+    """
+    A class used to represent Python reversed type. It's represented as a Sequence instead of a Iterable.
+    """
+
+    def __init__(self, values_type: IType = None):
+        identifier = 'reversed'
+        values_type = self.filter_types(values_type)
+        super().__init__(identifier, values_type)
 
     @property
-    def default_message(self) -> str:
-        return 'usererror'
+    def default_value(self) -> Any:
+        return reversed([])
 
     @property
     def identifier(self) -> str:
         return self._identifier
 
-    def validate_parameters(self, *params: IExpression) -> bool:
-        if len(params) > 1:
-            return False
-        if len(params) == 0:
-            return True
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return cls(Type.reversed)
 
-        from boa3.model.type.itype import IType
-        if not isinstance(params[0], (IExpression, IType)):
-            return False
-
-        param_type: IType = params[0].type if isinstance(params[0], IExpression) else params[0]
-        return isinstance(param_type, PrimitiveType)
+    def is_valid_key(self, key_type: IType) -> bool:
+        return key_type == self.valid_key
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return []
+    def valid_key(self) -> IType:
+        from boa3.internal.model.type.type import Type
+        return Type.int
 
-    @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return type(value) is reversed or isinstance(value, ReversedType)
 
     @property
-    def _body(self) -> Optional[str]:
-        return
+    def can_reassign_values(self) -> bool:
+        return False
+
+    def __eq__(self, other) -> bool:
+        if type(self) != type(other):
+            return False
+        return self.value_type == other.value_type
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if type(value) == type(self._arg_message.type):
-            return self
-        if isinstance(value, list):
-            value = value[0] if len(value) > 0 else None
-        if self.validate_parameters(value):
-            return ExceptionMethod(value)
-        return super().build(value)
+    def __hash__(self):
+        return hash(self.identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/exitmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/interopevent.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,26 +1,30 @@
-from typing import Dict, List, Optional, Tuple
+import ast
+from abc import ABC
+from typing import Dict, List, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinevent import IBuiltinEvent
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ExitMethod(IBuiltinMethod):
+class InteropEvent(IBuiltinEvent, ABC):
 
-    def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'exit'
-        args: Dict[str, Variable] = {}
-        super().__init__(identifier, args, return_type=Type.none)
+    def __init__(self, identifier: str, sys_call: str,
+                 args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+        self._sys_call: str = sys_call
+        super().__init__(identifier, args, defaults)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.ABORT, b'')]
+    def interop_method_hash(self) -> bytes:
+        return self._method_hash(self._sys_call)
 
-    @property
-    def _args_on_stack(self) -> int:
-        return 0
+    def _method_hash(self, method_name: str) -> bytes:
+        from boa3.internal.constants import SIZE_OF_INT32
+        from boa3.internal.neo import cryptography
+        from boa3.internal.neo.vm.type.String import String
+
+        return cryptography.sha256(String(method_name).to_bytes())[:SIZE_OF_INT32]
 
     @property
-    def _body(self) -> Optional[str]:
-        return None
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.SYSCALL, self.interop_method_hash)]
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/isinstancemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/isinstancemethod.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,32 +1,32 @@
 from typing import Any, Dict, List, Optional, Tuple, Union
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class IsInstanceMethod(IBuiltinMethod):
 
     def __init__(self, target_type: IType = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'isinstance'
 
         args: Dict[str, Variable] = {
             'x': Variable(Type.any),
             'A_tuple': None
         }
 
         super().__init__(identifier, args, return_type=Type.bool)
 
-        from boa3.model.type.collection.sequence.tupletype import TupleType
-        from boa3.model.type.annotation.metatype import MetaType
-        from boa3.model.type.annotation.uniontype import UnionType
+        from boa3.internal.model.type.collection.sequence.tupletype import TupleType
+        from boa3.internal.model.type.annotation.metatype import MetaType
+        from boa3.internal.model.type.annotation.uniontype import UnionType
 
         if not isinstance(target_type, IType):
             instances = [Type.none]
         elif isinstance(target_type, TupleType) and isinstance(target_type.item_type, UnionType):
             instances = [typ.meta_type if isinstance(typ, MetaType) else typ
                          for typ in target_type.item_type.union_types]
         else:
@@ -41,15 +41,15 @@
                 if not any(tpe.raw_identifier == other.raw_identifier for other in new_list):
                     new_list.append(tpe)
 
         self._instances_type = new_list
 
     @property
     def identifier(self) -> str:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if (len(self._instances_type) == 0
                 or (len(self._instances_type) == 1 and self._instances_type[0] in (None, Type.none))
             ):
             return self._identifier
 
         types = list({tpe.raw_identifier for tpe in self._instances_type})
         types.sort()
@@ -57,15 +57,15 @@
 
     def args_to_be_generated(self) -> List[int]:
         args = [name for name, symbol in self.args.items() if isinstance(symbol, Variable)]
         return [list(self.args).index(key) for key in args]
 
     @property
     def is_supported(self) -> bool:
-        from boa3.model.type.classes.classtype import ClassType
+        from boa3.internal.model.type.classes.classtype import ClassType
         return not any(isinstance(param, ClassType) and len(param.is_instance_opcodes()) == 0
                        for param in self._instances_type)
 
     def not_supported_str(self, callable_id: str) -> str:
         types = (self._instances_type[0].identifier if len(self._instances_type) == 1
                  else '({0})'.format(', '.join([arg.identifier for arg in self._instances_type])))
 
@@ -78,29 +78,30 @@
     def validate_parameters(self, *params: Union[IExpression, IType]) -> bool:
         if len(params) != 2:
             return False
 
         return not any(not isinstance(param, (IExpression, IType)) for param in params)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
         if len(self._instances_type) == 0:
             return [
                 (Opcode.ISNULL, b'')
             ]
         else:
             opcodes = []
-            from boa3.model.type.type import Type
-            from boa3.neo.vm.type.Integer import Integer
+            from boa3.internal.model.type.type import Type
+            from boa3.internal.neo.vm.type.Integer import Integer
             types = self._instances_type.copy()
 
             jmps = []
             for check_instance in types[:-1]:
                 opcodes.append((Opcode.DUP, b''))
-                opcodes.extend(check_instance.is_instance_opcodes())
+                is_instance_opcodes = check_instance.is_instance_opcodes()
+                opcodes.extend(is_instance_opcodes)
 
                 jmps.append(len(opcodes))
                 opcodes.append((Opcode.JMPIF, b''))
 
             opcodes.extend(types[-1].is_instance_opcodes())
 
             last_index = len(opcodes)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/lenmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/type/primitive/inttype.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,50 +1,46 @@
-from typing import Any, Dict, List, Optional, Sized, Tuple
+from typing import Any
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-
-
-class LenMethod(IBuiltinMethod):
-
-    def __init__(self, collection_type: IType = None):
-        from boa3.model.type.type import Type
-        if not isinstance(collection_type, ICollectionType):
-            collection_type = Type.sequence
-
-        identifier = 'len'
-        args: Dict[str, Variable] = {'__o': Variable(collection_type)}
-        super().__init__(identifier, args, return_type=Type.int)
-
-    def validate_parameters(self, *params: IExpression) -> bool:
-        if len(params) != 1:
-            return False
-        if not isinstance(params[0], IExpression):
-            return False
-        return isinstance(params[0].type, SequenceType)
+from boa3.internal import constants
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
+
+
+class IntType(PrimitiveType):
+    """
+    A class used to represent Python int type
+    """
+
+    def __init__(self):
+        identifier = 'int'
+        super().__init__(identifier)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.SIZE, b'')]
+    def default_value(self) -> Any:
+        return int()
 
     @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+    def abi_type(self) -> AbiType:
+        return AbiType.Integer
 
     @property
-    def _body(self) -> Optional[str]:
-        return None
+    def stack_item(self) -> StackItemType:
+        return StackItemType.Integer
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if type(value) == type(self.args['__o'].type):
-            return self
-
-        if isinstance(value, Sized) and len(value) == 1:
-            value = value[0]
-        if isinstance(value, ICollectionType):
-            return LenMethod(value)
-        return super().build(value)
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+
+        from boa3.internal.model.builtin.builtin import Builtin
+
+        self._instance_methods[constants.INIT_METHOD_ID] = Builtin.IntInt
+
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return Type.int
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return type(value) is int or isinstance(value, IntType)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/maxmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/reversedmethod.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,135 +1,129 @@
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, Dict, Iterable, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.collection.sequence.tupletype import TupleType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-
-
-class MaxMethod(IBuiltinMethod):
-
-    def __init__(self, arg_value: Optional[IType] = None):
-        from boa3.model.type.type import Type
-        identifier = 'max'
-        allowed_types = Type.int
-        if not isinstance(arg_value, IType):
-            arg_value = allowed_types
-
-        args: Dict[str, Variable] = {
-            'args1': Variable(Type.int),
-            'args2': Variable(Type.int)
-        }
-        vararg = ('values', Variable(arg_value))
-        super().__init__(identifier, args, return_type=arg_value, vararg=vararg)
-        self._allowed_types = allowed_types
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
-    @property
-    def _arg_values(self) -> Variable:
-        return self._vararg[1]
 
-    def validate_parameters(self, *params: IExpression) -> bool:
-        if len(params) != 1:
-            return False
-        if not isinstance(params[0], IExpression):
-            return False
-        return isinstance(params[0].type, SequenceType)
+class ReversedMethod(IBuiltinMethod):
+    def __init__(self, args_type: SequenceType = None):
+        from boa3.internal.model.type.type import Type
+        identifier = 'reversed'
+        if not isinstance(args_type, SequenceType):
+            args_type = Type.sequence
+
+        args: Dict[str, Variable] = {'sequence': Variable(args_type)}
+
+        super().__init__(identifier, args, return_type=Type.reversed)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.compiler.codegenerator import get_bytes_count
-        from boa3.neo.vm.type.Integer import Integer
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
-        jmp_place_holder = (Opcode.JMP, b'\x01')
+    @property
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
+        if self.args['sequence'].type is Type.sequence:
+            return self.raw_identifier
+        return '-{0}_from_{1}'.format(self._identifier, self.args['sequence'].type.identifier)
 
-        verify_number_of_parameters = [     # verifies if the stack has 2 or 3 items
-            (Opcode.DEPTH, b''),
-            (Opcode.PUSH2, b''),
-            (Opcode.JMPEQ, b''),
-            jmp_place_holder
-        ]
+    def build(self, value: Any) -> IBuiltinMethod:
+        if isinstance(value, Iterable) and len(value) > 0:
+            value = value[0]
 
-        if_n_parameters_gt_2 = [         # if number of items in stack is 3 (2 ints and one tuple)
-            (Opcode.REVERSE3, b''),
-            (Opcode.UNPACK, b''),
-            (Opcode.INC, b''),
-            (Opcode.INC, b''),
-            jmp_place_holder    # skips the next block of instructions
-        ]
+        if not isinstance(value, SequenceType):
+            return ReversedMethod()
 
-        if_n_parameters_eq_2 = [        # if number of items in stack is 2 (2 ints)
-            (Opcode.PUSH2, b'')
-        ]
+        if type(value) == type(self.args['sequence'].type):
+            return self
 
-        jmp_n_parameters_eq_2 = Opcode.get_jump_and_data(Opcode.JMP, get_bytes_count(if_n_parameters_eq_2), True)
-        if_n_parameters_gt_2[-1] = jmp_n_parameters_eq_2
+        return ReversedMethod(value)
 
-        jmp_n_parameters_gt_2 = Opcode.get_jump_and_data(Opcode.JMPEQ, get_bytes_count(if_n_parameters_gt_2))
-        verify_number_of_parameters[-1] = jmp_n_parameters_gt_2
+    @property
+    def _body(self) -> Optional[str]:
+        return
 
-        repack_array = [        # pack all the arguments in the array
-            (Opcode.PACK, b''),
-        ]
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.compiler.codegenerator import get_bytes_count
+
+        jmp_place_holder = (Opcode.JMP, b'\x01')
 
-        is_int_initialize = [   # puts the last array element as the max value
-            (Opcode.DUP, b''),          # index = len(array) - 1
-            (Opcode.SIZE, b''),
-            (Opcode.DEC, b''),
-            (Opcode.OVER, b''),
-            (Opcode.OVER, b''),
-            (Opcode.PICKITEM, b''),     # max = array[index]
+        if_statement = [
+            (Opcode.DUP, b''),
+            (Opcode.ISTYPE, Type.str.stack_item),  # if isinstance(arg1, (str, bytes)) continue
+            # if not isinstance(arg1, (str, bytes)) will jump into the else_body
         ]
 
-        is_int_while = [    # this will get the next number in the array and compare it with the current max
-            (Opcode.SWAP, b''),         # index--
-            (Opcode.DEC, b''),
+        if_true_body = [    # if isinstance(arg1, (str, bytes)) body will continue until else_body
+            (Opcode.NEWARRAY0, b''),  # list_aux = []
             (Opcode.SWAP, b''),
+            (Opcode.DUP, b''),
+            (Opcode.SIZE, b''),       # limit = len(arg)
+            (Opcode.PUSH0, b''),      # index = 0
+        ]
+
+        while_statement = [           # index and limit will be at the top of the stack
+            (Opcode.DUP, b''),        # verifies if index < limit
             (Opcode.PUSH2, b''),
             (Opcode.PICK, b''),
+            (Opcode.LT, b''),
+            jmp_place_holder          # if index >= limit, go to break_opcode
+        ]
+
+        while_body = [                # will add every byte or character into the array and increase the index
+            (Opcode.PUSH3, b''),
+            (Opcode.PICK, b''),
+            (Opcode.PUSH3, b''),
+            (Opcode.PICK, b''),
             (Opcode.PUSH2, b''),
-            (Opcode.PICK, b''),         # max = max if max > array[index] else array[index]
-            (Opcode.PICKITEM, b''),
-            (Opcode.MAX, b''),
-            (Opcode.OVER, b''),
-            (Opcode.SIGN, b'')
-            # if index != 0: go back to index--
-            # else go to the end
+            (Opcode.PICK, b''),
+            (Opcode.PUSH1, b''),
+            (Opcode.SUBSTR, b''),
+            (Opcode.CONVERT,
+             Type.int.stack_item if Type.bytes.is_type_of(self.args['sequence'].type) else Type.str.stack_item),
+            (Opcode.APPEND, b''),    # list_aux.append(arg[index])
+            (Opcode.INC, b''),       # index++
+            # returns to beginning of the while to verify if it index < limit
         ]
 
-        jmp_back_to_while_statement = (Opcode.JMPIF, Integer(-get_bytes_count(is_int_while)).to_byte_array(signed=True))
-        is_int_while.append(jmp_back_to_while_statement)
+        jmp_back_to_while_statement = OpcodeHelper.get_jump_and_data(Opcode.JMP, -get_bytes_count(while_body + while_statement))
+        while_body.append(jmp_back_to_while_statement)
 
-        clean_stack = [    # removes everything but max
-            (Opcode.REVERSE3, b''),
+        jmp_to_break_body = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, get_bytes_count(while_body), True)
+        while_statement[-1] = jmp_to_break_body
+
+        break_opcode = [        # remove auxiliary values from stack after leaving `while`
+            (Opcode.DROP, b''),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
+            # skips the else_body, because it's a bytestring value and unpacking and packing are expensive
         ]
 
-        return (
-            verify_number_of_parameters +
-            if_n_parameters_gt_2 +
-            if_n_parameters_eq_2 +
-            repack_array +
-            is_int_initialize +
-            is_int_while +
-            clean_stack
-        )
+        else_body = [    # creates a new array from an array, used when the arg is not a str or bytes value
+            (Opcode.UNPACK, b''),
+            (Opcode.PACK, b''),
+        ]
 
-    @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
+        jmp_else_body = OpcodeHelper.get_jump_and_data(Opcode.JMP, get_bytes_count(else_body), True)
+        break_opcode.append(jmp_else_body)
 
-    @property
-    def _body(self) -> Optional[str]:
-        return
+        if_true_body = if_true_body + while_statement + while_body + break_opcode
 
-    def build(self, value: Any) -> IBuiltinMethod:
-        if isinstance(value, list) and len(value) > 0:
-            value = value[0]
-        if isinstance(value, TupleType):
-            value = value.value_type
-        if type(value) == type(self._arg_values.type):
-            return self
-        return MaxMethod(value)
+        jmp_if_true_body = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, get_bytes_count(if_true_body))
+        if_statement.append(jmp_if_true_body)
+
+        reverse_array = [   # reverse the array
+            (Opcode.DUP, b''),
+            (Opcode.REVERSEITEMS, b''),     # return reversed(arg)
+        ]
+
+        return (
+            if_statement +
+            if_true_body +
+            else_body +
+            reverse_array
+        )
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/minmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/uint160method.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,136 +1,128 @@
+import ast
 from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.collection.sequence.tupletype import TupleType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-
-
-class MinMethod(IBuiltinMethod):
-
-    def __init__(self, arg_value: Optional[IType] = None):
-        from boa3.model.type.type import Type
-        identifier = 'min'
-        allowed_types = Type.int
-        if not isinstance(arg_value, IType):
-            arg_value = allowed_types
-
-        args: Dict[str, Variable] = {
-            'args1': Variable(Type.int),
-            'args2': Variable(Type.int)
-        }
-        vararg = ('values', Variable(arg_value))
-        super().__init__(identifier, args, return_type=arg_value, vararg=vararg)
-        self._allowed_types = allowed_types
+from boa3.internal import constants
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.uint160type import UInt160Type
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+
+
+class UInt160Method(IBuiltinMethod):
+
+    def __init__(self, return_type: UInt160Type, argument_type: IType = None):
+        from boa3.internal.model.type.type import Type
+        if argument_type is None or not self.validate_parameters(argument_type):
+            argument_type = Type.none
+
+        identifier = 'UInt160'
+        args: Dict[str, Variable] = {'object': Variable(argument_type)}
+
+        args_default = ast.parse("{0}".format(Type.int.default_value)
+                                 ).body[0].value
+
+        super().__init__(identifier, args, [args_default], return_type=return_type)
 
     @property
-    def _arg_values(self) -> Variable:
-        return self._vararg[1]
+    def _arg_object(self) -> Variable:
+        return self.args['object']
 
     @property
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
+        if self._arg_object.type is Type.none:
+            return self._identifier
+        return '-{0}_from_{1}'.format(self._identifier, self._arg_object.type._identifier)
+
     def validate_parameters(self, *params: IExpression) -> bool:
-        if len(params) != 1:
+        if len(params) > 1:
             return False
-        if not isinstance(params[0], IExpression):
-            return False
-        return isinstance(params[0].type, SequenceType)
+        if len(params) == 0:
+            return True
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.compiler.codegenerator import get_bytes_count
-        from boa3.neo.vm.type.Integer import Integer
-
-        jmp_place_holder = (Opcode.JMP, b'\x01')
-
-        verify_number_of_parameters = [  # verifies if the stack has 2 or 3 items
-            (Opcode.DEPTH, b''),
-            (Opcode.PUSH2, b''),
-            (Opcode.JMPEQ, b''),
-            jmp_place_holder
-        ]
+        from boa3.internal.model.type.itype import IType
+        if not isinstance(params[0], (IExpression, IType)):
+            return False
 
-        if_n_parameters_gt_2 = [  # if number of items in stack is 3
-            (Opcode.REVERSE3, b''),
-            (Opcode.UNPACK, b''),
-            (Opcode.INC, b''),
-            (Opcode.INC, b''),
-            jmp_place_holder  # skips the next block of instructions
-        ]
+        param_type: IType = params[0].type if isinstance(params[0], IExpression) else params[0]
+        from boa3.internal.model.type.type import Type
 
-        if_n_parameters_eq_2 = [  # if number of items in stack is 2
-            (Opcode.PUSH2, b'')
-        ]
+        return (Type.bytes.is_type_of(param_type)
+                or Type.int.is_type_of(param_type))
 
-        jmp_n_parameters_eq_2 = Opcode.get_jump_and_data(Opcode.JMP, get_bytes_count(if_n_parameters_eq_2), True)
-        if_n_parameters_gt_2[-1] = jmp_n_parameters_eq_2
+    def evaluate_literal(self, *args: Any) -> Any:
+        from boa3.internal.neo3.core.types import UInt160
 
-        jmp_n_parameters_gt_2 = Opcode.get_jump_and_data(Opcode.JMPEQ, get_bytes_count(if_n_parameters_gt_2))
-        verify_number_of_parameters[-1] = jmp_n_parameters_gt_2
+        if len(args) == 0:
+            return UInt160.zero().to_array()
+
+        if len(args) == 1:
+            arg = args[0]
+            if isinstance(arg, int):
+                from boa3.internal.neo.vm.type.Integer import Integer
+                arg = Integer(arg).to_byte_array(min_length=UInt160._BYTE_LEN)
+            if isinstance(arg, bytes):
+                value = UInt160(arg).to_array()
+                return value
 
-        repack_array = [  # pack all the arguments in the array
-            (Opcode.PACK, b''),
-        ]
+        return super().evaluate_literal(*args)
 
-        is_int_initialize = [  # puts the last array element as the max value
-            (Opcode.DUP, b''),  # index = len(array) - 1
-            (Opcode.SIZE, b''),
-            (Opcode.DEC, b''),
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        from boa3.internal.model.type.type import Type
+
+        from boa3.internal.neo.vm.type.StackItem import StackItemType
+        return [
+            (Opcode.DUP, b''),
+            (Opcode.ISTYPE, Type.int.stack_item),  # if istype(arg, int):
+            (Opcode.JMPIFNOT, Integer(46).to_byte_array(signed=True)),
+            (Opcode.DUP, b''),                       # assert num >= 0
+            (Opcode.PUSH0, b''),
+            (Opcode.GE, b''),
+            (Opcode.ASSERT, b''),
+
+            (Opcode.DUP, b''),                       # if len(num) < 20
+            (Opcode.SIZE, b''),                        # increase number's length to 20
+            (Opcode.PUSHINT8, Integer(constants.SIZE_OF_INT160).to_byte_array(signed=True)),
             (Opcode.OVER, b''),
             (Opcode.OVER, b''),
-            (Opcode.PICKITEM, b''),     # min = array[index]
-        ]
 
-        is_int_while = [    # this will get the next number in the array and compare it with the current min
-            (Opcode.SWAP, b''),         # index--
-            (Opcode.DEC, b''),
-            (Opcode.SWAP, b''),
-            (Opcode.PUSH2, b''),
-            (Opcode.PICK, b''),
-            (Opcode.PUSH2, b''),
-            (Opcode.PICK, b''),         # min = min if min < array[index] else array[index]
-            (Opcode.PICKITEM, b''),
-            (Opcode.MIN, b''),
-            (Opcode.OVER, b''),
-            (Opcode.SIGN, b'')
-            # if index != 0: go back to index--
-            # else go to the end
-        ]
-
-        jmp_back_to_while_statement = (Opcode.JMPIF, Integer(-get_bytes_count(is_int_while)).to_byte_array(signed=True))
-        is_int_while.append(jmp_back_to_while_statement)
-
-        clean_stack = [    # removes everything but min
+            (Opcode.JMPGE, Integer(30).to_byte_array(signed=True)),
+            (Opcode.PUSHDATA1, (Integer(constants.SIZE_OF_INT160).to_byte_array(signed=True)
+                                + bytes(constants.SIZE_OF_INT160))),
             (Opcode.REVERSE3, b''),
+            (Opcode.SUB, b''),
+            (Opcode.LEFT, b''),
+            (Opcode.CAT, b''),
+
+            (Opcode.JMP, Integer(4).to_byte_array()),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
-        ]
 
-        return (
-            verify_number_of_parameters +
-            if_n_parameters_gt_2 +
-            if_n_parameters_eq_2 +
-            repack_array +
-            is_int_initialize +
-            is_int_while +
-            clean_stack
-        )
+            (Opcode.CONVERT, StackItemType.ByteString),  # convert to uint160
+            (Opcode.DUP, b''),
+            (Opcode.SIZE, b''),
+            (Opcode.PUSHINT8, Integer(constants.SIZE_OF_INT160).to_byte_array(signed=True)),
+            (Opcode.NUMEQUAL, b''),
+            (Opcode.ASSERT, b''),
+        ]
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
-        return None
+        return
 
     def build(self, value: Any) -> IBuiltinMethod:
-        if isinstance(value, list) and len(value) > 0:
-            value = value[0]
-        if isinstance(value, TupleType):
-            value = value.value_type
-        if type(value) == type(self._arg_values.type):
+        if type(value) == type(self._arg_object.type):
             return self
-        return MinMethod(value)
+        if isinstance(value, list):
+            value = value[0] if len(value) > 0 else None
+        if self.validate_parameters(value):
+            return UInt160Method(self.return_type, value)
+        return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/rangemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/rangemethod.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 import ast
 from typing import Any, Dict, List, Optional, Tuple, Union
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class RangeMethod(IBuiltinMethod):
 
     def __init__(self, values_types: List[IType] = None):
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         identifier = 'range'
         if not isinstance(values_types, list) or len(values_types) < 1:
             stop = Variable(Type.none)
             start = Variable(Type.none)
             step = Variable(Type.none)
         else:
             stop = Variable(Type.int)
@@ -34,15 +34,15 @@
 
     @property
     def _arg_stop(self) -> Variable:
         return self.args['stop']
 
     @property
     def identifier(self) -> str:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if self._arg_stop.type is Type.none:
             return self._identifier
         return '-{0}_from_{1}'.format(self._identifier, self._arg_stop.type._identifier)
 
     @property
     def requires_reordering(self) -> bool:
         return True
@@ -56,21 +56,21 @@
         if len(params) < 1 or len(params) > 3:
             return False
 
         if any(not isinstance(param, (IExpression, IType)) for param in params):
             return False
 
         params_type: List[IType] = [param if isinstance(param, IType) else param.type for param in params]
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return all(param is Type.int for param in params_type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
-        from boa3.neo.vm.type.String import String
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        from boa3.internal.neo.vm.type.String import String
         range_error_msg = String('range() arg 3 must not be zero').to_bytes()
         return [
             (Opcode.PUSH2, b''),
             (Opcode.PICK, b''),
             (Opcode.SIGN, b''),
             (Opcode.JMPIF, Integer(5 + len(range_error_msg)).to_byte_array(signed=True)),
             (Opcode.PUSHDATA1, Integer(len(range_error_msg)).to_byte_array(signed=True) + range_error_msg),
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/reversedmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/uint256method.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,128 +1,128 @@
-from typing import Any, Dict, Iterable, List, Optional, Tuple
+import ast
+from typing import Any, Dict, List, Optional, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal import constants
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.collection.sequence.uint256type import UInt256Type
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ReversedMethod(IBuiltinMethod):
-    def __init__(self, args_type: SequenceType = None):
-        from boa3.model.type.type import Type
-        identifier = 'reversed'
-        if not isinstance(args_type, SequenceType):
-            args_type = Type.sequence
+class UInt256Method(IBuiltinMethod):
 
-        args: Dict[str, Variable] = {'sequence': Variable(args_type)}
+    def __init__(self, return_type: UInt256Type, argument_type: IType = None):
+        from boa3.internal.model.type.type import Type
+        if argument_type is None or not self.validate_parameters(argument_type):
+            argument_type = Type.none
 
-        super().__init__(identifier, args, return_type=Type.reversed)
+        identifier = 'UInt256'
+        args: Dict[str, Variable] = {'object': Variable(argument_type)}
 
-    @property
-    def _args_on_stack(self) -> int:
-        return len(self.args)
-
-    @property
-    def identifier(self) -> str:
-        from boa3.model.type.type import Type
-        if self.args['sequence'].type is Type.sequence:
-            return self.raw_identifier
-        return '-{0}_from_{1}'.format(self._identifier, self.args['sequence'].type.identifier)
-
-    def build(self, value: Any) -> IBuiltinMethod:
-        if isinstance(value, Iterable) and len(value) > 0:
-            value = value[0]
-
-        if not isinstance(value, SequenceType):
-            return ReversedMethod()
-
-        if type(value) == type(self.args['sequence'].type):
-            return self
+        args_default = ast.parse("{0}".format(Type.int.default_value)
+                                 ).body[0].value
 
-        return ReversedMethod(value)
+        super().__init__(identifier, args, [args_default], return_type=return_type)
 
     @property
-    def _body(self) -> Optional[str]:
-        return
+    def _arg_object(self) -> Variable:
+        return self.args['object']
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.type.type import Type
-        from boa3.compiler.codegenerator import get_bytes_count
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
+        if self._arg_object.type is Type.none:
+            return self._identifier
+        return '-{0}_from_{1}'.format(self._identifier, self._arg_object.type._identifier)
+
+    def validate_parameters(self, *params: IExpression) -> bool:
+        if len(params) > 1:
+            return False
+        if len(params) == 0:
+            return True
+
+        from boa3.internal.model.type.itype import IType
+        if not isinstance(params[0], (IExpression, IType)):
+            return False
+
+        param_type: IType = params[0].type if isinstance(params[0], IExpression) else params[0]
+        from boa3.internal.model.type.type import Type
+
+        return (Type.bytes.is_type_of(param_type)
+                or Type.int.is_type_of(param_type))
+
+    def evaluate_literal(self, *args: Any) -> Any:
+        from boa3.internal.neo3.core.types import UInt256
+
+        if len(args) == 0:
+            return UInt256.zero().to_array()
+
+        if len(args) == 1:
+            arg = args[0]
+            if isinstance(arg, int):
+                from boa3.internal.neo.vm.type.Integer import Integer
+                arg = Integer(arg).to_byte_array(min_length=UInt256._BYTE_LEN)
+            if isinstance(arg, bytes):
+                value = UInt256(arg).to_array()
+                return value
 
-        jmp_place_holder = (Opcode.JMP, b'\x01')
+        return super().evaluate_literal(*args)
 
-        if_statement = [
-            (Opcode.DUP, b''),
-            (Opcode.ISTYPE, Type.str.stack_item),  # if isinstance(arg1, (str, bytes)) continue
-            # if not isinstance(arg1, (str, bytes)) will jump into the else_body
-        ]
+    @property
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        from boa3.internal.model.type.type import Type
 
-        if_true_body = [    # if isinstance(arg1, (str, bytes)) body will continue until else_body
-            (Opcode.NEWARRAY0, b''),  # list_aux = []
-            (Opcode.SWAP, b''),
+        from boa3.internal.neo.vm.type.StackItem import StackItemType
+        return [
             (Opcode.DUP, b''),
-            (Opcode.SIZE, b''),       # limit = len(arg)
-            (Opcode.PUSH0, b''),      # index = 0
-        ]
-
-        while_statement = [           # index and limit will be at the top of the stack
-            (Opcode.DUP, b''),        # verifies if index < limit
-            (Opcode.PUSH2, b''),
-            (Opcode.PICK, b''),
-            (Opcode.LT, b''),
-            jmp_place_holder          # if index >= limit, go to break_opcode
-        ]
+            (Opcode.ISTYPE, Type.int.stack_item),  # if istype(arg, int):
+            (Opcode.JMPIFNOT, Integer(56).to_byte_array(signed=True)),
+            (Opcode.DUP, b''),                       # assert num >= 0
+            (Opcode.PUSH0, b''),
+            (Opcode.GE, b''),
+            (Opcode.ASSERT, b''),
+
+            (Opcode.DUP, b''),                       # if len(num) < 32
+            (Opcode.SIZE, b''),                        # increase number's length to 32
+            (Opcode.PUSHINT8, Integer(constants.SIZE_OF_INT256).to_byte_array(signed=True)),
+            (Opcode.OVER, b''),
+            (Opcode.OVER, b''),
+
+            (Opcode.JMPGE, Integer(44).to_byte_array(signed=True)),
+            (Opcode.PUSHDATA1, (Integer(constants.SIZE_OF_INT256).to_byte_array(signed=True)
+                                + bytes(constants.SIZE_OF_INT256))),
+            (Opcode.REVERSE3, b''),
+            (Opcode.SUB, b''),
+            (Opcode.LEFT, b''),
+            (Opcode.CAT, b''),
 
-        while_body = [                # will add every byte or character into the array and increase the index
-            (Opcode.PUSH3, b''),
-            (Opcode.PICK, b''),
-            (Opcode.PUSH3, b''),
-            (Opcode.PICK, b''),
-            (Opcode.PUSH2, b''),
-            (Opcode.PICK, b''),
-            (Opcode.PUSH1, b''),
-            (Opcode.SUBSTR, b''),
-            (Opcode.CONVERT,
-             Type.int.stack_item if Type.bytes.is_type_of(self.args['sequence'].type) else Type.str.stack_item),
-            (Opcode.APPEND, b''),    # list_aux.append(arg[index])
-            (Opcode.INC, b''),       # index++
-            # returns to beginning of the while to verify if it index < limit
-        ]
-
-        jmp_back_to_while_statement = Opcode.get_jump_and_data(Opcode.JMP, -get_bytes_count(while_body + while_statement))
-        while_body.append(jmp_back_to_while_statement)
-
-        jmp_to_break_body = Opcode.get_jump_and_data(Opcode.JMPIFNOT, get_bytes_count(while_body), True)
-        while_statement[-1] = jmp_to_break_body
-
-        break_opcode = [        # remove auxiliary values from stack after leaving `while`
-            (Opcode.DROP, b''),
+            (Opcode.JMP, Integer(4).to_byte_array()),
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
-            # skips the else_body, because it's a bytestring value and unpacking and packing are expensive
-        ]
 
-        else_body = [    # creates a new array from an array, used when the arg is not a str or bytes value
-            (Opcode.UNPACK, b''),
-            (Opcode.PACK, b''),
+            (Opcode.CONVERT, StackItemType.ByteString),  # convert to uint256
+            (Opcode.DUP, b''),
+            (Opcode.SIZE, b''),
+            (Opcode.PUSHINT8, Integer(constants.SIZE_OF_INT256).to_byte_array(signed=True)),
+            (Opcode.NUMEQUAL, b''),
+            (Opcode.ASSERT, b''),
         ]
 
-        jmp_else_body = Opcode.get_jump_and_data(Opcode.JMP, get_bytes_count(else_body), True)
-        break_opcode.append(jmp_else_body)
-
-        if_true_body = if_true_body + while_statement + while_body + break_opcode
-
-        jmp_if_true_body = Opcode.get_jump_and_data(Opcode.JMPIFNOT, get_bytes_count(if_true_body))
-        if_statement.append(jmp_if_true_body)
+    @property
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
-        reverse_array = [   # reverse the array
-            (Opcode.DUP, b''),
-            (Opcode.REVERSEITEMS, b''),     # return reversed(arg)
-        ]
+    @property
+    def _body(self) -> Optional[str]:
+        return
 
-        return (
-            if_statement +
-            if_true_body +
-            else_body +
-            reverse_array
-        )
+    def build(self, value: Any) -> IBuiltinMethod:
+        if type(value) == type(self._arg_object.type):
+            return self
+        if isinstance(value, list):
+            value = value[0] if len(value) > 0 else None
+        if self.validate_parameters(value):
+            return UInt256Method(self.return_type, value)
+        return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/sqrtmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/oracle/oraclegetpricemethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,24 @@
-from typing import Dict, List, Optional, Tuple
+from typing import Dict, Optional
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.interop.nativecontract import OracleMethod
+from boa3.internal.model.variable import Variable
 
 
-class SqrtMethod(IBuiltinMethod):
+class OracleGetPriceMethod(OracleMethod):
 
     def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'sqrt'
-        args: Dict[str, Variable] = {'val': Variable(Type.int)}
-        super().__init__(identifier, args, return_type=Type.int)
+        from boa3.internal.model.type.type import Type
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.SQRT, b'')]
+        identifier = 'get_price'
+        syscall = 'getPrice'
+        args: Dict[str, Variable] = {}
+
+        super().__init__(identifier, syscall, args, return_type=Type.int)
 
     @property
     def _args_on_stack(self) -> int:
         return len(self.args)
 
     @property
     def _body(self) -> Optional[str]:
-        return
+        return None
```

### Comparing `neo3-boa-0.9.0/boa3/model/builtin/method/strsplitmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/classmethod/popdictdefaultmethod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,103 +1,88 @@
-import ast
-from typing import Dict, List, Tuple
+from typing import Dict, List, Optional, Tuple
 
-from boa3.model.builtin.interop.nativecontract import StdLibMethod
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.builtin.classmethod.popmethod import PopMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class StrSplitMethod(StdLibMethod):
-    def __init__(self):
-        from boa3.model.type.type import Type
-        identifier = 'split'
-        syscall = 'stringSplit'
+class PopDictDefaultMethod(PopMethod):
+
+    def __init__(self, arg_value: Optional[IType] = None):
+        from boa3.internal.model.type.type import Type
+
+        if not Type.dict.is_type_of(arg_value):
+            arg_value = Type.dict
+
         args: Dict[str, Variable] = {
-            'self': Variable(Type.str),
-            'sep': Variable(Type.str),
-            'maxsplit': Variable(Type.int)
+            'self': Variable(arg_value),
+            'key': Variable(arg_value.valid_key),
+            'default': Variable(Type.any)
         }
-        # whitespace is the default separator
-        separator_default = ast.parse("' '").body[0].value
-        # maxsplit the default value is -1
-        maxsplit_default = ast.parse("-1").body[0].value.operand
-        maxsplit_default.n = -1
 
-        super().__init__(identifier, syscall, args, defaults=[separator_default, maxsplit_default],
-                         return_type=Type.list.build_collection(Type.str))
+        super().__init__(args, return_type=arg_value.value_type)
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.compiler.codegenerator import get_bytes_count
-        from boa3.model.type.type import Type
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.neo.vm.type.Integer import Integer
+        from boa3.internal.compiler.codegenerator import get_bytes_count
 
         jmp_place_holder = (Opcode.JMP, b'\x01')
 
-        preserver_args_from_array = [   # copies split and maxsplit args on the stack
-            (Opcode.DUP, b''),
-            (Opcode.PUSH1, b''),
-            (Opcode.PICKITEM, b''),
+        put_default_at_bottom = [
+            (Opcode.REVERSE3, b''),
             (Opcode.SWAP, b''),
-            (Opcode.UNPACK, b''),
-            (Opcode.DEC, b''),
-            (Opcode.PACK, b'')
+            (Opcode.REVERSE3, b''),
         ]
 
-        neo_strsplit_method = super().opcode
-
-        verify_maxsplit = [     # verifies if there is a maxsplit
-            (Opcode.OVER, b''),
+        prepare_values = [
+            (Opcode.DUP, b''),
+            (Opcode.SIGN, b''),
             (Opcode.PUSHM1, b''),
-            jmp_place_holder    # if maxsplit <= -1 skip concatenation and clean the stack
+            (Opcode.JMPNE, Integer(5).to_byte_array(min_length=1, signed=True)),
+            (Opcode.OVER, b''),
+            (Opcode.SIZE, b''),
+            (Opcode.ADD, b''),
+            (Opcode.OVER, b''),
+            (Opcode.OVER, b''),
         ]
 
-        while_verify = [        # verifies if len(array) <= maxsplit + 1, if it is jump out of while
-            (Opcode.DUP, b''),
-            (Opcode.SIZE, b''),
-            (Opcode.PUSH2, b''),
-            (Opcode.PICK, b''),
-            (Opcode.INC, b''),
-            jmp_place_holder    # go clean the stack
+        verify_has_key = [
+            (Opcode.HASKEY, b''),
+            jmp_place_holder
         ]
 
-        concatenate_array = [
-            (Opcode.DUP, b''),
-            (Opcode.PUSH3, b''),
-            (Opcode.PICK, b''),
+        pick_from_dict = [
             (Opcode.OVER, b''),
-            (Opcode.POPITEM, b''),
-            (Opcode.CAT, b''),
             (Opcode.OVER, b''),
-            (Opcode.POPITEM, b''),
+            (Opcode.PICKITEM, b''),
+            (Opcode.REVERSE3, b''),
             (Opcode.SWAP, b''),
-            (Opcode.CAT, b''),
-            (Opcode.CONVERT, Type.str.stack_item),
-            (Opcode.APPEND, b''),
-            # go to while_verify
         ]
 
-        num_jmp_code = -get_bytes_count(while_verify + concatenate_array)
-        jmp_back_to_while = Opcode.get_jump_and_data(Opcode.JMP, num_jmp_code)
-        concatenate_array.append(jmp_back_to_while)
-
-        num_jmp_code = get_bytes_count(while_verify + concatenate_array)
-        jmp_to_clean_from_verify_maxsplit = Opcode.get_jump_and_data(Opcode.JMPLE, num_jmp_code, True)
-        verify_maxsplit[-1] = jmp_to_clean_from_verify_maxsplit
-
-        num_jmp_code = get_bytes_count(concatenate_array)
-        jmp_to_clean_from_while_verify = Opcode.get_jump_and_data(Opcode.JMPLE, num_jmp_code, True)
-        while_verify[-1] = jmp_to_clean_from_while_verify
+        pop_from_dict = [
+            (Opcode.REMOVE, b''),
+            (Opcode.NIP, b''),
+            jmp_place_holder
+        ]
 
-        clean_stack = [
-            (Opcode.REVERSE3, b''),
+        return_default = [
             (Opcode.DROP, b''),
             (Opcode.DROP, b''),
         ]
 
+        num_jmp_code = get_bytes_count(return_default)
+        pop_from_dict[-1] = OpcodeHelper.get_jump_and_data(Opcode.JMP, num_jmp_code, True)
+
+        num_jmp_code = get_bytes_count(pick_from_dict + pop_from_dict)
+        verify_has_key[-1] = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, num_jmp_code, True)
+
         return (
-            preserver_args_from_array +
-            neo_strsplit_method +
-            verify_maxsplit +
-            while_verify +
-            concatenate_array +
-            clean_stack
+            put_default_at_bottom +
+            prepare_values +
+            verify_has_key +
+            pick_from_dict +
+            pop_from_dict +
+            return_default
         )
```

### Comparing `neo3-boa-0.9.0/boa3/model/callable.py` & `neo3-boa-1.0.0/boa3/internal/model/callable.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,45 +1,52 @@
+from __future__ import annotations
+
 import ast
 from abc import ABC
-from typing import Dict, List, Optional, Tuple
+from typing import Dict, List, Optional, Set, Tuple
 
-from boa3.model import set_internal_call
-from boa3.model.expression import IExpression
-from boa3.model.type.type import IType, Type
-from boa3.model.variable import Variable
-from boa3.neo.vm.VMCode import VMCode
+from boa3.internal.model import set_internal_call
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.VMCode import VMCode
 
 
 class Callable(IExpression, ABC):
     """
     A class used to represent a function or a class method
 
     :ivar args: a dictionary that maps each arg with its name. Empty by default.
     :ivar is_public: a boolean value that specifies if the method is public. False by default.
     :ivar return_type: the return type of the method. None by default.
     """
 
     def __init__(self, args: Dict[str, Variable] = None,
                  vararg: Optional[Tuple[str, Variable]] = None,
+                 kwargs: Optional[Dict[str, Variable]] = None,
                  defaults: List[ast.AST] = None,
                  return_type: IType = Type.none, is_public: bool = False,
+                 decorators: List[Callable] = None,
+                 external_name: str = None,
+                 is_safe: bool = False,
                  origin_node: Optional[ast.AST] = None):
+
         if args is None:
             args = {}
         self.args: Dict[str, Variable] = args.copy()
 
         if not isinstance(defaults, list):
             defaults = []
         self.defaults: List[ast.AST] = defaults
 
         self._vararg: Optional[Tuple[str, Variable]] = None
         if (isinstance(vararg, tuple) and len(vararg) == 2
                 and isinstance(vararg[0], str) and isinstance(vararg[1], Variable)):
 
-            from boa3.model.type.typeutils import TypeUtils
+            from boa3.internal.model.type.typeutils import TypeUtils
 
             vararg_id, vararg_var = vararg
             if vararg_var.type is not Type.any:
                 default_code = "{0}({1}, {2})".format(TypeUtils.cast.raw_identifier,
                                                       Type.tuple.build_collection(vararg_var.type),
                                                       Type.tuple.default_value)
             else:
@@ -47,16 +54,42 @@
 
             default_value = set_internal_call(ast.parse(default_code).body[0].value)
 
             self.args[vararg_id] = Variable(Type.tuple.build_collection([vararg_var.type]))
             self.defaults.append(default_value)
             self._vararg = vararg
 
+        if kwargs is None:
+            kwargs = {}
+        self._kwargs: Dict[str, Variable] = kwargs.copy()
+
         self.return_type: IType = return_type
-        self.is_public: bool = is_public
+
+        if decorators is None:
+            decorators = []
+        from boa3.internal.model.decorator import IDecorator
+        self.decorators: List[IDecorator] = [decorator for decorator in decorators
+                                             if isinstance(decorator, IDecorator)]
+
+        from boa3.internal.model.builtin.decorator import PublicDecorator
+        public_decorator = next((decorator for decorator in self.decorators
+                                 if isinstance(decorator, PublicDecorator)),
+                                None)
+
+        self.is_public: bool = is_public or public_decorator is not None
+        if self.is_public:
+            if isinstance(public_decorator, PublicDecorator):
+                external_name = public_decorator.name
+            elif self.defined_by_entry:
+                external_name = None
+
+        self.external_name: Optional[str] = external_name
+        self.is_safe: bool = is_safe or (isinstance(public_decorator, PublicDecorator) and public_decorator.safe)
+
+        self._self_calls: Set[ast.AST] = set()
 
         super().__init__(origin_node)
 
         self.init_address: Optional[int] = None
         self.init_bytecode: Optional[VMCode] = None
         self.init_defaults_bytecode: Optional[VMCode] = None
         self.end_bytecode: Optional[VMCode] = None
@@ -78,28 +111,39 @@
     def args_without_default(self) -> Dict[str, Variable]:
         num_defaults = len(self.defaults)
         if num_defaults > 0:
             return {key: self.args[key] for key in list(self.args.keys())[:-num_defaults]}
         return self.args
 
     @property
+    def has_cls_or_self(self) -> bool:
+        return any(decorator.has_cls_or_self for decorator in self.decorators)
+
+    @property
+    def cls_or_self_type(self) -> Optional[IType]:
+        if not self.has_cls_or_self or len(self.args) == 0:
+            return None
+
+        return list(self.args.values())[0].type
+
+    @property
     def has_starred_argument(self) -> bool:
         return self._vararg is not None
 
     @property
     def start_address(self) -> Optional[int]:
         """
         Gets the address where this method starts in the bytecode
 
         :return: the first address of the method
         """
         if self.init_bytecode is None and self.init_defaults_bytecode is None:
             return self.init_address
         else:
-            from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
+            from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
             return VMCodeMapping.instance().get_start_address(self.init_bytecode)
 
     @property
     def start_bytecode(self) -> Optional[VMCode]:
         return (self.init_defaults_bytecode if len(self.defaults) > 0
                 else self.init_bytecode)
 
@@ -109,18 +153,40 @@
         Gets the address of this method's last operation in the bytecode
 
         :return: the last address of the method
         """
         if self.end_bytecode is None:
             return self.start_address
         else:
-            from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
+            from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
             return VMCodeMapping.instance().get_end_address(self.end_bytecode)
 
+    @property
+    def is_called(self) -> bool:
+        return len(self._self_calls) > 0
+
+    def reset_calls(self):
+        self._self_calls.clear()
+
+    @property
+    def is_compiled(self) -> bool:
+        return self.start_address is not None and self.end_address is not None
+
+    def add_call_origin(self, origin: ast.AST) -> bool:
+        try:
+            self._self_calls.add(origin)
+            return True
+        except BaseException:
+            return False
+
     def __str__(self) -> str:
         args_types: List[str] = [str(arg.type) for arg in self.args.values()]
         if self.return_type is not Type.none:
             signature = '({0}) -> {1}'.format(', '.join(args_types), self.return_type)
         else:
             signature = '({0})'.format(', '.join(args_types))
         public = 'public ' if self.is_public else ''
         return '{0}{1}'.format(public, signature)
+
+    def __repr__(self) -> str:
+        name = self.identifier if hasattr(self, 'identifier') else self.__class__.__name__
+        return f'{name}{str(self)}'
```

### Comparing `neo3-boa-0.9.0/boa3/model/debuginstruction.py` & `neo3-boa-1.0.0/boa3/internal/model/debuginstruction.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from __future__ import annotations
 
 import ast
 
-from boa3.neo.vm.VMCode import VMCode
+from boa3.internal.neo.vm.VMCode import VMCode
 
 
 class DebugInstruction:
     def __init__(self, code: VMCode, start_line: int, start_col: int, end_line: int = None, end_col: int = None):
         if end_line is None or end_line < start_line:
             end_line = start_line
         if end_col is None or end_col < end_col:
@@ -22,9 +22,9 @@
         return '{0}:{1}-{2}:{3} {4}'.format(self.start_line, self.start_col,
                                             self.end_line, self.end_col,
                                             self.code)
 
     @classmethod
     def build(cls, ast_node: ast.AST, bytecode: VMCode) -> DebugInstruction:
         end_line: int = ast_node.end_lineno if hasattr(ast_node, 'end_lineno') else ast_node.lineno
-        end_col: int = ast_node.end_col_offset if hasattr(ast_node, 'end_lineno') else ast_node.col_offset
+        end_col: int = ast_node.end_col_offset + 1 if hasattr(ast_node, 'end_lineno') else ast_node.col_offset
         return cls(bytecode, ast_node.lineno, ast_node.col_offset, end_line, end_col)
```

### Comparing `neo3-boa-0.9.0/boa3/model/event.py` & `neo3-boa-1.0.0/boa3/internal/model/event.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,32 +1,37 @@
 import ast
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.callable import Callable
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.type.type import Type
-from boa3.model.variable import Variable
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.type.type import Type
+from boa3.internal.model.variable import Variable
 
 
 class Event(Callable, IdentifiedSymbol):
     def __init__(self, event_id: str, args: Dict[str, Variable] = None,
-                 vararg: Optional[Tuple[str, Variable]] = None, defaults: List[ast.AST] = None,
+                 vararg: Optional[Tuple[str, Variable]] = None,
+                 kwargs: Optional[Dict[str, Variable]] = None,
+                 defaults: List[ast.AST] = None,
                  origin_node: Optional[ast.AST] = None):
-        super().__init__(args, vararg, defaults, Type.none, True, origin_node)
+        super().__init__(args, vararg, kwargs, defaults, Type.none, True, origin_node)
 
         self.name: str = event_id
-        self._identifier: str = self.name
+        self._identifier: str = None
 
     @property
     def shadowing_name(self) -> str:
         return 'event'
 
     @property
     def identifier(self) -> str:
-        return self.name
+        if self._identifier is None:
+            # internal identifier should not be the name to avoid nonexistent duplicated symbol ids
+            self._identifier = f'-{self.name}-{hex(id(self))}'
+        return self._identifier
 
     @property
     def args_to_generate(self) -> Dict[str, Variable]:
         return self.args.copy()
 
     @property
     def generate_name(self) -> bool:
```

### Comparing `neo3-boa-0.9.0/boa3/model/expression.py` & `neo3-boa-1.0.0/boa3/internal/model/expression.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import ast
 from abc import abstractmethod
 from typing import Optional
 
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
 
 
 class IExpression(ISymbol):
     """
     An interface used to represent expressions
     """
```

### Comparing `neo3-boa-0.9.0/boa3/model/identifiedsymbol.py` & `neo3-boa-1.0.0/boa3/internal/model/identifiedsymbol.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from abc import ABC
 
-from boa3.model.symbol import ISymbol
+from boa3.internal.model.symbol import ISymbol
 
 
 class IdentifiedSymbol(ISymbol, ABC):
     """
     A class to represent a symbol with a name identifier attached to it
 
     :return: the resulting type when the expression is evaluated
```

### Comparing `neo3-boa-0.9.0/boa3/model/imports/builtin.py` & `neo3-boa-1.0.0/boa3/internal/model/imports/package.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,123 +1,131 @@
 from __future__ import annotations
 
-from typing import Dict, List, Optional, Tuple, Union
+from typing import Dict, List, Optional
 
-from boa3.model.builtin.builtin import Builtin
-from boa3.model.builtin.interop.interop import Interop
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.imports.package import Package
-from boa3.model.symbol import ISymbol
-from boa3.model.type.typeutils import TypeUtils
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
 
-__all__ = ['get_package',
-           'get_internal_symbol'
-           ]
 
-
-def get_package(package_full_path: str) -> Optional[Package]:
-    return CompilerBuiltin.instance().get_package(package_full_path)
-
-
-def get_internal_symbol(symbol_id: str) -> Optional[ISymbol]:
-    return CompilerBuiltin.instance().get_internal_symbol(symbol_id)
-
-
-class CompilerBuiltin:
-
-    _instance = None
-
-    @classmethod
-    def instance(cls) -> CompilerBuiltin:
-        if cls._instance is None:
-            cls._instance = cls()
-        return cls._instance
-
-    def __init__(self):
-        self.packages: List[Package] = []
-
-        self._generate_builtin_package('typing', TypeUtils.get_types_from_typing_lib())
-        self._generate_builtin_package('boa3.builtin', Builtin.boa_builtins)
-        self._generate_builtin_package('boa3.builtin.contract', Builtin.package_symbols('contract'))
-        self._generate_builtin_package('boa3.builtin.interop', Interop.package_symbols)
-        self._generate_builtin_package('boa3.builtin.type', Builtin.package_symbols('type'))
-
-    def _generate_builtin_package(self, package_full_path: str,
-                                  symbols: Union[Dict[str, ISymbol], List[IdentifiedSymbol]] = None):
-        if isinstance(symbols, list):
-            symbols = {symbol.identifier: symbol for symbol in symbols}
-        if not isinstance(symbols, dict):
-            symbols = {}
-
-        package_ids = package_full_path.split('.')
-        cur_package: Package = None
-
-        for package_id in package_ids:
-            package = None
-
-            if isinstance(cur_package, Package):
-                if package_id in cur_package.symbols:
-                    package = cur_package.symbols[package_id]
+class Package(IdentifiedSymbol):
+    """
+    A class used to represent a Python module.
+
+    :ivar properties: a list that stores every property in the package. Empty by default.
+    :ivar methods: a list that stores every method in the package. Empty by default.
+    :ivar types: a list that stores every property in the package. Empty by default.
+    """
+
+    def __init__(self, identifier: str,
+                 properties: List[IdentifiedSymbol] = None,
+                 methods: List[IdentifiedSymbol] = None,
+                 types: List[IdentifiedSymbol] = None,
+                 packages: List[Package] = None,
+                 other_symbols: dict = None,
+                 import_origin=None
+                 ):
+        """
+        :param packages: a list that stores the inner packages and modules of this package. Empty by default.
+        :param other_symbols: a dictionary with other symbols that are evaluated during the compilation. Empty by
+          default. Should be None for builtin packages.
+        :type other_symbols: dict or None
+        :param import_origin: the analyser that generated this package. Should be None for builtin packages.
+        :type import_origin: boa3.internal.model.imports.importsymbol.Import
+        """
+
+        from enum import Enum
+        if isinstance(identifier, Enum):
+            identifier = identifier.value
+
+        super().__init__(identifier)
+
+        self._all_symbols: List[IdentifiedSymbol] = []
+
+        if methods is None:
+            methods = []
+        self._all_symbols.extend(methods)
+
+        if properties is None:
+            properties = []
+        self._all_symbols.extend(properties)
+
+        if types is None:
+            types = []
+        self._all_symbols.extend(types)
+
+        if packages is None:
+            packages = []
+        self._packages = packages
+        for package in packages:
+            package._parent = self
+
+        # for packages that are not builtin
+        if isinstance(other_symbols, dict):
+            from boa3.internal.model.symbol import ISymbol
+            self._additional_symbols = {key: value
+                                        for key, value in other_symbols.items()
+                                        if (value not in self._all_symbols
+                                            and isinstance(key, str)
+                                            and isinstance(value, ISymbol))}
+            self.origin = import_origin
+        else:
+            self._additional_symbols = {}
+            self.origin = None
+
+        self._aliases: Dict[str, str] = {}
+        self._parent: Optional[Package] = None
+
+    @property
+    def shadowing_name(self) -> str:
+        return 'package'
+
+    @property
+    def symbols(self) -> Dict[str, IdentifiedSymbol]:
+        """
+        Gets all the symbols in the package.
+
+        :return: a list that stores every symbol in the package
+        """
+        symbol_map = {(self._aliases[symbol.raw_identifier]
+                       if symbol.raw_identifier in self._aliases
+                       else symbol.raw_identifier): symbol
+                      for symbol in self._all_symbols}
+        symbol_map.update(self._additional_symbols)
+        return symbol_map
+
+    @property
+    def inner_packages(self) -> Dict[str, Package]:
+        return {symbol.raw_identifier: symbol for symbol in self._packages}
+
+    @property
+    def parent(self) -> Optional[Package]:
+        """
+        Get the parent package of this one. None if it's the root package.
+        """
+        return self._parent
+
+    def include_symbol(self, symbol_id, symbol: IdentifiedSymbol):
+        identifier = symbol.raw_identifier if isinstance(symbol, IdentifiedSymbol) else symbol_id
+        check_list = self._packages if isinstance(symbol, Package) else self._all_symbols
+
+        if all(package_symbol.raw_identifier != identifier for package_symbol in check_list):
+            if isinstance(symbol, IdentifiedSymbol) and symbol.raw_identifier != symbol_id:
+                self._aliases[symbol.raw_identifier] = symbol_id
+
+            if isinstance(symbol, Package):
+                self._packages.append(symbol)
+                if symbol._parent is not None:
+                    return
+                symbol._parent = self
             else:
-                package = next((root_package for root_package in self.packages
-                                if root_package.identifier == package_id),
-                               None)
-
-            if not isinstance(package, Package):
-                package = Package(identifier=package_id)
-                if isinstance(cur_package, Package):
-                    cur_package.include_symbol(package_id, package)
-                else:
-                    self.packages.append(package)
-
-            cur_package = package
-
-        if isinstance(cur_package, Package):
-            for symbol_id, symbol in symbols.items():
-                cur_package.include_symbol(symbol_id, symbol)
-
-    def get_package(self, package_full_path: str) -> Optional[Package]:
-        package_ids = package_full_path.split('.')
-
-        cur_package: Package = next((root_package for root_package in self._instance.packages
-                                     if root_package.identifier == package_ids[0]),
-                                    None)
-        if cur_package is None:
-            return None
-
-        for package_id in package_ids[1:]:
-            if package_id not in cur_package.symbols:
-                return None
-
-            cur_package = cur_package.symbols[package_id]
-
-        return cur_package
-
-    def get_internal_symbol(self, symbol_id: str) -> Optional[ISymbol]:
-        packages_stack: List[Tuple[list, int]] = []
-        current_list = self._instance.packages
-        current_index = 0
-
-        while len(current_list) > current_index or len(packages_stack) > 0:
-            if len(current_list) <= current_index:
-                # if didn't find in the current list, go back to the previous list search
-                # if the stack is empty, it doesn't continue the loop because the while condition
-                current_list, current_index = packages_stack.pop()
-                if len(current_list) <= current_index:
-                    # if the previous list has no elements unchecked, just continue the loop
-                    continue
-
-            package = current_list[current_index]
-            if symbol_id in package.symbols:
-                return package.symbols[symbol_id]
-            current_index += 1
-
-            # if the package has internal packages, searches the symbol in these packages before continuing
-            internal_packages = [symbol for symbol in package.symbols.values() if isinstance(symbol, Package)]
-            if len(internal_packages) > 0:
-                # save the current list and index in the package
-                # made this way to avoid recursive function call
-                packages_stack.append((current_list, current_index))
-                current_list = internal_packages
-                current_index = 0
+                self._all_symbols.append(symbol)
+
+    def update_with_analyser(self, analyser):
+        from boa3.internal.analyser.analyser import Analyser
+        if isinstance(analyser, Analyser):
+            for symbol in self._all_symbols:
+                if hasattr(symbol, 'update_with_analyser'):
+                    symbol.update_with_analyser(analyser)
+            for pkg in self._packages:
+                pkg.update_with_analyser(analyser)
 
-        return None
+    def __repr__(self) -> str:
+        return self.identifier
```

### Comparing `neo3-boa-0.9.0/boa3/model/imports/importsymbol.py` & `neo3-boa-1.0.0/boa3/internal/model/imports/importsymbol.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import ast
 from typing import Dict
 
-from boa3.analyser.importanalyser import ImportAnalyser
-from boa3.model.builtin.builtincallable import IBuiltinCallable
-from boa3.model.method import Method
-from boa3.model.symbol import ISymbol
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
+from boa3.internal.analyser.importanalyser import ImportAnalyser
+from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
+from boa3.internal.model.method import Method
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
 
 
 class Import(ISymbol):
     """
     A class used to represent an imported package
 
     :ivar variables: a dictionary that maps each variable with its name. Empty by default.
@@ -36,14 +36,15 @@
                                       if alias not in symbols}
 
         for method in self.methods.values():
             if not isinstance(method, IBuiltinCallable) and hasattr(method, 'defined_by_entry'):
                 # methods imported are treated as methods defined in the entry file
                 method.defined_by_entry = True
 
+        self.analyser = import_analyser.analyser
         self.origin: str = origin
         self.ast: ast.AST = syntax_tree
 
     @property
     def shadowing_name(self) -> str:
         return 'module'
 
@@ -58,7 +59,14 @@
         return symbol
 
     @property
     def all_symbols(self) -> Dict[str, ISymbol]:
         symbol = self.symbols.copy()
         symbol.update(self._symbols_not_imported)
         return symbol
+
+
+class BuiltinImport(Import):
+    """
+    A class used to differentiate built-in importings
+    """
+    pass
```

### Comparing `neo3-boa-0.9.0/boa3/model/method.py` & `neo3-boa-1.0.0/boa3/internal/model/method.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 import ast
 from typing import Dict, List, Optional, Tuple
 
-from boa3.model.callable import Callable
-from boa3.model.debuginstruction import DebugInstruction
-from boa3.model.symbol import ISymbol
-from boa3.model.type.type import IType, Type
-from boa3.model.variable import Variable
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.debuginstruction import DebugInstruction
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.model.variable import Variable
 
 
 class Method(Callable):
     """
     A class used to represent a function or a class method
 
     :ivar args: a dictionary that maps each arg with its name. Empty by default.
@@ -17,24 +18,36 @@
     :ivar imported_symbols: a dictionary that maps each imported symbol with its name. Empty by default.
     :ivar is_public: a boolean value that specifies if the method is public. False by default.
     :ivar return_type: the return type of the method. None by default.
     """
 
     def __init__(self, args: Dict[str, Variable] = None,
                  vararg: Optional[Tuple[str, Variable]] = None,
+                 kwargs: Optional[Dict[str, Variable]] = None,
                  defaults: List[ast.AST] = None,
-                 return_type: IType = Type.none, is_public: bool = False, origin_node: Optional[ast.AST] = None):
-        super().__init__(args, vararg, defaults, return_type, is_public, origin_node)
+                 return_type: IType = Type.none, is_public: bool = False,
+                 decorators: List[Callable] = None,
+                 is_init: bool = False,
+                 external_name: str = None,
+                 is_safe: bool = False,
+                 origin_node: Optional[ast.AST] = None):
+        super().__init__(args, vararg, kwargs, defaults, return_type, is_public, decorators, external_name, is_safe, origin_node)
 
         self.imported_symbols = {}
         self._symbols = {}
         self.defined_by_entry = True
+        self.is_init = is_init
         self.locals: Dict[str, Variable] = {}
 
+        if is_init and self.has_cls_or_self:
+            self.return_type = list(self.args.values())[0].type
+
         self._debug_map: List[DebugInstruction] = []
+        self.origin_class: Optional[ClassType] = None
+        self.file_origin: Optional[str] = None
 
     @property
     def shadowing_name(self) -> str:
         return 'method'
 
     def include_variable(self, var_id: str, var: Variable, is_global: bool = False):
         """
@@ -86,26 +99,26 @@
         """
         return self._origin_node
 
     def debug_map(self) -> List[DebugInstruction]:
         """
         Returns a list with the debug information of each mapped Python instruction inside this method
         """
-        from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
+        from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
         return sorted(self._debug_map, key=lambda instr: VMCodeMapping.instance().get_start_address(instr.code))
 
     def include_instruction(self, instr_info: DebugInstruction):
         """
         Includes a new instruction in the debug info
 
         :param instr_info: debug information from the new instruction
         """
         if not any((info.start_line == instr_info.start_line and info.start_col == instr_info.start_col
                     for info in self._debug_map)):
-            existing_instr_info: Optional[DebugInstruction] =\
+            existing_instr_info: Optional[DebugInstruction] = \
                 next((info for info in self._debug_map if info.code == instr_info.code), None)
             if existing_instr_info is not None:
                 self._debug_map.remove(existing_instr_info)
             self._debug_map.append(instr_info)
 
     def remove_instruction(self, start_line: int, start_col: int):
         """
```

### Comparing `neo3-boa-0.9.0/boa3/model/module.py` & `neo3-boa-1.0.0/boa3/internal/model/module.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,34 +1,37 @@
 from typing import Dict
 
-from boa3.model.callable import Callable
-from boa3.model.method import Method
-from boa3.model.symbol import ISymbol
-from boa3.model.variable import Variable
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.method import Method
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.variable import Variable
 
 
 class Module(ISymbol):
     """
     A class used to represent a Python module
 
     :ivar variables: a dictionary that maps each variable with its name. Empty by default.
     :ivar methods: a dictionary that maps each method with its name. Empty by default.
     :ivar callables: a dictionary that maps each callable object with its name. Empty by default.
+    :ivar classes: a dictionary that maps each class with its name. Empty by default.
     :ivar imported_symbols: a dictionary that maps each imported symbol with its name. Empty by default.
     """
 
     def __init__(self, variables: Dict[str, Variable] = None, methods: Dict[str, Method] = None):
         if variables is None:
             variables = {}
         self.variables = variables
 
         if methods is None:
             methods = {}
         self.methods = methods
         self.callables: Dict[str, Callable] = {}
+        self.classes: Dict[str, ClassType] = {}
 
         self.defined_by_entry = True
         self.imported_symbols = {}
         self.assigned_variables = []
 
     @property
     def shadowing_name(self) -> str:
@@ -48,49 +51,65 @@
         if var_id not in self.variables:
             return False
 
         if var_id in self.assigned_variables or var_id in self.imported_symbols:
             return True
 
         for imported in self.imported_symbols.values():
-            from boa3.model.imports.importsymbol import Import
+            from boa3.internal.model.imports.importsymbol import Import
             if isinstance(imported, Import) and self.variables[var_id] in imported.variables.values():
                 return True
 
         return False
 
     def assign_variable(self, var_id: str):
         if var_id in self.variables:
             self.assigned_variables.append(var_id)
 
-    def include_callable(self, method_id: str, method: Callable):
+    def include_callable(self, method_id: str, method: Callable) -> bool:
         """
         Includes a method into the scope of the module
 
         :param method_id: method identifier
         :param method: method to be included
         """
         if method_id not in self.symbols:
             if isinstance(method, Method):
                 self.methods[method_id] = method
             else:
                 self.callables[method_id] = method
 
+            return True
+
+        return False
+
+    def include_class(self, class_id: str, class_obj: ClassType):
+        """
+        Includes a class into the scope of the module
+
+        :param class_id: class identifier
+        :param class_obj: class object to be included
+        """
+        if class_id not in self.symbols:
+            self.classes[class_id] = class_obj
+
     def include_symbol(self, symbol_id: str, symbol: ISymbol):
         """
         Includes a method into the scope of the module
 
         :param symbol_id: method identifier
         :param symbol: method to be included
         """
         if symbol_id not in self.symbols:
             if isinstance(symbol, Variable):
                 self.include_variable(symbol_id, symbol)
             elif isinstance(symbol, Callable):
                 self.include_callable(symbol_id, symbol)
+            elif isinstance(symbol, ClassType):
+                self.include_class(symbol_id, symbol)
             else:
                 self.imported_symbols[symbol_id] = symbol
 
     @property
     def symbols(self) -> Dict[str, ISymbol]:
         """
         Gets all the symbols in the module
@@ -98,8 +117,9 @@
         :return: a dictionary that maps each symbol in the module with its name
         """
         symbols = {}
         symbols.update(self.imported_symbols)
         symbols.update(self.variables)
         symbols.update(self.methods)
         symbols.update(self.callables)
+        symbols.update(self.classes)
         return symbols
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/additional/membership.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/additional/membership.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from typing import List, Optional, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.collection.mapping.mappingtype import MappingType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class CollectionMembership(BinaryOperation):
     """
     A class used to represent a collection membership operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
@@ -63,15 +63,15 @@
             left = right_operand.item_type if not isinstance(right_operand, MappingType) else right_operand.key_type
             return left, right_operand
 
         return left_operand, self.right_type
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+        from boa3.internal.neo.vm.type.Integer import Integer
         return [
             (Opcode.DUP, b''),
             (Opcode.ISTYPE, Type.mapping.stack_item),   # if isinstance(arg1, dict)
             (Opcode.JMPIFNOT, Integer(6).to_byte_array(signed=True, min_length=1)),
             (Opcode.SWAP, b''),
             (Opcode.HASKEY, b''),                           # return value.has_key(arg0)
             (Opcode.JMP, Integer(54).to_byte_array(signed=True, min_length=1)),
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/additional/notmembership.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/additional/notmembership.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 from typing import List, Optional, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.collection.mapping.mappingtype import MappingType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class CollectionNotMembership(BinaryOperation):
     """
     A class used to represent a collection not membership operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
@@ -59,9 +59,9 @@
             left = right_operand.item_type if not isinstance(right_operand, MappingType) else right_operand.key_type
             return left, right_operand
 
         return left_operand, self.right_type
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.model.operation.binary.additional import CollectionMembership
+        from boa3.internal.model.operation.binary.additional import CollectionMembership
         return CollectionMembership().opcode + [(Opcode.NOT, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/addition.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/subtraction.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,46 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Addition(BinaryOperation):
+class Subtraction(BinaryOperation):
     """
-    A class used to represent a numeric addition operation
+    A class used to represent a numeric subtraction operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
     _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Plus
+        self.operator: Operator = Operator.Minus
         super().__init__(left, right)
 
-    @property
-    def is_symmetric(self) -> bool:
-        return True
-
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.ADD, b'')]
+        return [(Opcode.SUB, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/concat.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/concat.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,13 @@
-from typing import List, Tuple
+from typing import List, Optional, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class Concat(BinaryOperation):
     """
     A class used to represent a string concatenation operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
@@ -26,28 +26,34 @@
             return False
         left: IType = types[0]
         right: IType = types[1]
 
         if left == right and any(valid_type.is_type_of(left) for valid_type in self._valid_types):
             return True
 
-        left_valid_type = next((valid_type for valid_type in self._valid_types
-                                if valid_type.is_type_of(left)), None)
+        left_valid_type = self._get_valid_type(left)
         if left_valid_type is None:
             return False
 
-        right_valid_type = next((valid_type for valid_type in self._valid_types
-                                 if valid_type.is_type_of(right)), None)
+        right_valid_type = self._get_valid_type(right)
 
-        return right_valid_type is not None and left_valid_type == right_valid_type
+        return (right_valid_type is not None
+                and (left_valid_type == right_valid_type
+                     or left_valid_type.is_type_of(right_valid_type)
+                     or right_valid_type.is_type_of(left_valid_type))
+                )
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
+    def _get_valid_type(self, operator_type: IType) -> Optional[IType]:
+        return next((valid_type for valid_type in self._valid_types
+                     if valid_type.is_type_of(operator_type)), None)
+
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
         return [(Opcode.CAT, b''),
                 (Opcode.CONVERT, Type.str.stack_item)
                 ]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/division.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/power.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,40 @@
-from typing import List
+from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Division(BinaryOperation):
+class Power(BinaryOperation):
     """
-    A class used to represent a floating-point division operation
+    A class used to represent a numeric power operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
     _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Div
+        self.operator: Operator = Operator.Pow
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     @property
-    def is_supported(self) -> bool:
-        # TODO: change when float division is supported
-        return False
+    def opcode(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.POW, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/floordivision.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/leftshift.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,42 +1,39 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class FloorDivision(BinaryOperation):
+class LeftShift(BinaryOperation):
     """
-    A class used to represent an integer division operation
+    A class used to represent the bit left shift [ << ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: List[IType] = [Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.IntDiv
+    def __init__(self, left: IType = Type.int, right: IType = Type.int):
+        self.operator: Operator = Operator.LeftShift
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
-
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return any(_type.is_type_of(left) for _type in self._valid_types) and Type.int.is_type_of(right)
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.DIV, b'')]
+        return [(Opcode.SHL, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/modulo.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/lessthan.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Modulo(BinaryOperation):
+class LessThan(BinaryOperation):
     """
-    A class used to represent a numeric modulo operation
+    A class used to represent a numeric less than comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
+    _valid_types: List[IType] = [Type.int, Type.str]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Mod
+        self.operator: Operator = Operator.Lt
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.MOD, b'')]
+        return [(Opcode.LT, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/multiplication.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/identity.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,46 +1,36 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Multiplication(BinaryOperation):
+class Identity(BinaryOperation):
     """
-    A class used to represent a numeric multiplication operation
+    A class used to represent an is comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Mult
+        self.operator: Operator = Operator.Is
         super().__init__(left, right)
 
-    @property
-    def is_symmetric(self) -> bool:
-        return True
-
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        left: IType = types[0]
-        right: IType = types[1]
-
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return True
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.MUL, b'')]
+        return [(Opcode.EQUAL, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/power.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/floordivision.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,42 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Power(BinaryOperation):
+class FloorDivision(BinaryOperation):
     """
-    A class used to represent a numeric power operation
+    A class used to represent an integer division operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
     _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Pow
+        self.operator: Operator = Operator.IntDiv
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.POW, b'')]
+        return [(Opcode.DIV, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/strmultiplication.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/strbytesmultiplication.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class StrMultiplication(BinaryOperation):
+class StrBytesMultiplication(BinaryOperation):
     """
-    A class used to represent a string concatenation operation
+    A class used to represent a string or bytes concatenation operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.str]
+    _valid_types: List[IType] = [Type.str, Type.bytes]
 
     def __init__(self, left: IType = Type.str, right: IType = Type.int):
         self.operator: Operator = Operator.Mult
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left in self._valid_types and right is Type.int
+        return any(_type.is_type_of(left) for _type in self._valid_types) and Type.int.is_type_of(right)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        from boa3.neo.vm.type.Integer import Integer
+        from boa3.internal.neo.vm.type.Integer import Integer
         codes = [
             (Opcode.PUSHDATA1, Integer(0).to_byte_array(min_length=1)),  # concatString = ''
             (Opcode.ROT, b''),
             (Opcode.ROT, b''),
             (Opcode.JMP, Integer(7).to_byte_array()),       # while argInt > 0
             (Opcode.REVERSE3, b''),
             (Opcode.OVER, b''),
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/arithmetic/subtraction.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/notidentity.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,42 +1,39 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Subtraction(BinaryOperation):
+class NotIdentity(BinaryOperation):
     """
-    A class used to represent a numeric subtraction operation
+    A class used to represent an is not comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
     _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Minus
+        self.operator: Operator = Operator.IsNot
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        left: IType = types[0]
-        right: IType = types[1]
-
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return True
 
     def _get_result(self, left: IType, right: IType) -> IType:
-        # TODO: change the logic of the return type when implement other numeric types
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.SUB, b'')]
+        return [
+            (Opcode.NOTEQUAL, b'')
+        ]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/binaryoperation.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/binaryoperation.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
 from typing import List, Optional, Tuple
 
-from boa3.model.operation.operation import IOperation
-from boa3.model.type.itype import IType
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.type.itype import IType
 
 
 class BinaryOperation(IOperation, ABC):
     """
     An interface used to represent binary operations
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/__init__.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/__init__.py`

 * *Files 23% similar despite different names*

```diff
@@ -3,14 +3,14 @@
            'LeftShift',
            'LogicAnd',
            'LogicOr',
            'LogicXor',
            'RightShift'
            ]
 
-from boa3.model.operation.binary.logical.booleanand import BooleanAnd
-from boa3.model.operation.binary.logical.booleanor import BooleanOr
-from boa3.model.operation.binary.logical.leftshift import LeftShift
-from boa3.model.operation.binary.logical.logicand import LogicAnd
-from boa3.model.operation.binary.logical.logicor import LogicOr
-from boa3.model.operation.binary.logical.logicxor import LogicXor
-from boa3.model.operation.binary.logical.rightshift import RightShift
+from boa3.internal.model.operation.binary.logical.booleanand import BooleanAnd
+from boa3.internal.model.operation.binary.logical.booleanor import BooleanOr
+from boa3.internal.model.operation.binary.logical.leftshift import LeftShift
+from boa3.internal.model.operation.binary.logical.logicand import LogicAnd
+from boa3.internal.model.operation.binary.logical.logicor import LogicOr
+from boa3.internal.model.operation.binary.logical.logicxor import LogicXor
+from boa3.internal.model.operation.binary.logical.rightshift import RightShift
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/booleanand.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/negative.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,41 +1,38 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class BooleanAnd(BinaryOperation):
+class Negative(UnaryOperation):
     """
-    A class used to represent the boolean or operation
+    A class used to represent a numeric negative operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
-    :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
+    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.bool]
+    _valid_types: List[IType] = [Type.int]
 
-    def __init__(self, left: IType = Type.bool, right: IType = None):
-        self.operator: Operator = Operator.And
-        super().__init__(left, right)
+    def __init__(self, operand: IType = Type.int):
+        self.operator: Operator = Operator.Minus
+        super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        left: IType = types[0]
-        right: IType = types[1]
+        operand: IType = types[0]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return any(_type.is_type_of(operand) for _type in self._valid_types)
 
-    def _get_result(self, left: IType, right: IType) -> IType:
-        if self.validate_type(left, right):
-            return Type.bool
+    def _get_result(self, operand: IType) -> IType:
+        if self.validate_type(operand):
+            return operand
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.BOOLAND, b'')]
+        return [(Opcode.NEGATE, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/booleanor.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/positive.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,41 +1,39 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class BooleanOr(BinaryOperation):
+class Positive(UnaryOperation):
     """
-    A class used to represent the boolean or operation
+    A class used to represent a numeric positive operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
-    :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
+    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.bool]
+    _valid_types: List[IType] = [Type.int]
 
-    def __init__(self, left: IType = Type.bool, right: IType = None):
-        self.operator: Operator = Operator.Or
-        super().__init__(left, right)
+    def __init__(self, operand: IType = Type.int):
+        self.operator: Operator = Operator.Plus
+        super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        left: IType = types[0]
-        right: IType = types[1]
+        operand: IType = types[0]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return any(_type.is_type_of(operand) for _type in self._valid_types)
 
-    def _get_result(self, left: IType, right: IType) -> IType:
-        if self.validate_type(left, right):
-            return Type.bool
+    def _get_result(self, operand: IType) -> IType:
+        if self.validate_type(operand):
+            return operand
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.BOOLOR, b'')]
+        # it is the identity function, so there is no need of including another opcode
+        return []
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/leftshift.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/lessthanorequal.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LeftShift(BinaryOperation):
+class LessThanOrEqual(BinaryOperation):
     """
-    A class used to represent the bit left shift [ << ] operation
+    A class used to represent a numeric less than or equal comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: List[IType] = [Type.int, Type.str]
 
-    def __init__(self, left: IType = Type.int, right: IType = Type.int):
-        self.operator: Operator = Operator.LeftShift
+    def __init__(self, left: IType = Type.int, right: IType = None):
+        self.operator: Operator = Operator.LtE
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left in self._valid_types and right is Type.int
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.SHL, b'')]
+        return [(Opcode.LE, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/logicand.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/logicor.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LogicAnd(BinaryOperation):
+class LogicOr(BinaryOperation):
     """
-    A class used to represent the bit and [ & ] operation
+    A class used to represent the bit or [ | ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
     _valid_types: List[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.BitAnd
+        self.operator: Operator = Operator.BitOr
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.AND, b'')]
+        return [(Opcode.OR, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/logicor.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/objectequality.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,40 +1,43 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LogicOr(BinaryOperation):
+class ObjectEquality(BinaryOperation):
     """
-    A class used to represent the bit or [ | ] operation
+    A class used to represent a equality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: List[IType] = [Type.str, Type.bytes, Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.BitOr
+    def __init__(self, left: IType = Type.str, right: IType = None):
+        self.operator: Operator = Operator.Eq
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left == right and left in self._valid_types
+        return self._is_valid_type(left) and self._is_valid_type(right)
+
+    def _is_valid_type(self, tpe: IType) -> bool:
+        return any(valid.is_type_of(tpe) for valid in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.OR, b'')]
+        return [(Opcode.EQUAL, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/logicxor.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/logicxor.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class LogicXor(BinaryOperation):
     """
     A class used to represent the bit xor [ ^ ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
@@ -23,15 +23,15 @@
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return left
         else:
             return Type.none
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/logical/rightshift.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/greaterthan.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class RightShift(BinaryOperation):
+class GreaterThan(BinaryOperation):
     """
-    A class used to represent the bit right shift [ >> ] operation
+    A class used to represent a numeric greater than comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: List[IType] = [Type.int, Type.str]
 
-    def __init__(self, left: IType = Type.int, right: IType = Type.int):
-        self.operator: Operator = Operator.RightShift
+    def __init__(self, left: IType = Type.int, right: IType = None):
+        self.operator: Operator = Operator.Gt
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left in self._valid_types and right is Type.int
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return left
+            return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.SHR, b'')]
+        return [(Opcode.GT, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/LessThan.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/division.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,41 +1,40 @@
-from typing import List, Tuple
+from typing import List
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
 
 
-class LessThan(BinaryOperation):
+class Division(BinaryOperation):
     """
-    A class used to represent a numeric less than comparison
+    A class used to represent a floating-point division operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Lt
+        self.operator: Operator = Operator.Div
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return Type.bool
+            return left
         else:
             return Type.none
 
     @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.LT, b'')]
+    def is_supported(self) -> bool:
+        # TODO: change when float division is supported
+        return False
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/Lessthanorequal.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/logicnot.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,41 +1,38 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class LessThanOrEqual(BinaryOperation):
+class LogicNot(UnaryOperation):
     """
-    A class used to represent a numeric less than or equal comparison
+    A class used to represent the bit not [ ~ ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
-    :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
+    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: List[IType] = [Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.LtE
-        super().__init__(left, right)
+    def __init__(self, operand: IType = Type.int):
+        self.operator: Operator = Operator.BitNot
+        super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        left: IType = types[0]
-        right: IType = types[1]
+        operand: IType = types[0]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return any(_type.is_type_of(operand) for _type in self._valid_types)
 
-    def _get_result(self, left: IType, right: IType) -> IType:
-        if self.validate_type(left, right):
-            return Type.bool
+    def _get_result(self, operand: IType) -> IType:
+        if self.validate_type(operand):
+            return Type.int
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.LE, b'')]
+        return [(Opcode.INVERT, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/greaterthan.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/numericinequality.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,41 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class GreaterThan(BinaryOperation):
+class NumericInequality(BinaryOperation):
     """
-    A class used to represent a numeric greater than comparison
+    A class used to represent a numeric inequality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: List[IType] = [Type.int, Type.bool]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Gt
+        self.operator: Operator = Operator.NotEq
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.GT, b'')]
+        return [(Opcode.NUMNOTEQUAL, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/greaterthanorequal.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/multiplication.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,41 +1,44 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class GreaterThanOrEqual(BinaryOperation):
+class Multiplication(BinaryOperation):
     """
-    A class used to represent a numeric greater than or equal comparison
+    A class used to represent a numeric multiplication operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.str]
+    _valid_types: List[IType] = [Type.int]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.GtE
+        self.operator: Operator = Operator.Mult
         super().__init__(left, right)
 
+    @property
+    def is_symmetric(self) -> bool:
+        return True
+
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return Type.bool
+            return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.GE, b'')]
+        return [(Opcode.MUL, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/identity.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/booleannot.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,36 +1,38 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class Identity(BinaryOperation):
+class BooleanNot(UnaryOperation):
     """
-    A class used to represent an is comparison
+    A class used to represent the boolean not operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
-    :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
+    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
+    _valid_types: List[IType] = [Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Is
-        super().__init__(left, right)
+    def __init__(self, operand: IType = Type.bool):
+        self.operator: Operator = Operator.Not
+        super().__init__(operand)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
-        return True
+        operand: IType = types[0]
 
-    def _get_result(self, left: IType, right: IType) -> IType:
-        if self.validate_type(left, right):
-            return Type.bool
+        return any(_type.is_type_of(operand) for _type in self._valid_types)
+
+    def _get_result(self, operand: IType) -> IType:
+        if self.validate_type(operand):
+            return operand
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.EQUAL, b'')]
+        return [(Opcode.NOT, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/numericequality.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/noneidentity.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,41 +1,49 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NumericEquality(BinaryOperation):
+class NoneIdentity(UnaryOperation):
     """
-    A class used to represent a numeric equality comparison
+    A class used to represent an 'is None' comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
-    :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
+    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.Eq
-        super().__init__(left, right)
+    def __init__(self, operand: IType = Type.int):
+        self.operator: Operator = Operator.Is
+        super().__init__(operand)
+
+    @property
+    def number_of_operands(self) -> int:
+        # it is a Python binary operation that is equivalent to a Neo VM unary operation
+        return 2
+
+    @property
+    def op_on_stack(self) -> int:
+        return super().number_of_operands
 
     def validate_type(self, *types: IType) -> bool:
+        if len(types) == self.op_on_stack:
+            return True
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left is Type.none or right is Type.none
 
-    def _get_result(self, left: IType, right: IType) -> IType:
-        if self.validate_type(left, right):
+    def _get_result(self, operand: IType) -> IType:
+        if self.validate_type(operand):
             return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.NUMEQUAL, b'')]
+        return [(Opcode.ISNULL, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/numericinequality.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/greaterthanorequal.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,41 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NumericInequality(BinaryOperation):
+class GreaterThanOrEqual(BinaryOperation):
     """
-    A class used to represent a numeric inequality comparison
+    A class used to represent a numeric greater than or equal comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: List[IType] = [Type.int, Type.str]
 
     def __init__(self, left: IType = Type.int, right: IType = None):
-        self.operator: Operator = Operator.NotEq
+        self.operator: Operator = Operator.GtE
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        # TODO: change the logic of the validation when implement other numeric types
-        return left == right and left in self._valid_types
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
             return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.NUMNOTEQUAL, b'')]
+        return [(Opcode.GE, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/objectequality.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/logical/rightshift.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,43 +1,40 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class ObjectEquality(BinaryOperation):
+class RightShift(BinaryOperation):
     """
-    A class used to represent a equality comparison
+    A class used to represent the bit right shift [ >> ] operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.str, Type.bytes, Type.int, Type.bool]
+    _valid_types: List[IType] = [Type.int, Type.bool]
 
-    def __init__(self, left: IType = Type.str, right: IType = None):
-        self.operator: Operator = Operator.Eq
+    def __init__(self, left: IType = Type.int, right: IType = Type.int):
+        self.operator: Operator = Operator.RightShift
         super().__init__(left, right)
 
     def validate_type(self, *types: IType) -> bool:
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return self._is_valid_type(left) and self._is_valid_type(right)
-
-    def _is_valid_type(self, tpe: IType) -> bool:
-        return any(valid.is_type_of(tpe) for valid in self._valid_types)
+        return any(_type.is_type_of(left) for _type in self._valid_types) and Type.int.is_type_of(right)
 
     def _get_result(self, left: IType, right: IType) -> IType:
         if self.validate_type(left, right):
-            return Type.bool
+            return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.EQUAL, b'')]
+        return [(Opcode.SHR, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binary/relational/objectinequality.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/relational/objectinequality.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import List, Tuple
 
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class ObjectInequality(BinaryOperation):
     """
     A class used to represent a inequality comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/binaryop.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binaryop.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,32 +1,33 @@
 from typing import List, Optional
 
-from boa3.model.operation.binary.additional import *
-from boa3.model.operation.binary.arithmetic import *
-from boa3.model.operation.binary.binaryoperation import BinaryOperation
-from boa3.model.operation.binary.logical import *
-from boa3.model.operation.binary.relational import *
-from boa3.model.operation.operation import IOperation
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary.noneidentity import NoneIdentity
-from boa3.model.operation.unary.nonenotidentity import NoneNotIdentity
-from boa3.model.type.itype import IType
+from boa3.internal.model.operation.binary.additional import *
+from boa3.internal.model.operation.binary.arithmetic import *
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.binary.logical import *
+from boa3.internal.model.operation.binary.relational import *
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.noneidentity import NoneIdentity
+from boa3.internal.model.operation.unary.nonenotidentity import NoneNotIdentity
+from boa3.internal.model.type.itype import IType
 
 
 class BinaryOp:
     # Arithmetic operations
     Add = Addition()
     Sub = Subtraction()
     Mul = Multiplication()
     Div = Division()
     IntDiv = FloorDivision()
+    ListAdd = ListAddition()
     Mod = Modulo()
     Pow = Power()
     Concat = Concat()
-    StrMul = StrMultiplication()
+    StrBytesMul = StrBytesMultiplication()
 
     # Relational operations
     NumEq = NumericEquality()
     NumNotEq = NumericInequality()
     Lt = LessThan()
     LtE = LessThanOrEqual()
     Gt = GreaterThan()
@@ -63,15 +64,15 @@
         :rtype: BinaryOperation or None
         """
         for id, op in vars(cls).items():
             if isinstance(op, IOperation) and op.is_valid(operator, left, right):
                 if isinstance(op, BinaryOperation):
                     return op.build(left, right)
                 else:
-                    from boa3.model.type.type import Type
+                    from boa3.internal.model.type.type import Type
                     operand = right if left is Type.none else left
                     return op.build(operand)
 
     @classmethod
     def get_operation_by_operator(cls, operator: Operator, left_operand: IType,
                                   right_operand: Optional[IType] = None) -> Optional[BinaryOperation]:
         """
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/operation.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/operation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
 from typing import List, Optional, Tuple
 
-from boa3.model.operation.operator import Operator
-from boa3.model.type.itype import IType
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class IOperation(ABC):
+class IOperation(ISymbol, ABC):
     """
     An interface used to represent operations
 
     :ivar operator: the operator of the operation
     :ivar result: the result type of the operation
     """
 
@@ -26,14 +27,23 @@
         Gets the operation sequence of opcodes with in Neo Vm
 
         :return: the opcode if exists. Empty list otherwise.
         """
         return []
 
     @property
+    def shadowing_name(self) -> str:
+        """
+        Gets the type of the evaluated expression
+
+        :return: the resulting type when the expression is evaluated
+        """
+        return self.operator.value
+
+    @property
     def bytecode(self) -> bytes:
         """
         Gets the operation bytecode
 
         :return: the bytecode if exists. Empty bytes otherwise.
         """
         str_mult_bytes = bytearray()
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/operator.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/operator.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3/model/operation/unary/logicnot.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/unaryoperation.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,38 +1,48 @@
-from typing import List, Tuple
+from __future__ import annotations
 
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary.unaryoperation import UnaryOperation
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from abc import ABC, abstractmethod
+from typing import List, Optional
 
+from boa3.internal.model.operation.operation import IOperation
+from boa3.internal.model.type.itype import IType
 
-class LogicNot(UnaryOperation):
+
+class UnaryOperation(IOperation, ABC):
     """
-    A class used to represent the bit not [ ~ ] operation
+    An interface used to represent binary operations
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
+    :ivar operand: the operand type.
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
-    _valid_types: List[IType] = [Type.int, Type.bool]
+    _valid_types: List[IType] = []
 
-    def __init__(self, operand: IType = Type.int):
-        self.operator: Operator = Operator.BitNot
-        super().__init__(operand)
-
-    def validate_type(self, *types: IType) -> bool:
-        if len(types) != self.number_of_operands:
-            return False
-        operand: IType = types[0]
+    def __init__(self, operand: IType):
+        self.operand_type: IType = operand
+        result = self._get_result(operand)
+        super().__init__(self.operator, result)
 
-        return operand in self._valid_types
+    @property
+    def number_of_operands(self) -> int:
+        return 1
 
+    @abstractmethod
     def _get_result(self, operand: IType) -> IType:
-        if self.validate_type(operand):
-            return operand
-        else:
-            return Type.none
+        """
+        Gets the result type of the operation given the operand type.
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.INVERT, b'')]
+        :param operand:  operand type
+        :return: the result type of the operation. Type.none if the operand is not valid.
+        """
+        pass
+
+    @classmethod
+    def build(cls, operand: IType) -> Optional[UnaryOperation]:
+        """
+        Creates a unary operation with the given operand type
+
+        :param operand: operand type
+        :return: The built operation if the operands are valid. None otherwise
+        :rtype: UnaryOperation or None
+        """
+        return cls(operand)
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/unary/noneidentity.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unary/nonenotidentity.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 from typing import List, Tuple
 
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary.unaryoperation import UnaryOperation
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NoneIdentity(UnaryOperation):
+class NoneNotIdentity(UnaryOperation):
     """
-    A class used to represent an 'is None' comparison
+    A class used to represent an 'is not None' comparison
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
     :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
 
     def __init__(self, operand: IType = Type.int):
-        self.operator: Operator = Operator.Is
+        self.operator: Operator = Operator.IsNot
         super().__init__(operand)
 
     @property
     def number_of_operands(self) -> int:
         # it is a Python binary operation that is equivalent to a Neo VM unary operation
         return 2
 
@@ -42,8 +42,11 @@
         if self.validate_type(operand):
             return Type.bool
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.ISNULL, b'')]
+        return [
+            (Opcode.ISNULL, b''),
+            (Opcode.NOT, b'')
+        ]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/unary/nonenotidentity.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/binary/arithmetic/addition.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,52 +1,44 @@
 from typing import List, Tuple
 
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary.unaryoperation import UnaryOperation
-from boa3.model.type.type import IType, Type
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.model.operation.binary.binaryoperation import BinaryOperation
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.type.type import IType, Type
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NoneNotIdentity(UnaryOperation):
+class Addition(BinaryOperation):
     """
-    A class used to represent an 'is not None' comparison
+    A class used to represent a numeric addition operation
 
     :ivar operator: the operator of the operation. Inherited from :class:`IOperation`
-    :ivar operand: the operand type. Inherited from :class:`UnaryOperation`
+    :ivar left: the left operand type. Inherited from :class:`BinaryOperation`
+    :ivar right: the left operand type. Inherited from :class:`BinaryOperation`
     :ivar result: the result type of the operation.  Inherited from :class:`IOperation`
     """
+    _valid_types: List[IType] = [Type.int]
 
-    def __init__(self, operand: IType = Type.int):
-        self.operator: Operator = Operator.IsNot
-        super().__init__(operand)
+    def __init__(self, left: IType = Type.int, right: IType = None):
+        self.operator: Operator = Operator.Plus
+        super().__init__(left, right)
 
     @property
-    def number_of_operands(self) -> int:
-        # it is a Python binary operation that is equivalent to a Neo VM unary operation
-        return 2
-
-    @property
-    def op_on_stack(self) -> int:
-        return super().number_of_operands
+    def is_symmetric(self) -> bool:
+        return True
 
     def validate_type(self, *types: IType) -> bool:
-        if len(types) == self.op_on_stack:
-            return True
         if len(types) != self.number_of_operands:
             return False
         left: IType = types[0]
         right: IType = types[1]
 
-        return left is Type.none or right is Type.none
+        return left == right and any(_type.is_type_of(left) for _type in self._valid_types)
 
-    def _get_result(self, operand: IType) -> IType:
-        if self.validate_type(operand):
-            return Type.bool
+    def _get_result(self, left: IType, right: IType) -> IType:
+        if self.validate_type(left, right):
+            return left
         else:
             return Type.none
 
     @property
     def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return [
-            (Opcode.ISNULL, b''),
-            (Opcode.NOT, b'')
-        ]
+        return [(Opcode.ADD, b'')]
```

### Comparing `neo3-boa-0.9.0/boa3/model/operation/unaryop.py` & `neo3-boa-1.0.0/boa3/internal/model/operation/unaryop.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from typing import Optional
 
-from boa3.model.operation.operator import Operator
-from boa3.model.operation.unary import *
-from boa3.model.operation.unary.unaryoperation import UnaryOperation
-from boa3.model.type.itype import IType
+from boa3.internal.model.operation.operator import Operator
+from boa3.internal.model.operation.unary import *
+from boa3.internal.model.operation.unary.unaryoperation import UnaryOperation
+from boa3.internal.model.type.itype import IType
 
 
 class UnaryOp:
     # Arithmetic operations
     Positive = Positive()
     Negative = Negative()
```

### Comparing `neo3-boa-0.9.0/boa3/model/property.py` & `neo3-boa-1.0.0/boa3/internal/model/property.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import ast
 from typing import Optional
 
-from boa3.model.expression import IExpression
-from boa3.model.method import Method
-from boa3.model.type.itype import IType
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.itype import IType
 
 
 class Property(IExpression):
     """
     A class used to represent a variable
 
     :ivar var_type: the type of the variable.
```

### Comparing `neo3-boa-0.9.0/boa3/model/standards/neostandard.py` & `neo3-boa-1.0.0/boa3/internal/model/standards/neostandard.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,44 +1,54 @@
 import abc
-from typing import Dict, List, Union
+from typing import List, Optional, Union
 
-from boa3.model.event import Event
-from boa3.model.method import Method
+from boa3.internal.model.event import Event
+from boa3.internal.model.method import Method
 
 
 class INeoStandard(abc.ABC):
-    def __init__(self, methods: Dict[str, Method], events: List[Event]):
-        self.methods: Dict[str, Method] = methods
-        self.events: Dict[str, Event] = {event.name: event for event in events}
+    def __init__(self, methods: List[Method], events: List[Event], optionals: Optional[List[Method]] = None):
+        if optionals is None:
+            optionals = []
+        self.methods: List[Method] = methods.copy()
+        self.events: List[Event] = events.copy()
+        self.optionals: List[Method] = optionals.copy()
 
-    def match_definition(self, symbol_id: str, symbol: Union[Method, Event]) -> bool:
-        if not isinstance(symbol, (Method, Event)) or not isinstance(symbol_id, str):
+    def match_definition(self, standard: Union[Method, Event], symbol: Union[Method, Event]) -> bool:
+        if not isinstance(standard, (Method, Event)) or not isinstance(symbol, (Method, Event)):
             return False
 
-        standard_symbols = self.methods if isinstance(symbol, Method) else self.events
-        if symbol_id not in standard_symbols:
+        standard_symbols = self.methods + self.optionals if isinstance(symbol, Method) else self.events
+        if standard not in standard_symbols:
             return False
 
-        standard_def = standard_symbols[symbol_id]
-        return self._have_same_signature(standard_def, symbol)
+        return self._have_same_signature(standard, symbol)
 
     def _have_same_signature(self, symbol: Union[Method, Event], other: Union[Method, Event]) -> bool:
         if (isinstance(symbol, Method) and not isinstance(other, Method)
                 or isinstance(symbol, Event) and not isinstance(other, Event)):
             return False
 
-        if symbol.return_type != other.return_type:
+        if symbol.return_type != other.return_type and not (
+                # verifies if both return types are equal if they are a neo3-boa type
+                symbol.return_type.is_type_of(other.return_type) and other.return_type.is_type_of(symbol.return_type)):
             return False
 
         if symbol.is_public != other.is_public:
             return False
 
+        if symbol.is_safe != other.is_safe:
+            return False
+
         if len(symbol.args) != len(other.args):
             return False
 
         method_args = list(symbol.args.values())
         other_args = list(other.args.values())
         for index in range(len(method_args)):
-            if method_args[index].type != other_args[index].type:
-                return False
-
+            if hasattr(symbol, 'literal_implementation') and symbol.literal_implementation:
+                if method_args[index].type != other_args[index].type:
+                    return False
+            else:
+                if not method_args[index].type.is_type_of(other_args[index].type):
+                    return False
         return True
```

### Comparing `neo3-boa-0.9.0/boa3/model/standards/standardmethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/native/neo_contract_methods/registercandidatemethod.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,14 +1,18 @@
 from typing import Dict
 
-from boa3.model.method import Method
-from boa3.model.type.itype import IType
-from boa3.model.type.type import Type
-from boa3.model.variable import Variable
+from boa3.internal.model.builtin.interop.nativecontract import NeoContractMethod
+from boa3.internal.model.variable import Variable
 
 
-class StandardMethod(Method):
-    def __init__(self, args: Dict[str, IType] = None, return_type: IType = Type.none):
-        if not isinstance(args, dict):
-            args = {}
-        method_args = {key: Variable(value) for key, value in args.items()}
-        super().__init__(args=method_args, return_type=return_type, is_public=True)
+class RegisterCandidateMethod(NeoContractMethod):
+
+    def __init__(self):
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.type.collection.sequence.ecpointtype import ECPointType
+
+        identifier = 'register_candidate'
+        native_identifier = 'registerCandidate'
+        args: Dict[str, Variable] = {
+            'pubkey': Variable(ECPointType.build())
+        }
+        super().__init__(identifier, native_identifier, args, return_type=Type.bool)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/annotation/metatype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/primitive/bytearraytype.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,50 +1,37 @@
-from typing import Any, Optional
+from typing import Any
 
-from boa3.model.type.itype import IType
-from boa3.neo.vm.type.AbiType import AbiType
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
-class MetaType(IType):
+class ByteArrayType(BytesType, MutableSequenceType):
     """
-    A class used to represent internal Boa and Python types
+    A class used to represent Python list type
     """
 
-    def __init__(self, type_of: IType = None):
-        identifier = 'type'
-        super().__init__(identifier)
-        self._internal_type: Optional[IType] = type_of
+    def __init__(self):
+        super().__init__()
+        self._identifier = 'bytearray'
 
     @property
-    def abi_type(self) -> AbiType:
-        return AbiType.Any
+    def stack_item(self) -> StackItemType:
+        return StackItemType.Buffer
+
+    @property
+    def default_value(self) -> Any:
+        return bytearray()
 
     @classmethod
     def build(cls, value: Any) -> IType:
-        if isinstance(value, MetaType):
-            return value
-        if isinstance(value, IType):
-            return cls(value)
-        else:
-            return metaType
+        from boa3.internal.model.type.type import Type
+        return Type.bytearray
 
     @classmethod
-    def _is_type_of(cls, value: Any) -> bool:
-        return isinstance(value, MetaType)
-
-    def is_type_of(self, value: Any) -> bool:
-        return isinstance(value, MetaType) and self._internal_type.is_type_of(value._internal_type)
-
-    @property
-    def has_meta_type(self) -> bool:
-        return self._internal_type is not None
+    def _is_type_of(cls, value: Any):
+        return type(value) in [bytearray, ByteArrayType]
 
     @property
-    def meta_type(self) -> Optional[IType]:
-        return self._internal_type
-
-    @property
-    def meta_id(self) -> Optional[None]:
-        return self._internal_type.identifier if self._internal_type is not None else None
-
-
-metaType: IType = MetaType()
+    def can_reassign_values(self) -> bool:
+        return True
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/annotation/optionaltype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/annotation/optionaltype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, Iterable, List, Set
 
-from boa3.model.type.annotation.uniontype import UnionType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.nonetype import noneType
+from boa3.internal.model.type.annotation.uniontype import UnionType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.nonetype import noneType
 
 
 class OptionalType(UnionType):
     """
     An class used to represent Python Optional annotation type
     """
 
@@ -18,27 +18,27 @@
             if noneType in optional_types:
                 optional_types.remove(noneType)
             else:
                 union_types.add(noneType)
 
         super().__init__(union_types)
         self._identifier = 'Optional'
-        self._optional_type = optional_types
+        self._optional_type = optional_types if optional_types is not None else set()
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}]'.format(self._identifier,
                                  ', '.join([t.identifier for t in self._optional_type]))
 
     @property
     def optional_types(self) -> List[IType]:
         return list(self._optional_type)
 
     def _is_type_of(self, value: Any) -> bool:
-        if not isinstance(self._optional_type, Iterable):
+        if not isinstance(self._optional_type, Iterable) or len(self._optional_type) == 0:
             return False
         if isinstance(value, UnionType):
             return all(self._is_type_of(x) for x in value._union_types)
         return any(t.is_type_of(value) for t in self._union_types)
 
     @classmethod
     def build(cls, value: Any) -> IType:
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/annotation/uniontype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/annotation/uniontype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,46 +1,64 @@
 from typing import Any, Iterable, List, Set
 
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class UnionType(IType):
     """
     An class used to represent Python Union annotation type
     """
 
     def __init__(self, union_types: Set[IType] = None):
         identifier: str = 'Union'
         super().__init__(identifier)
-        self._union_types: Set[IType] = union_types
+        self._union_types: Set[IType] = union_types if union_types is not None else set()
+
+        # variables to not reevaluate everytime we need to access
+        self._abi_type: AbiType = None
+        self._stack_item: StackItemType = None
 
     @property
     def identifier(self) -> str:
         return '{0}[{1}]'.format(self._identifier,
                                  ', '.join([t.identifier for t in self._union_types]))
 
     @property
     def union_types(self) -> List[IType]:
         return list(self._union_types)
 
+    @property
+    def abi_type(self) -> AbiType:
+        if self._abi_type is None:
+            self._abi_type = AbiType.union([union.abi_type for union in self._union_types])
+        return self._abi_type
+
+    @property
+    def stack_item(self) -> StackItemType:
+        if self._stack_item is None:
+            self._stack_item = StackItemType.union([union.stack_item for union in self._union_types])
+        return self._stack_item
+
     def _is_type_of(self, value: Any) -> bool:
-        if not isinstance(self._union_types, Iterable):
+        if not isinstance(self._union_types, Iterable) or len(self._union_types) == 0:
             return False
         if isinstance(value, UnionType):
             return all(self._is_type_of(x) for x in value._union_types)
         return any(t.is_type_of(value) for t in self._union_types)
 
     @classmethod
     def build(cls, value: Any) -> IType:
         if isinstance(value, Iterable):
             types = set(value)
         else:
             types = {value}
 
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if any(t is Type.any for t in types):
             return Type.any
 
         if all(isinstance(t, IType) for t in types):
             for x in types.copy():
                 if isinstance(x, UnionType):
                     types.remove(x)
@@ -64,15 +82,15 @@
 
         new_union = []
         for x in self._union_types:
             if not other_type.is_type_of(x):
                 new_union.append(x)
 
         if len(new_union) < 2:
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             return Type.none if len(new_union) == 0 else new_union[0]
         else:
             return UnionType(set(new_union))
 
     def intersect_type(self, other_type: IType) -> IType:
         if self.is_type_of(other_type):
             return other_type
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/anytype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/anytype.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any, List, Tuple
 
-from boa3.model.type.itype import IType
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.type.AbiType import AbiType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
 class __AnyType(IType):
     """
     A class used to represent Python bool type
     """
 
@@ -16,15 +16,15 @@
 
     @property
     def abi_type(self) -> AbiType:
         return AbiType.Any
 
     @classmethod
     def build(cls, value: Any) -> IType:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return Type.any
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return True
 
     def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/baseexceptiontype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/baseexceptiontype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from typing import Any
 
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.itype import IType
 
 
 class BaseExceptionType(IType):
     """
     An class used to represent a generic Python exception
     """
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/genericcollectiontype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/genericsequencetype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,48 +1,40 @@
 from typing import Any, Set
 
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
 
 
-class GenericCollectionType(ICollectionType):
+class GenericSequenceType(SequenceType):
     """
-    An class used to represent a generic Python collection type
+    An class used to represent a generic Python sequence type
     """
 
-    def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
-        identifier: str = 'collection'
-        keys_type = self.filter_types(keys_type)
+    def __init__(self, values_type: Set[IType] = None):
+        identifier: str = 'sequence'
         values_type = self.filter_types(values_type)
-        super().__init__(identifier, keys_type, values_type)
+        super().__init__(identifier, values_type)
 
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
-        return self.key_type
+        from boa3.internal.model.type.type import Type
+        return Type.int
 
     @property
     def is_generic(self) -> bool:
         return True
 
     @classmethod
-    def _is_type_of(cls, value: Any):
-        return isinstance(value, ICollectionType)
-
-    @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            if isinstance(value, dict):
-                keys = list(value.keys())
-                values = list(value.values())
-            else:
-                keys = value.key_type
-                values = value.value_type
-
-            keys_types: Set[IType] = cls.get_types(keys)
-            values_types: Set[IType] = cls.get_types(values)
-            return cls(keys_types, values_types)
+            values_types: Set[IType] = cls.get_types(value)
+            return cls(values_types)
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, SequenceType)
 
     def __hash__(self):
         return hash(self.identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/icollection.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/icollection.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,19 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
 from typing import Any, Iterable, Set, Union
 
-from boa3.model.type.annotation.uniontype import UnionType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
+from boa3.internal.model.type.annotation.uniontype import UnionType
+from boa3.internal.model.type.classes.pythonclass import PythonClass
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.primitivetype import PrimitiveType
 
 
-class ICollectionType(IType, ABC):
+class ICollectionType(PythonClass, ABC):
     """
     An interface used to represent Python mapping type
     """
 
     def __init__(self, identifier: str, keys_type: Set[IType] = None, values_type: Set[IType] = None):
         if keys_type is None:
             keys_type = set()
@@ -51,26 +52,26 @@
     @property
     @abstractmethod
     def valid_key(self) -> IType:
         pass
 
     def _get_collection_type(self, values_type: Set[IType]):
         if len(values_type) == 0:
-            from boa3.model.type.anytype import anyType
+            from boa3.internal.model.type.anytype import anyType
             val_type: IType = anyType
         elif len(values_type) == 1:
             val_type: IType = list(values_type)[0]
         else:
             val_type: IType = UnionType.build(values_type)
 
         return val_type
 
     @classmethod
     def get_types(cls, value: Any) -> Set[IType]:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         if isinstance(value, IType):
             return {value}
 
         if not isinstance(value, Iterable):
             value = {value}
 
         types: Set[IType] = {val if isinstance(val, IType) else Type.get_type(val) for val in value}
@@ -83,15 +84,15 @@
         elif not isinstance(values_type, set):
             if isinstance(values_type, Iterable):
                 values_type = set(values_type)
             else:
                 values_type = {values_type}
 
         if len(values_type) > 1:
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             if any(t is Type.any or t is Type.none for t in values_type):
                 return {Type.any}
 
             actual_types = list(values_type)[:1]
             for value in list(values_type)[1:]:
                 other = next((x for x in actual_types
                               if x.is_type_of(value) or value.is_type_of(x)), None)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/mapping/genericmappingtype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mutable/dicttype.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,30 +1,42 @@
 from typing import Any, Set
 
-from boa3.model.type.collection.mapping.mappingtype import MappingType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.mapping.mutable.mutablemappingtype import MutableMappingType
+from boa3.internal.model.type.itype import IType
 
 
-class GenericMappingType(MappingType):
+class DictType(MutableMappingType):
     """
-    An class used to represent a generic Python sequence type
+    A class used to represent Python dict type
     """
 
     def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
-        identifier: str = 'mapping'
+        identifier = 'dict'
         keys_type = self.filter_types(keys_type)
         values_type = self.filter_types(values_type)
         super().__init__(identifier, keys_type, values_type)
 
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
-
     @property
-    def is_generic(self) -> bool:
-        return True
+    def default_value(self) -> Any:
+        return dict()
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, MappingType)
+        return type(value) in [dict, DictType]
+
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+
+        from boa3.internal.model.builtin.builtin import Builtin
+
+        instance_methods = [Builtin.Copy,
+                            Builtin.DictKeys,
+                            Builtin.DictValues,
+                            Builtin.DictPop,
+                            Builtin.DictPopDefault,
+                            ]
+
+        for instance_method in instance_methods:
+            self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
 
     def __hash__(self):
         return hash(self.identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/mapping/mappingtype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mappingtype.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from abc import ABC
 from typing import Any, Iterable, Set, Sized
 
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.itype import IType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.type.collection.icollection import ICollectionType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class MappingType(ICollectionType, ABC):
     """
     An interface used to represent Python mapping type
     """
 
@@ -58,23 +58,23 @@
             if isinstance(values_type, Iterable):
                 values_type = set(values_type)
             else:
                 values_type = {values_type}
 
         if len(values_type) > 1 and all(isinstance(x, MappingType) for x in values_type):
             first_item: MappingType = list(values_type)[0]
-            mapping_type = type(first_item)          # first mapping type
+            mapping_type = type(first_item)  # first mapping type
 
             k_types = set(value.key_type for value in values_type)
             v_types = set(value.value_type for value in values_type)
 
             if all(isinstance(x, mapping_type) for x in values_type):
                 values_type = {mapping_type(keys_type=k_types, values_type=v_types)}
             else:
-                from boa3.model.type.type import Type
+                from boa3.internal.model.type.type import Type
                 generic_type: IType = Type.get_generic_type(*values_type)
                 if isinstance(generic_type, MappingType):
                     values_type = {generic_type.build_collection(k_types, v_types)}
 
             return values_type
 
         # if any value is not a map, call the collection filter
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/mapping/mutable/mutablemappingtype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/mutable/mutablemappingtype.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from abc import ABC
 from typing import Any, Set
 
-from boa3.model.type.collection.mapping.mappingtype import MappingType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
+from boa3.internal.model.type.itype import IType
 
 
 class MutableMappingType(MappingType, ABC):
     """
     An interface used to represent Python mutable mapping type
     """
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/ecpointtype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/primitive/strtype.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,73 +1,57 @@
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.type.AbiType import AbiType
+from boa3.internal import constants
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class ECPointType(BytesType, ClassType):
+class StrType(IByteStringType):
     """
-    A class used to represent Neo's UInt160 type
+    A class used to represent Python str type
     """
 
     def __init__(self):
-        super().__init__()
-        self._identifier = 'ECPoint'
-        from boa3.model.builtin.method.ecpointmethod import ECPointMethod
-        self._constructor = ECPointMethod(self)
+        identifier = 'str'
+        super().__init__(identifier, [self])
 
     @property
-    def identifier(self) -> str:
-        return self._identifier
+    def default_value(self) -> Any:
+        return str()
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.PublicKey
+        return AbiType.String
 
-    @property
-    def variables(self) -> Dict[str, Variable]:
-        return {}
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
 
-    @property
-    def properties(self) -> Dict[str, Property]:
-        return {}
+        from boa3.internal.model.builtin.builtin import Builtin
 
-    @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
+        instance_methods = [Builtin.StrSplit,
+                            Builtin.BytesStringIndex,
+                            ]
 
-    @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
+        for instance_method in instance_methods:
+            self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
 
-    def constructor_method(self) -> Optional[Method]:
-        return self._constructor
-
-    @property
-    def default_value(self) -> Any:
-        return bytes(20)
+        self._instance_methods[constants.INIT_METHOD_ID] = Builtin.StrBytes
 
     @classmethod
-    def build(cls, value: Any = None) -> IType:
-        return _ECPoint
+    def build(cls, value: Any) -> IType:
+        if cls._is_type_of(value):
+            from boa3.internal.model.type.type import Type
+            return Type.str
 
     @classmethod
-    def _is_type_of(cls, value: Any):
-        return isinstance(value, ECPointType)
-
-    def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
-        push_int_opcode, size_data = Opcode.get_push_and_data(33)
-
-        return [
-            (Opcode.SIZE, b''),  # return len(value) == 33
-            (push_int_opcode, size_data),
-            (Opcode.NUMEQUAL, b'')
-        ]
+    def build_collection(cls, value_type: IType):
+        from boa3.internal.model.type.type import Type
+        return Type.str
 
+    @classmethod
+    def _is_type_of(cls, value: Any) -> bool:
+        from boa3.internal.model.type.collection.sequence.buffertype import BufferType
+        return isinstance(value, (str, StrType)) and not isinstance(value, BufferType)
 
-_ECPoint = ECPointType()
+    def is_type_of(self, value: Any) -> bool:
+        return self._is_type_of(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/genericsequencetype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/tupletype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,40 +1,49 @@
 from typing import Any, Set
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
 
 
-class GenericSequenceType(SequenceType):
+class TupleType(SequenceType):
     """
-    An class used to represent a generic Python sequence type
+    A class used to represent Python tuple type
     """
 
     def __init__(self, values_type: Set[IType] = None):
-        identifier: str = 'sequence'
+        identifier = 'tuple'
         values_type = self.filter_types(values_type)
         super().__init__(identifier, values_type)
 
+    @property
+    def default_value(self) -> Any:
+        return tuple()
+
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return Type.int
 
-    @property
-    def is_generic(self) -> bool:
-        return True
-
     @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
             values_types: Set[IType] = cls.get_types(value)
             return cls(values_types)
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, SequenceType)
+        return type(value) is tuple or isinstance(value, TupleType)
+
+    @property
+    def can_reassign_values(self) -> bool:
+        return False
+
+    def __eq__(self, other) -> bool:
+        if type(self) != type(other):
+            return False
+        return self.value_type == other.value_type
 
     def __hash__(self):
         return hash(self.identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/genericmutablesequencetype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/genericmutablesequencetype.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import Any, Set
 
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
+from boa3.internal.model.type.itype import IType
 
 
 class GenericMutableSequenceType(MutableSequenceType):
     """
     An class used to represent a generic Python mutable sequence type
     """
 
@@ -15,15 +15,15 @@
         super().__init__(identifier, values_type)
 
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return Type.int
 
     @property
     def is_generic(self) -> bool:
         return True
 
     @classmethod
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/listtype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/interop/blockchain/witnessruleactiontype.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,45 +1,58 @@
-from typing import Any, Set
+from __future__ import annotations
 
-from boa3.model.type.collection.sequence.mutable.mutablesequencetype import MutableSequenceType
-from boa3.model.type.itype import IType
+from typing import Any, Dict
 
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.primitive.inttype import IntType
+from boa3.internal.neo3.network.payloads.verification import WitnessRuleAction
 
-class ListType(MutableSequenceType):
+
+class WitnessRuleActionType(IntType):
     """
-    A class used to represent Python list type
+    A class used to represent Neo interop WitnessRuleAction type
     """
 
-    def __init__(self, values_type: Set[IType] = None):
-        identifier = 'list'
-        values_type = self.filter_types(values_type)
-        super().__init__(identifier, values_type)
+    def __init__(self):
+        super().__init__()
+        self._identifier = 'WitnessRuleAction'
 
     @property
     def default_value(self) -> Any:
-        return list()
+        return WitnessRuleAction.DENY
 
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
+    @classmethod
+    def build(cls, value: Any = None) -> WitnessRuleActionType:
+        if value is None or cls._is_type_of(value):
+            return _WitnessRuleAction
+
+    @classmethod
+    def _is_type_of(cls, value: Any = None):
+        return isinstance(value, (WitnessRuleAction, WitnessRuleActionType))
 
     @property
-    def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
-        return Type.int
+    def symbols(self) -> Dict[str, ISymbol]:
+        """
+        Gets the class symbols of this type
 
-    @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            values_types: Set[IType] = cls.get_types(value)
-            return cls(values_types)
+        :return: a dictionary that maps each symbol in the module with its name
+        """
+        from boa3.internal.model.variable import Variable
 
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return type(value) in [list, ListType]
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in WitnessRuleAction.__members__.keys()})
+
+        return _symbols
+
+    def get_value(self, symbol_id) -> Any:
+        """
+        Gets the literal value of a symbol
+
+        :return: the value if this type has this symbol. None otherwise.
+        """
+        if symbol_id in self.symbols:
+            return WitnessRuleAction.__members__[symbol_id]
+
+        return None
 
-    def __eq__(self, other) -> bool:
-        if type(self) != type(other):
-            return False
-        return self.value_type == other.value_type
 
-    def __hash__(self):
-        return hash(self.identifier)
+_WitnessRuleAction = WitnessRuleActionType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/mutable/mutablesequencetype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/mapping/genericmappingtype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,25 +1,30 @@
-from abc import ABC
 from typing import Any, Set
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.mapping.mappingtype import MappingType
+from boa3.internal.model.type.itype import IType
 
 
-class MutableSequenceType(SequenceType, ABC):
+class GenericMappingType(MappingType):
     """
-    An interface used to represent Python mutable sequence type
+    An class used to represent a generic Python sequence type
     """
 
-    def __init__(self, identifier: str, values_type: Set[IType]):
-        super().__init__(identifier, values_type)
+    def __init__(self, keys_type: Set[IType] = None, values_type: Set[IType] = None):
+        identifier: str = 'mapping'
+        keys_type = self.filter_types(keys_type)
+        values_type = self.filter_types(values_type)
+        super().__init__(identifier, keys_type, values_type)
 
-    def is_type_of(self, value: Any) -> bool:
-        if self._is_type_of(value):
-            if isinstance(value, MutableSequenceType):
-                return self.value_type.is_type_of(value.value_type)
-            return True
-        return False
+    def is_valid_key(self, key_type: IType) -> bool:
+        return key_type == self.valid_key
 
     @property
-    def can_reassign_values(self) -> bool:
+    def is_generic(self) -> bool:
         return True
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return isinstance(value, MappingType)
+
+    def __hash__(self):
+        return hash(self.identifier)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/rangetype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/rangetype.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import Any
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
 
 
 class RangeType(SequenceType):
     """
     A class used to represent Python range type
     """
 
@@ -23,21 +23,21 @@
         return self._identifier
 
     def is_valid_key(self, key_type: IType) -> bool:
         return key_type == self.valid_key
 
     @property
     def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return Type.int
 
     @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            from boa3.model.type.type import Type
+            from boa3.internal.model.type.type import Type
             return cls(Type.int)
 
     @classmethod
     def _is_type_of(cls, value: Any):
         return type(value) is range or isinstance(value, RangeType)
 
     @property
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/reversedtype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/strmethod.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,53 +1,53 @@
-from typing import Any
+import ast
+from typing import Any, Dict, List, Optional
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
 
 
-class ReversedType(SequenceType):
-    """
-    A class used to represent Python reversed type. It's represented as a Sequence instead of a Iterable.
-    """
+class StrMethod(IBuiltinMethod):
 
-    def __init__(self, values_type: IType = None):
-        identifier = 'reversed'
-        values_type = self.filter_types(values_type)
-        super().__init__(identifier, values_type)
+    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+        from boa3.internal.model.type.type import Type
+        identifier = 'str'
+        super().__init__(identifier, args, defaults=defaults, return_type=Type.str)
 
     @property
-    def default_value(self) -> Any:
-        return reversed([])
+    def _arg_value(self) -> Variable:
+        return self.args['object']
 
     @property
     def identifier(self) -> str:
-        return self._identifier
+        from boa3.internal.model.type.type import Type
+
+        if self._arg_value.type is Type.bool:
+            return '-{0}_{1}'.format(self._identifier, Type.bool.identifier)
 
-    @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            from boa3.model.type.type import Type
-            return cls(Type.reversed)
+        if self._arg_value.type is Type.int:
+            return '-{0}_{1}'.format(self._identifier, Type.int.identifier)
 
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
+        return self._identifier
 
     @property
-    def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
-        return Type.int
-
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return type(value) is reversed or isinstance(value, ReversedType)
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
     @property
-    def can_reassign_values(self) -> bool:
-        return False
+    def _body(self) -> Optional[str]:
+        return None
+
+    def build(self, value: Any) -> IBuiltinMethod:
+        if not isinstance(value, list):
+            value = [value]
+
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.builtin.builtin import Builtin
+        if len(value) > 0:
+
+            if Type.bool.is_type_of(value[0]):
+                return Builtin.StrBool
 
-    def __eq__(self, other) -> bool:
-        if type(self) != type(other):
-            return False
-        return self.value_type == other.value_type
+            if Type.int.is_type_of(value[0]):
+                return Builtin.StrInt
 
-    def __hash__(self):
-        return hash(self.identifier)
+        return Builtin.StrBytes
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/sequencetype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/primitive/bytestype.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,36 +1,38 @@
-from abc import ABC
-from typing import Any, Set
+from typing import Any
 
-from boa3.model.type.collection.icollection import ICollectionType
-from boa3.model.type.itype import IType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class SequenceType(ICollectionType, ABC):
+class BytesType(IByteStringType):
     """
-    An interface used to represent Python sequence type
+    A class used to represent Python bytes type
     """
 
-    def __init__(self, identifier: str, values_type: Set[IType]):
-        super().__init__(identifier, values_type=values_type)
-        self.value_type: IType = self.item_type
-
-    @property
-    def default_value(self) -> Any:
-        return []
-
-    def is_type_of(self, value: Any) -> bool:
-        if self._is_type_of(value):
-            if isinstance(value, SequenceType):
-                return self.value_type.is_type_of(value.value_type)
-            return True
-        return False
+    def __init__(self):
+        identifier = 'bytes'
+        from boa3.internal.model.type.primitive.inttype import IntType
+        values_type = [IntType()]
+        super().__init__(identifier, values_type)
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.Array
+        return AbiType.ByteArray
 
     @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.Array
+    def default_value(self) -> Any:
+        return bytes()
+
+    @classmethod
+    def build(cls, value: Any) -> IType:
+        from boa3.internal.model.type.type import Type
+        return Type.bytes
+
+    @classmethod
+    def build_collection(cls, *value_type: IType):
+        return cls.build(value_type)
+
+    @classmethod
+    def _is_type_of(cls, value: Any):
+        return type(value) is bytes or isinstance(value, BytesType)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/tupletype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/neo/opcodetype.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,49 +1,60 @@
-from typing import Any, Set
+from typing import Any, Dict
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
 
 
-class TupleType(SequenceType):
+class OpcodeType(BytesType):
     """
-    A class used to represent Python tuple type
+    A class used to represent Neo interop Opcode type
     """
 
-    def __init__(self, values_type: Set[IType] = None):
-        identifier = 'tuple'
-        values_type = self.filter_types(values_type)
-        super().__init__(identifier, values_type)
+    def __init__(self):
+        super().__init__()
+        self._identifier = 'Opcode'
 
     @property
     def default_value(self) -> Any:
-        return tuple()
-
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
-
-    @property
-    def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
-        return Type.int
+        from boa3.internal.neo.vm.opcode.Opcode import Opcode
+        return Opcode.NOP
 
     @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            values_types: Set[IType] = cls.get_types(value)
-            return cls(values_types)
+    def build(cls, value: Any = None) -> IType:
+        if value is None or cls._is_type_of(value):
+            return _Opcode
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return type(value) is tuple or isinstance(value, TupleType)
+        from boa3.internal.neo.vm.opcode.Opcode import Opcode
+        return isinstance(value, (Opcode, OpcodeType))
 
     @property
-    def can_reassign_values(self) -> bool:
-        return False
+    def symbols(self) -> Dict[str, ISymbol]:
+        """
+        Gets the class symbols of this type
+
+        :return: a dictionary that maps each symbol in the module with its name
+        """
+        from boa3.internal.neo.vm.opcode.Opcode import Opcode
+        from boa3.internal.model.variable import Variable
+
+        _symbols = super().symbols
+        _symbols.update({name: Variable(self) for name in Opcode.__members__.keys()})
+
+        return _symbols
+
+    def get_value(self, symbol_id) -> Any:
+        """
+        Gets the literal value of a symbol
+
+        :return: the value if this type has this symbol. None otherwise.
+        """
+        if symbol_id in self.symbols:
+            from boa3.internal.neo.vm.opcode.Opcode import Opcode
+            return Opcode.__members__[symbol_id]
+
+        return None
 
-    def __eq__(self, other) -> bool:
-        if type(self) != type(other):
-            return False
-        return self.value_type == other.value_type
 
-    def __hash__(self):
-        return hash(self.identifier)
+_Opcode = OpcodeType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/uint160type.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/uint256type.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,78 +1,61 @@
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, List, Optional, Tuple
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal import constants
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.classes.classtype import ClassType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class UInt160Type(BytesType, ClassType):
+class UInt256Type(BytesType, ClassType):
     """
-    A class used to represent Neo's UInt160 type
+    A class used to represent Neo's UInt256 type
     """
 
     def __init__(self):
         super().__init__()
-        self._identifier = 'UInt160'
-        from boa3.model.builtin.method.uint160method import UInt160Method
-        self._constructor = UInt160Method(self)
+        self._identifier = 'UInt256'
+        from boa3.internal.model.builtin.method.uint256method import UInt256Method
+        self._constructor = UInt256Method(self)
 
     @property
     def identifier(self) -> str:
         return self._identifier
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.Hash160
-
-    @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.ByteString
-
-    @property
-    def variables(self) -> Dict[str, Variable]:
-        return {}
-
-    @property
-    def properties(self) -> Dict[str, Property]:
-        return {}
-
-    @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
-
-    @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
+        return AbiType.Hash256
 
     def constructor_method(self) -> Optional[Method]:
         return self._constructor
 
     @property
     def default_value(self) -> Any:
-        return bytes(20)
+        return bytes(constants.SIZE_OF_INT256)
 
     @classmethod
     def build(cls, value: Any = None) -> IType:
-        return _UInt160
+        return _UInt256
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, UInt160Type)
+        return isinstance(value, UInt256Type)
+
+    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        return super(PythonClass, self).is_instance_opcodes()
 
     def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
-        push_int_opcode, size_data = Opcode.get_push_and_data(20)
+        push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_INT256)
 
         return [
-            (Opcode.SIZE, b''),  # return len(value) == 20
+            (Opcode.SIZE, b''),  # return len(value) == 32
             (push_int_opcode, size_data),
             (Opcode.NUMEQUAL, b'')
         ]
 
 
-_UInt160 = UInt160Type()
+_UInt256 = UInt256Type()
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/collection/sequence/uint256type.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/ecpointtype.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,78 +1,72 @@
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, List, Optional, Tuple
 
-from boa3.model.method import Method
-from boa3.model.property import Property
-from boa3.model.type.classes.classtype import ClassType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal import constants
+from boa3.internal.model.method import Method
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class UInt256Type(BytesType, ClassType):
+class ECPointType(BytesType):
     """
-    A class used to represent Neo's UInt256 type
+    A class used to represent Neo's UInt160 type
     """
 
     def __init__(self):
         super().__init__()
-        self._identifier = 'UInt256'
-        from boa3.model.builtin.method.uint256method import UInt256Method
-        self._constructor = UInt256Method(self)
+        self._identifier = 'ECPoint'
+        from boa3.internal.model.builtin.method.ecpointmethod import ECPointMethod
+        self._constructor = ECPointMethod(self)
 
     @property
     def identifier(self) -> str:
         return self._identifier
 
     @property
     def abi_type(self) -> AbiType:
-        return AbiType.Hash256
-
-    @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.ByteString
-
-    @property
-    def variables(self) -> Dict[str, Variable]:
-        return {}
-
-    @property
-    def properties(self) -> Dict[str, Property]:
-        return {}
-
-    @property
-    def class_methods(self) -> Dict[str, Method]:
-        return {}
-
-    @property
-    def instance_methods(self) -> Dict[str, Method]:
-        return {}
+        return AbiType.PublicKey
 
     def constructor_method(self) -> Optional[Method]:
         return self._constructor
 
     @property
     def default_value(self) -> Any:
-        return bytes(32)
+        return bytes(constants.SIZE_OF_ECPOINT)
 
     @classmethod
     def build(cls, value: Any = None) -> IType:
-        return _UInt256
+        return _ECPoint
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return isinstance(value, UInt256Type)
+        return isinstance(value, ECPointType)
+
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
+
+        from boa3.internal.model.builtin.builtin import Builtin
+
+        instance_methods = [Builtin.ScriptHashMethod_,
+                            ]
+
+        for instance_method in instance_methods:
+            self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
+
+    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.classes.pythonclass import PythonClass
+        return super(PythonClass, self).is_instance_opcodes()
 
     def _is_instance_inner_opcodes(self, jmp_to_if_false: int = 0) -> List[Tuple[Opcode, bytes]]:
-        push_int_opcode, size_data = Opcode.get_push_and_data(32)
+        from boa3.internal import constants
+        push_int_opcode, size_data = OpcodeHelper.get_push_and_data(constants.SIZE_OF_ECPOINT)
 
         return [
-            (Opcode.SIZE, b''),  # return len(value) == 32
+            (Opcode.SIZE, b''),  # return len(value) == 33
             (push_int_opcode, size_data),
             (Opcode.NUMEQUAL, b'')
         ]
 
 
-_UInt256 = UInt256Type()
+_ECPoint = ECPointType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/itype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/itype.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from __future__ import annotations
 
 from abc import abstractmethod
 from typing import Any, Dict, List, Tuple
 
-from boa3.model.identifiedsymbol import IdentifiedSymbol
-from boa3.model.symbol import ISymbol
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class IType(IdentifiedSymbol):
     """
     An interface used to represent types
 
     :ivar identifier: the name identifier of the type
@@ -118,15 +118,15 @@
         Gets a type that is an union of `self` and `other_type`
 
         :param other_type: type that'll be united with `self`
         :type other_type: IType
         :return: an union of this type and other_type
         :rtype: IType
         """
-        from boa3.model.type.annotation.uniontype import UnionType
+        from boa3.internal.model.type.annotation.uniontype import UnionType
         return UnionType.build((self, other_type))
 
     def except_type(self, other_type: IType) -> IType:
         """
         Gets a type that is type of `self` but is not type of `other_type`.
         If `other_type` is an implementation of `self`, returns `self`
 
@@ -149,24 +149,24 @@
         :rtype: IType
         """
         if self.is_type_of(other_type):
             return other_type
         if other_type.is_type_of(self):
             return self
 
-        from boa3.model.type.annotation.uniontype import UnionType
+        from boa3.internal.model.type.annotation.uniontype import UnionType
         if isinstance(other_type, UnionType):
             same_types = [x for x in other_type.union_types if self.is_type_of(x)]
             if len(same_types) == 0:
                 return self
             elif len(same_types) == 1:
                 return same_types[0]
             else:
                 return UnionType.build(same_types)
 
-        from boa3.model.type.type import Type
+        from boa3.internal.model.type.type import Type
         return Type.none
 
     def is_equal(self, other: Any) -> bool:
         if not isinstance(other, IType):
             return False
         return self.is_type_of(other) and other.is_type_of(self)
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/primitive/booltype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/primitive/bytestringtype.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,38 +1,28 @@
 from typing import Any
 
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.inttype import IntType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.ibytestringtype import IByteStringType
 
 
-class BoolType(IntType):
+class ByteStringType(IByteStringType):
     """
-    A class used to represent Python bool type
+    A class used to represent ByteString type interface
     """
 
     def __init__(self):
-        super().__init__()
-        self._identifier = 'bool'
-
-    @property
-    def default_value(self) -> Any:
-        return bool()
-
-    @property
-    def abi_type(self) -> AbiType:
-        return AbiType.Boolean
-
-    @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.Boolean
+        identifier = 'ByteString'
+        values_type = [self]
+        super().__init__(identifier, values_type)
 
     @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            from boa3.model.type.type import Type
-            return Type.bool
+    def _is_type_of(cls, value: Any) -> bool:
+        from boa3.internal.model.type.type import Type
+        return (Type.str.is_type_of(value)
+                or Type.bytes.is_type_of(value))
 
     @classmethod
-    def _is_type_of(cls, value: Any):
-        return type(value) in [bool, BoolType]
+    def build(cls, value: Any = None) -> IType:
+        return _ByteString
+
+
+_ByteString = ByteStringType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/primitive/bytestype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/intmethod.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,60 +1,49 @@
-from typing import Any
+import ast
+from typing import Any, Dict, List, Optional
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
-
-
-class BytesType(SequenceType, PrimitiveType):
-    """
-    A class used to represent Python bytes type
-    """
-
-    def __init__(self):
-        identifier = 'bytes'
-        from boa3.model.type.primitive.inttype import IntType
-        values_type = [IntType()]
-        super().__init__(identifier, values_type)
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.variable import Variable
 
-    @property
-    def identifier(self) -> str:
-        return self._identifier
 
-    @property
-    def abi_type(self) -> AbiType:
-        return AbiType.ByteArray
+class IntMethod(IBuiltinMethod):
+
+    def __init__(self, args: Dict[str, Variable] = None, defaults: List[ast.AST] = None):
+        from boa3.internal.model.type.type import Type
+        identifier = 'int'
+        super().__init__(identifier, args, defaults=defaults, return_type=Type.int)
 
     @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.ByteString
+    def _arg_value(self) -> Variable:
+        return self.args['value']
 
     @property
-    def default_value(self) -> Any:
-        return bytes()
+    def identifier(self) -> str:
+        from boa3.internal.model.type.type import Type
 
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
+        if self._arg_value.type is Type.int:
+            return '-{0}_{1}'.format(self._identifier, Type.int)
+
+        if self._arg_value.type.is_type_of(Type.str) or self._arg_value.type.is_type_of(Type.bytes):
+            return '-{0}_{1}'.format(self._identifier, Type.str)
+
+        return self._identifier
 
     @property
-    def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
-        return Type.int
-
-    @classmethod
-    def build(cls, value: Any) -> IType:
-        from boa3.model.type.type import Type
-        return Type.bytes
-
-    @classmethod
-    def build_collection(cls, *value_type: IType):
-        return cls.build(value_type)
-
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        return type(value) is bytes or isinstance(value, BytesType)
+    def _args_on_stack(self) -> int:
+        return len(self.args)
 
     @property
-    def can_reassign_values(self) -> bool:
-        return False
+    def _body(self) -> Optional[str]:
+        return None
+
+    def build(self, value: Any) -> IBuiltinMethod:
+        if not isinstance(value, list):
+            value = [value]
+
+        from boa3.internal.model.type.type import Type
+        from boa3.internal.model.builtin.builtin import Builtin
+        if len(value) == 0 or Type.int.is_type_of(value[0]):
+            return Builtin.IntInt
+
+        if Type.str.is_type_of(value[0]) or Type.bytes.is_type_of(value[0]):
+            return Builtin.IntByteString
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/primitive/inttype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/primitive/nonetype.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,38 +1,37 @@
-from typing import Any
+from typing import Any, List, Tuple
 
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.type.classes.pythonclass import PythonClass
+from boa3.internal.model.type.itype import IType
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.type.AbiType import AbiType
 
 
-class IntType(PrimitiveType):
+class NoneType(PythonClass):
     """
-    A class used to represent Python int type
+    A class used to represent Python None value
     """
 
     def __init__(self):
-        identifier = 'int'
+        identifier = 'none'
         super().__init__(identifier)
 
     @property
-    def default_value(self) -> Any:
-        return int()
-
-    @property
     def abi_type(self) -> AbiType:
-        return AbiType.Integer
-
-    @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.Integer
+        return AbiType.Void
 
     @classmethod
     def build(cls, value: Any) -> IType:
         if cls._is_type_of(value):
-            from boa3.model.type.type import Type
-            return Type.int
+            from boa3.internal.model.type.type import Type
+            return Type.none
 
     @classmethod
     def _is_type_of(cls, value: Any):
-        return type(value) is int or isinstance(value, IntType)
+        from boa3.internal.model.type.type import Type
+        return value is None or value is Type.none
+
+    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
+        return [(Opcode.ISNULL, b'')]
+
+
+noneType: IType = NoneType()
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/primitive/nonetype.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/listmappingmethod.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,36 +1,34 @@
-from typing import Any, List, Tuple
+from typing import Dict, List, Tuple
 
-from boa3.model.type.itype import IType
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.type.AbiType import AbiType
+from boa3.internal.model.builtin.method.listmethod import ListMethod
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
-class NoneType(IType):
-    """
-    A class used to represent Python None value
-    """
+class ListMappingMethod(ListMethod):
 
-    def __init__(self):
-        identifier = 'none'
-        super().__init__(identifier)
+    def __init__(self, mapping_type: IType = None):
+        from boa3.internal.model.type.type import Type
+        if mapping_type is None:
+            mapping_type = Type.mapping
 
-    @property
-    def abi_type(self) -> AbiType:
-        return AbiType.Void
+        args: Dict[str, Variable] = {
+            'value': Variable(mapping_type),
+        }
+
+        return_type = Type.list.build_collection(mapping_type.key_type)
 
-    @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            from boa3.model.type.type import Type
-            return Type.none
+        super().__init__(args, return_type)
 
-    @classmethod
-    def _is_type_of(cls, value: Any):
-        from boa3.model.type.type import Type
-        return value is None or value is Type.none
+    @property
+    def prepare_for_packing(self) -> List[Tuple[Opcode, bytes]]:
 
-    def is_instance_opcodes(self) -> List[Tuple[Opcode, bytes]]:
-        return [(Opcode.ISNULL, b'')]
+        if self._prepare_for_packing is None:
 
+            self._prepare_for_packing = [
+                (Opcode.KEYS, b''),
+                (Opcode.UNPACK, b'')
+            ]
 
-noneType: IType = NoneType()
+        return super().prepare_for_packing
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/primitive/strtype.py` & `neo3-boa-1.0.0/boa3/internal/model/type/collection/sequence/mutable/mutablesequencetype.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,63 +1,42 @@
-from typing import Any
+from abc import ABC
+from typing import Any, Set
 
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.primitivetype import PrimitiveType
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.model.type.collection.sequence.sequencetype import SequenceType
+from boa3.internal.model.type.itype import IType
 
 
-class StrType(SequenceType, PrimitiveType):
+class MutableSequenceType(SequenceType, ABC):
     """
-    A class used to represent Python str type
+    An interface used to represent Python mutable sequence type
     """
 
-    def __init__(self):
-        identifier = 'str'
-        super().__init__(identifier, [self])
+    def __init__(self, identifier: str, values_type: Set[IType]):
+        super().__init__(identifier, values_type)
 
-    @property
-    def identifier(self) -> str:
-        return self._identifier
+    def _init_class_symbols(self):
+        super()._init_class_symbols()
 
-    @property
-    def default_value(self) -> Any:
-        return str()
+        from boa3.internal.model.builtin.builtin import Builtin
 
-    @property
-    def abi_type(self) -> AbiType:
-        return AbiType.String
-
-    @property
-    def stack_item(self) -> StackItemType:
-        return StackItemType.ByteString
+        instance_methods = [Builtin.SequenceAppend,
+                            Builtin.SequenceClear,
+                            Builtin.SequenceInsert,
+                            Builtin.SequenceExtend,
+                            Builtin.SequencePop,
+                            Builtin.SequenceReverse,
+                            Builtin.SequenceRemove,
+                            ]
 
-    @classmethod
-    def build(cls, value: Any) -> IType:
-        if cls._is_type_of(value):
-            from boa3.model.type.type import Type
-            return Type.str
-
-    @classmethod
-    def build_collection(cls, value_type: IType):
-        from boa3.model.type.type import Type
-        return Type.str
-
-    @classmethod
-    def _is_type_of(cls, value: Any) -> bool:
-        return type(value) in [str, StrType]
+        for instance_method in instance_methods:
+            self._instance_methods[instance_method.raw_identifier] = instance_method.build(self)
 
     def is_type_of(self, value: Any) -> bool:
-        return self._is_type_of(value)
-
-    def is_valid_key(self, key_type: IType) -> bool:
-        return key_type == self.valid_key
-
-    @property
-    def valid_key(self) -> IType:
-        from boa3.model.type.type import Type
-        return Type.int
+        if self._is_type_of(value):
+            if isinstance(value, MutableSequenceType):
+                return self.value_type.is_type_of(value.value_type)
+            return True
+        return False
 
     @property
     def can_reassign_values(self) -> bool:
-        return False
+        return True
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/type.py` & `neo3-boa-1.0.0/boa3/internal/model/type/type.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 from typing import Any, Dict
 
-from boa3.model.type.annotation.optionaltype import OptionalType
-from boa3.model.type.annotation.uniontype import UnionType
-from boa3.model.type.anytype import anyType
-from boa3.model.type.baseexceptiontype import BaseExceptionType
-from boa3.model.type.collection.genericcollectiontype import GenericCollectionType
-from boa3.model.type.collection.mapping.genericmappingtype import GenericMappingType
-from boa3.model.type.collection.mapping.mutable.dicttype import DictType
-from boa3.model.type.collection.sequence.genericsequencetype import GenericSequenceType
-from boa3.model.type.collection.sequence.mutable.genericmutablesequencetype import GenericMutableSequenceType
-from boa3.model.type.collection.sequence.mutable.listtype import ListType
-from boa3.model.type.collection.sequence.rangetype import RangeType
-from boa3.model.type.collection.sequence.reversedtype import ReversedType
-from boa3.model.type.collection.sequence.tupletype import TupleType
-from boa3.model.type.itype import IType
-from boa3.model.type.primitive.booltype import BoolType
-from boa3.model.type.primitive.bytearraytype import ByteArrayType
-from boa3.model.type.primitive.bytestype import BytesType
-from boa3.model.type.primitive.inttype import IntType
-from boa3.model.type.primitive.nonetype import noneType
-from boa3.model.type.primitive.strtype import StrType
+from boa3.internal.model.type.annotation.optionaltype import OptionalType
+from boa3.internal.model.type.annotation.uniontype import UnionType
+from boa3.internal.model.type.anytype import anyType
+from boa3.internal.model.type.baseexceptiontype import BaseExceptionType
+from boa3.internal.model.type.collection.genericcollectiontype import GenericCollectionType
+from boa3.internal.model.type.collection.mapping.genericmappingtype import GenericMappingType
+from boa3.internal.model.type.collection.mapping.mutable.dicttype import DictType
+from boa3.internal.model.type.collection.sequence.genericsequencetype import GenericSequenceType
+from boa3.internal.model.type.collection.sequence.mutable.genericmutablesequencetype import GenericMutableSequenceType
+from boa3.internal.model.type.collection.sequence.mutable.listtype import ListType
+from boa3.internal.model.type.collection.sequence.rangetype import RangeType
+from boa3.internal.model.type.collection.sequence.reversedtype import ReversedType
+from boa3.internal.model.type.collection.sequence.tupletype import TupleType
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.booltype import BoolType
+from boa3.internal.model.type.primitive.bytearraytype import ByteArrayType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.type.primitive.inttype import IntType
+from boa3.internal.model.type.primitive.nonetype import noneType
+from boa3.internal.model.type.primitive.strtype import StrType
 
 
 class Type:
     @classmethod
     def builtin_types(cls) -> Dict[str, IType]:
         """
         Gets a dictionary that maps each type with its name
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/typeutils.py` & `neo3-boa-1.0.0/boa3/internal/model/type/typeutils.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 from typing import Dict, List
 
-from boa3.model.callable import Callable
-from boa3.model.symbol import ISymbol
-from boa3.model.type.annotation.metatype import metaType
-from boa3.model.type.type import Type
-from boa3.model.type.typingmethod.casttypemethod import CastTypeMethod
+from boa3.internal.model.callable import Callable
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.symbol import ISymbol
+from boa3.internal.model.type.annotation.metatype import metaType
+from boa3.internal.model.type.type import Type
+from boa3.internal.model.type.typingmethod.casttypemethod import CastTypeMethod
 
 
 class TypeUtils:
     @classmethod
     def all_functions(cls) -> Dict[str, Callable]:
-        from boa3.model.builtin.builtincallable import IBuiltinCallable
+        from boa3.internal.model.builtin.builtincallable import IBuiltinCallable
         return {tpe._identifier: tpe for tpe in vars(cls).values() if isinstance(tpe, IBuiltinCallable)}
 
     @classmethod
     def get_types_from_typing_lib(cls) -> Dict[str, ISymbol]:
         import typing
         from types import FunctionType
 
@@ -35,7 +36,13 @@
         return type_symbols
 
     # type for internal validation
     type = metaType
 
     # Annotation function utils
     cast = CastTypeMethod()
+
+    _internal_validation_symbols: List[IdentifiedSymbol] = [type
+                                                            ]
+
+    symbols_for_internal_validation = {symbol.identifier: symbol
+                                       for symbol in _internal_validation_symbols}
```

### Comparing `neo3-boa-0.9.0/boa3/model/type/typingmethod/casttypemethod.py` & `neo3-boa-1.0.0/boa3/internal/model/builtin/method/tobytesmethod.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,121 +1,141 @@
-from typing import Any, Dict, List, Optional, Sized, Tuple
+from abc import ABC
+from typing import Any, Dict, List, Optional, Sequence, Tuple
 
-from boa3.model.builtin.method.builtinmethod import IBuiltinMethod
-from boa3.model.expression import IExpression
-from boa3.model.type.annotation.metatype import MetaType, metaType
-from boa3.model.type.anytype import anyType
-from boa3.model.type.collection.sequence.sequencetype import SequenceType
-from boa3.model.type.itype import IType
-from boa3.model.variable import Variable
-from boa3.neo.vm.opcode.Opcode import Opcode
-
-
-class CastTypeMethod(IBuiltinMethod):
-
-    def __init__(self, cast_to_type: IType = None, origin_type: IType = None):
-        # if the type to be casted is not value, there's an error in the signature
-        if cast_to_type is None:
-            type_value = metaType
-        elif isinstance(cast_to_type, MetaType):
-            type_value = cast_to_type if cast_to_type.has_meta_type else metaType
-        else:
-            type_value = MetaType.build(cast_to_type)
-
-        if origin_type is None:
-            origin_type = anyType
-        elif isinstance(origin_type, MetaType):
-            origin_type = origin_type.meta_type if origin_type.has_meta_type else anyType
-
-        identifier = 'cast'
-        args: Dict[str, Variable] = {'typ': Variable(type_value),
-                                     'val': Variable(anyType)}
-        super().__init__(identifier, args,
-                         return_type=cast_to_type.meta_type if isinstance(cast_to_type, MetaType) else anyType)
-        self._origin_type: IType = origin_type
+from boa3.internal.model.builtin.method.builtinmethod import IBuiltinMethod
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.identifiedsymbol import IdentifiedSymbol
+from boa3.internal.model.type.itype import IType
+from boa3.internal.model.type.primitive.bytestype import BytesType
+from boa3.internal.model.type.primitive.inttype import IntType
+from boa3.internal.model.type.primitive.strtype import StrType
+from boa3.internal.model.variable import Variable
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+
+
+class ToBytesMethod(IBuiltinMethod, ABC):
+    def __init__(self, self_type: IType):
+        identifier = 'to_bytes'
+        args: Dict[str, Variable] = {'self': Variable(self_type)}
+        from boa3.internal.model.type.type import Type
+        super().__init__(identifier, args, return_type=Type.bytes)
 
     @property
-    def identifier(self) -> str:
-        if self.is_supported:
-            identifier = (self.typ_arg.type.meta_id
-                          if hasattr(self.typ_arg.type, 'meta_id')
-                          else self.typ_arg.type.identifier)
-            return '-{0}_{1}'.format(self._identifier, identifier)
-        else:
-            return self._identifier
+    def _arg_self(self) -> Variable:
+        return self.args['self']
 
     def validate_parameters(self, *params: IExpression) -> bool:
         if len(params) != 1:
             return False
-        if not isinstance(params[0], IExpression):
-            return False
-        return isinstance(params[0].type, SequenceType)
+        return isinstance(params[0], IExpression) and isinstance(params[0].type, BytesType)
 
     @property
-    def is_supported(self) -> bool:
-        return (isinstance(self.typ_arg, Variable)
-                and isinstance(self.typ_arg.type, MetaType)
-                and self.typ_arg.type.has_meta_type)
-
-    def not_supported_str(self, callable_id: str) -> str:
-        return '{0}({1})'.format(callable_id,
-                                 ','.join([arg.type.identifier if isinstance(arg, Variable) else 'unknown'
-                                           for arg in self.args.values()]))
+    def identifier(self) -> str:
+        if isinstance(self._arg_self.type, IdentifiedSymbol):
+            return '-{0}_{1}'.format(self._arg_self.type.identifier, self._identifier)
+        return self._identifier
 
     @property
-    def is_cast(self) -> bool:
-        return True
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.model.type.type import Type
+        return [
+            (Opcode.CONVERT, Type.bytes.stack_item)
+        ]
 
-    @property
-    def cast_types(self) -> Optional[Tuple[IType, IType]]:
-        origin_type = self._origin_type
-        target_type = (self.typ_arg.type.meta_type
-                       if hasattr(self.typ_arg.type, 'meta_type')
-                       else self.typ_arg.type)
-        return origin_type, target_type
+    def build(self, value: Any) -> IBuiltinMethod:
+        if isinstance(value, IntType):
+            return IntToBytesMethod(value)
+        elif isinstance(value, StrType):
+            return StrToBytesMethod(value)
+        # if it is not a valid type, show mismatched type with int
+        return IntToBytesMethod()
 
-    @property
-    def opcode(self) -> List[Tuple[Opcode, bytes]]:
-        return []
+    def push_self_first(self) -> bool:
+        return self.has_self_argument
 
     @property
     def _args_on_stack(self) -> int:
-        return 1  # the implementation is the same as x = arg
+        return len(self.args)
 
     @property
-    def args_on_stack(self) -> int:
-        return 1  # the implementation is the same as x = arg
+    def _body(self) -> Optional[str]:
+        return None
 
-    @property
-    def generation_order(self) -> List[int]:
-        # type should not be converted
-        indexes = super().generation_order
-        typ_index = list(self.args).index('typ')
 
-        if typ_index in indexes:
-            indexes.remove(typ_index)
+class _ConvertToBytesMethod(ToBytesMethod):
+    def __init__(self):
+        super().__init__(None)
 
-        return indexes
 
-    @property
-    def _body(self) -> Optional[str]:
-        return None
+ToBytes = _ConvertToBytesMethod()
+
+
+class IntToBytesMethod(ToBytesMethod):
+    def __init__(self, self_type: IType = None):
+        if not isinstance(self_type, IntType):
+            from boa3.internal.model.type.type import Type
+            self_type = Type.int
+        super().__init__(self_type)
+
+    def build(self, value: Any) -> IBuiltinMethod:
+        if isinstance(value, Sequence) and len(value) == 1:
+            value = value[0]
+        if type(value) == type(self.args['self'].type):
+            return self
+        if isinstance(value, IntType):
+            return IntToBytesMethod(value)
+        return super().build(value)
 
     @property
-    def typ_arg(self) -> Variable:
-        return self.args['typ'] if isinstance(self.args['typ'], Variable) else Variable(anyType)
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        from boa3.internal.compiler.codegenerator import get_bytes_count
+        from boa3.internal.neo.vm.type.Integer import Integer
+
+        number_zero_to_bytes = b'\x00'
+        jmp_place_holder = (Opcode.JMP, b'\x01')
+
+        verify_number_is_zero = [
+            (Opcode.DUP, b''),
+            (Opcode.NZ, b''),
+            jmp_place_holder
+        ]
+
+        number_is_not_zero = super()._opcode.copy()
+        number_is_not_zero.append(jmp_place_holder)
+
+        number_is_zero = [
+            (Opcode.DROP, b''),
+            (Opcode.PUSHDATA1, Integer(len(number_zero_to_bytes)).to_byte_array() + number_zero_to_bytes),
+        ]
+
+        number_is_not_zero[-1] = OpcodeHelper.get_jump_and_data(Opcode.JMP, get_bytes_count(number_is_zero))
+
+        verify_number_is_zero[-1] = OpcodeHelper.get_jump_and_data(Opcode.JMPIFNOT, get_bytes_count(number_is_not_zero))
+
+        return (
+            verify_number_is_zero +
+            number_is_not_zero +
+            number_is_zero
+        )
+
+
+class StrToBytesMethod(ToBytesMethod):
+    def __init__(self, self_type: IType = None):
+        if not isinstance(self_type, StrType):
+            from boa3.internal.model.type.type import Type
+            self_type = Type.str
+        super().__init__(self_type)
 
     @property
-    def val_arg(self) -> Variable:
-        return self.args['val']
+    def _opcode(self) -> List[Tuple[Opcode, bytes]]:
+        # string and bytes' stack item are the same
+        return []
 
     def build(self, value: Any) -> IBuiltinMethod:
-        if isinstance(value, Sized) and len(value) == len(self.args):
-            cast_to = value[0]
-            cast_from = value[1]
-
-            if isinstance(cast_to, IType):
-                if isinstance(cast_from, IType):
-                    return CastTypeMethod(cast_to, cast_from)
-                else:
-                    return CastTypeMethod(cast_to)
+        if isinstance(value, Sequence) and len(value) == 1:
+            value = value[0]
+        if type(value) == type(self.args['self'].type):
+            return self
+        if isinstance(value, StrType):
+            return StrToBytesMethod(value)
         return super().build(value)
```

### Comparing `neo3-boa-0.9.0/boa3/model/variable.py` & `neo3-boa-1.0.0/boa3/internal/model/variable.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,31 @@
 from __future__ import annotations
 
 import ast
-from typing import Optional
+from typing import Optional, Union
 
-from boa3.model.expression import IExpression
-from boa3.model.type.itype import IType
+from boa3.internal.model.expression import IExpression
+from boa3.internal.model.type.itype import IType
 
 
 class Variable(IExpression):
     """
     A class used to represent a variable
 
     :ivar var_type: the type of the variable.
     """
 
     def __init__(self, var_type: Optional[IType], origin_node: Optional[ast.AST] = None):
         super().__init__(origin_node)
         self.defined_by_entry = True
-        self._var_type: Optional[IType] = var_type
+        if var_type is None:
+            from boa3.internal.analyser.model.optimizer import Undefined, UndefinedType
+            var_type = Undefined
+
+        self._var_type: Union[IType, UndefinedType] = var_type
 
         self.is_reassigned = False
         self._origin_variable: Optional[Variable] = None
 
     def copy(self) -> Variable:
         var = Variable(self._var_type, self._origin_node)
         var.is_reassigned = self.is_reassigned
```

### Comparing `neo3-boa-0.9.0/boa3/neo/cryptography/__init__.py` & `neo3-boa-1.0.0/boa3/internal/neo/cryptography/__init__.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3/neo/smart_contract/notification.py` & `neo3-boa-1.0.0/boa3/internal/neo/smart_contract/notification.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 from __future__ import annotations
 
 from typing import Any, Dict, Tuple
 
-from boa3.neo import to_hex_str
-from boa3.neo.utils import stack_item_from_json
+from boa3.internal.neo import to_hex_str
+from boa3.internal.neo.utils import stack_item_from_json
 
 
 class Notification:
     _event_name_key = 'eventname'
     _script_hash_key = 'scripthash'
     _value_key = 'value'
 
@@ -25,15 +25,15 @@
         return self._script_hash
 
     @property
     def arguments(self) -> tuple:
         return self._value
 
     @classmethod
-    def from_json(cls, json: Dict[str, Any]) -> Notification:
+    def from_json(cls, json: Dict[str, Any], *args, **kwargs) -> Notification:
         """
         Creates a Notification object from a json.
 
         :param json: json that contains the notification data
         :return: a Notification object
         :rtype: Notification
         """
@@ -47,21 +47,27 @@
             value: Any = stack_item_from_json(json[cls._value_key]) if cls._value_key in json else []
         except ValueError:
             value = []
 
         if not isinstance(value, list):
             value = [value]
 
+        if isinstance(script, str):
+            script = cls._get_script_from_str(script)
+
+        return cls(name, script, *value)
+
+    @classmethod
+    def _get_script_from_str(cls, script: str) -> bytes:
         if isinstance(script, str) and script.startswith('0x'):
             bytes_script = bytearray()
             for x in range(2, len(script), 2):
                 bytes_script.append(int(script[x:x + 2], 16))
             bytes_script.reverse()
             script = bytes(bytes_script)
-
-        return cls(name, script, *value)
+        return script
 
     def __str__(self) -> str:
         return '[{0}] {1}'.format(to_hex_str(self.origin), self._event_name)
 
     def __repr__(self) -> str:
         return str(self)
```

### Comparing `neo3-boa-0.9.0/boa3/neo/utils/__init__.py` & `neo3-boa-1.0.0/boa3/internal/neo/utils/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,23 +1,32 @@
 from typing import Any, Dict, Optional, Sequence
 
-from boa3.neo.core.types.InteropInterface import InteropInterface
-from boa3.neo.vm.type.AbiType import AbiType
-from boa3.neo.vm.type.Integer import Integer
-from boa3.neo.vm.type.StackItem import StackItemType
-from boa3.neo.vm.type.String import String
+from boa3.internal.neo.core.types.InteropInterface import InteropInterface
+from boa3.internal.neo.vm.type.AbiType import AbiType
+from boa3.internal.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.type.StackItem import StackItemType
+from boa3.internal.neo.vm.type.String import String
 
 
 def stack_item_from_json(item: Dict[str, Any]) -> Any:
     if 'type' not in item:
         return None
 
     item_type: StackItemType = StackItemType.get_stack_item_type(item['type'])
     if item_type is StackItemType.InteropInterface:
-        return InteropInterface
+        if 'value' in item:
+            interop_interface = item['value']
+        else:
+            interop_interface = item
+
+        if isinstance(interop_interface, dict) and 'iterator' in interop_interface:
+            return [stack_item_from_json(value) for value in interop_interface['iterator']]
+        else:
+            return InteropInterface
+
     if item_type is StackItemType.Any or 'value' not in item:
         return None
 
     value: Any = None
     item_value: Any = item['value']
 
     if item_type is StackItemType.Boolean:
```

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/TryCode.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/TryCode.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import Optional
 
-from boa3.neo.vm.VMCode import VMCode
-from boa3.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.VMCode import VMCode
+from boa3.internal.neo.vm.type.Integer import Integer
 
 
 class TryCode(VMCode):
     """
     Represents a Neo VM function try code
 
     :ivar info: the opcode information of the code
@@ -15,15 +15,15 @@
     def __init__(self, except_start_code: Optional[VMCode] = None, finally_start_code: Optional[VMCode] = None):
         """
         :param except_start_code: the first code of the except body
         :type except_start_code: VMCode or None
         """
         self._except_start_code: Optional[VMCode] = except_start_code
         self._finally_start_code: Optional[VMCode] = finally_start_code
-        from boa3.neo.vm.opcode.OpcodeInfo import OpcodeInfo
+        from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo
         super().__init__(OpcodeInfo.TRY)
 
     @property
     def target(self) -> VMCode:
         return self._except_start_code if self._finally_start_code is None else self._finally_start_code
 
     def set_except_code(self, except_code: VMCode):
@@ -67,15 +67,15 @@
 
         :return: the unformatted data in bytes of the code.
         """
         min_len = self._info.data_len // 2  # for try opcode, data_len adds catch and finally addresses
         if opcode is None:
             return bytes(min_len)
         else:
-            from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
+            from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
             code_mapping = VMCodeMapping.instance()
             self_start = code_mapping.get_start_address(self)
             target_start = code_mapping.get_start_address(opcode)
 
             return (Integer(target_start - self_start)
                     .to_byte_array(signed=True, min_length=min_len))
```

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/VMCode.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/VMCode.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from __future__ import annotations
 
 from typing import Optional
 
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.opcode.OpcodeInformation import OpcodeInformation
-from boa3.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.opcode import OpcodeHelper
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.opcode.OpcodeInformation import OpcodeInformation
+from boa3.internal.neo.vm.type.Integer import Integer
 
 
 class VMCode:
     """
     Represents a Neo VM code
 
     :ivar info: the opcode information of the code
@@ -57,15 +58,15 @@
         Gets the Neo VM raw data of the code
 
         :return: the unformatted data in bytes of the code.
         """
         if self.target is None:
             return self._data
         else:
-            from boa3.compiler.codegenerator.vmcodemapping import VMCodeMapping
+            from boa3.internal.compiler.codegenerator.vmcodemapping import VMCodeMapping
             code_mapping = VMCodeMapping.instance()
             self_start = code_mapping.get_start_address(self)
             target_start = code_mapping.get_start_address(self.target)
 
             if self_start == target_start:
                 return self._data
 
@@ -89,24 +90,21 @@
     def target(self) -> VMCode:
         """
         Gets the target code of this code
 
         :return: the target code if this is a control code. None otherwise
         :rtype: VMCode
         """
-        return self._target if self.opcode.has_target() else None
+        return self._target if OpcodeHelper.has_target(self.opcode) else None
 
     def set_target(self, target_code):
         """
         Set the target code if this instruction's opcode requires a target
 
         :param target_code: the target code of this instruction
         :type target_code: VMCode
         """
-        if self.opcode.has_target():
+        if OpcodeHelper.has_target(self.opcode):
             self._target = target_code
 
     def __str__(self) -> str:
         return self.opcode.name + ' ' + self.data.hex()
-
-    def __repr__(self) -> str:
-        return str(self)
```

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/opcode/OpcodeInfo.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/OpcodeInfo.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Optional
 
-from boa3 import constants
-from boa3.neo.vm.opcode.Opcode import Opcode
-from boa3.neo.vm.opcode.OpcodeInformation import OpcodeInformation
+from boa3.internal import constants
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.opcode.OpcodeInformation import OpcodeInformation
 
 
 class OpcodeInfo:
     @classmethod
     def get_info(cls, opcode: Opcode) -> Optional[OpcodeInformation]:
         """
         Gets a binary operation given the operator.
@@ -24,14 +24,18 @@
     PUSHINT8 = OpcodeInformation(Opcode.PUSHINT8, 1)
     PUSHINT16 = OpcodeInformation(Opcode.PUSHINT16, 2)
     PUSHINT32 = OpcodeInformation(Opcode.PUSHINT32, 4)
     PUSHINT64 = OpcodeInformation(Opcode.PUSHINT64, 8)
     PUSHINT128 = OpcodeInformation(Opcode.PUSHINT128, 16)
     PUSHINT256 = OpcodeInformation(Opcode.PUSHINT256, 32)
 
+    # Pushes the boolean value True onto the stack.
+    PUSHT = OpcodeInformation(Opcode.PUSHT)
+    # Pushes the boolean value False onto the stack.
+    PUSHF = OpcodeInformation(Opcode.PUSHF)
     # Convert the next four bytes to an address, and push the address onto the stack.
     PUSHA = OpcodeInformation(Opcode.PUSHA, 4)
     # The item null is pushed onto the stack.
     PUSHNULL = OpcodeInformation(Opcode.PUSHNULL)
     # The next byte contains the number of bytes to be pushed onto the stack.
     PUSHDATA1 = OpcodeInformation(Opcode.PUSHDATA1, 1, constants.ONE_BYTE_MAX_VALUE)
     # The next two bytes contain the number of bytes to be pushed onto the stack.
@@ -379,14 +383,19 @@
     DIV = OpcodeInformation(Opcode.DIV)
     # Returns the remainder after dividing a by b.
     MOD = OpcodeInformation(Opcode.MOD)
     # The result of raising value to the exponent power.
     POW = OpcodeInformation(Opcode.POW)
     # Returns the square root of a specified number.
     SQRT = OpcodeInformation(Opcode.SQRT)
+    # Performs modulus division on a number multiplied by another number.
+    MODMUL = OpcodeInformation(Opcode.MODMUL)
+    # Performs modulus division on a number raised to the power of another number.
+    # If the exponent is -1, it will have the calculation of the modular inverse.
+    MODPOW = OpcodeInformation(Opcode.MODPOW)
     # Shifts a left b bits, preserving sign.
     SHL = OpcodeInformation(Opcode.SHL)
     # Shifts a right b bits, preserving sign.
     SHR = OpcodeInformation(Opcode.SHR)
     # If the input is 0 or 1, it is flipped. Otherwise the output will be 0.
     NOT = OpcodeInformation(Opcode.NOT)
     # If both a and b are not 0, the output is 1. Otherwise 0.
@@ -414,19 +423,25 @@
     # Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.
     WITHIN = OpcodeInformation(Opcode.WITHIN)
 
     # endregion
 
     # region Compound-type
 
+    # A value n is taken from top of main stack. The next n*2 items on main stack are removed, put inside n-sized map
+    # and this map is put on top of the main stack.
+    PACKMAP = OpcodeInformation(Opcode.PACKMAP)
+    # A value n is taken from top of main stack. The next n items on main stack are removed, put inside n-sized
+    # struct and this struct is put on top of the main stack.
+    PACKSTRUCT = OpcodeInformation(Opcode.PACKSTRUCT)
     # A value n is taken from top of main stack. The next n items on main stack are removed, put inside n-sized array
     # and this array is put on top of the main stack.
     PACK = OpcodeInformation(Opcode.PACK)
-    # An array is removed from top of the main stack. Its elements are put on top of the main stack (in reverse
-    # order) and the array size is also put on main stack.
+    # A collection is removed from top of the main stack. Its elements are put on top of the main stack (in reverse
+    # order) and the collection size is also put on main stack.
     UNPACK = OpcodeInformation(Opcode.UNPACK)
     # An empty array (with size 0) is put on top of the main stack.
     NEWARRAY0 = OpcodeInformation(Opcode.NEWARRAY0)
     # A value n is taken from top of main stack. A null-filled array with size n is put on top of the main stack.
     NEWARRAY = OpcodeInformation(Opcode.NEWARRAY)
     # A value n is taken from top of main stack. An array of type T with size n is put on top of the main stack.
     NEWARRAY_T = OpcodeInformation(Opcode.NEWARRAY_T, 1)
```

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/opcode/OpcodeInformation.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/opcode/OpcodeInformation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from __future__ import annotations
 
 from typing import Optional
 
-from boa3.neo.vm.opcode.Opcode import Opcode
+from boa3.internal.neo.vm.opcode.Opcode import Opcode
 
 
 class OpcodeInformation:
     """
     Stores the information about a specific :class:`Opcode`
 
     :ivar opcode: the opcode of the code
@@ -30,9 +30,9 @@
         self.stack_items: int = stack_items
 
     def get_large(self) -> Optional[OpcodeInformation]:
         large_op = self.opcode.get_large
         if large_op is None:
             return None
 
-        from boa3.neo.vm.opcode.OpcodeInfo import OpcodeInfo
+        from boa3.internal.neo.vm.opcode.OpcodeInfo import OpcodeInfo
         return OpcodeInfo.get_info(large_op)
```

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/type/ContractParameterType.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/type/ContractParameterType.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/type/Integer.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/type/Integer.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-from boa3.constants import BYTEORDER
+from boa3.internal.constants import BYTEORDER
 
 
 class Integer(int):
     def to_byte_array(self, signed: bool = False, min_length: int = 0) -> bytes:
         """
         Converts an integer value to a immutable byte array
```

### Comparing `neo3-boa-0.9.0/boa3/neo/vm/type/StackItem.py` & `neo3-boa-1.0.0/boa3/internal/neo/vm/type/StackItem.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,40 +1,63 @@
 from __future__ import annotations
 
 from enum import Enum
-from typing import Any
+from typing import Any, List
 
-from boa3.neo.vm.type.Integer import Integer
-from boa3.neo.vm.type.String import String
+from boa3.internal.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.type.String import String
 
 
 class StackItemType(bytes, Enum):
     Any = b'\x00'
     Pointer = b'\x10'
     Boolean = b'\x20'
     Integer = b'\x21'
     ByteString = b'\x28'
     Buffer = b'\x30'
     Array = b'\x40'
     Struct = b'\x41'
     Map = b'\x48'
     InteropInterface = b'\x60'
 
-    @classmethod
-    def get_stack_item_type(cls, stack_item_type: str) -> StackItemType:
+    @staticmethod
+    def get_stack_item_type(stack_item_type: str) -> StackItemType:
         try:
             return StackItemType[stack_item_type]
         except BaseException:
             return StackItemType.Any
 
+    @staticmethod
+    def union(stack_item_types: List[StackItemType]) -> StackItemType:
+        if len(stack_item_types) == 0:
+            return StackItemType.Any
+
+        if len(stack_item_types) == 1:
+            return stack_item_types[0]
+
+        stacks = stack_item_types[:1]
+        for union in stack_item_types[1:]:
+            if union not in stacks:
+                stacks.append(union)
+
+        if len(stacks) == 1:
+            return stacks[0]
+        else:
+            return StackItemType.Any
+
 
 def serialize(value: Any) -> bytes:
     if value is None:
         return StackItemType.Any
 
+    if isinstance(value, bool):
+        stack_type = StackItemType.Boolean
+        span = Integer(value).to_byte_array(signed=False, min_length=1)
+        return stack_type + span
+
     if isinstance(value, (int, str, bytes)):
         if isinstance(value, int):
             stack_type = StackItemType.Integer
             span = Integer(value).to_byte_array(signed=True, min_length=1)
         elif isinstance(value, str):
             stack_type = StackItemType.ByteString
             span = String(value).to_bytes()
```

### Comparing `neo3-boa-0.9.0/boa3/neo3/contracts/contracttypes.py` & `neo3-boa-1.0.0/boa3/internal/neo3/contracts/contracttypes.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,14 +1,17 @@
 from enum import IntFlag
 
 
 class TriggerType(IntFlag):
     """
     Represents the triggers for running smart contracts. Triggers enable the contract to execute different logic under
     different usage scenarios.
+
+    Check out `Neo's Documentation <https://developers.neo.org/docs/n3/reference/scapi/framework/services/TriggerType>`__
+    to learn more about TriggerTypes.
     """
 
     ON_PERSIST = 0x01
     """
     Indicate that the contract is triggered by the system to execute the OnPersist method of the native contracts.
 
     :meta hide-value:
@@ -50,14 +53,17 @@
     """
 
 
 class CallFlags(IntFlag):
     """
     Defines special behaviors allowed when invoking smart contracts, e.g., chain calls, sending notifications and
     modifying states.
+
+    Check out `Neo's Documentation <https://developers.neo.org/docs/n3/reference/scapi/framework/services/CallFlags>`__
+    to learn more about CallFlags.
     """
 
     NONE = 0
     """
     Special behaviors of the invoked contract are not allowed, such as chain calls, sending notifications, modifying 
     state, etc.
```

### Comparing `neo3-boa-0.9.0/boa3/neo3/contracts/native/nativetypes.py` & `neo3-boa-1.0.0/boa3/internal/neo3/contracts/native/nativetypes.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3/neo3/contracts/nef.py` & `neo3-boa-1.0.0/boa3/internal/neo3/contracts/nef.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 from __future__ import annotations
 
 import hashlib
-from typing import Tuple
+from typing import List, Tuple
 
-from boa3.neo3.core import Size as s, serialization, types, utils
+from boa3.internal.neo3 import contracts
+from boa3.internal.neo3.core import Size as s, serialization, types, utils
 
 
 class Version(serialization.ISerializable):
     """
     Represents the version number of an assembly
     """
 
@@ -37,30 +38,37 @@
                 and self.minor == other.minor
                 and self.build == other.build
                 and self.revision == other.revision)
 
     def __len__(self):
         return s.uint64 + s.uint64 + s.uint64 + s.uint64
 
+    def __str__(self):
+        return "{0}.{1}.{2}.{3}".format(self.major,
+                                        self.minor,
+                                        self.build,
+                                        self.revision)
+
     def serialize(self, writer: serialization.BinaryWriter) -> None:
-        version_str = "{0}.{1}.{2}.{3}".format(self.major,
-                                               self.minor,
-                                               self.build,
-                                               self.revision)
-        from boa3.neo.vm.type.String import String
+        version_str = str(self)
+        from boa3.internal.neo.vm.type.String import String
         version_bytes = String(version_str).to_bytes() + bytes(s.uint64 * 4 - len(version_str))
         writer.write_bytes(version_bytes)
 
     def deserialize(self, reader: serialization.BinaryReader) -> None:
         version_str = reader.read_bytes(s.uint64 * 4).decode('utf-8')
 
         import re
         version_str = re.sub(r'\x00+', '', version_str)
 
-        major, minor, build, revision = version_str.split('.')
+        version_split = version_str.split('.')
+        while len(version_split) < 4:
+            version_split.append('0')
+
+        major, minor, build, revision = version_split
         self.major = int(major)
         self.minor = int(minor)
         self.build = int(build)
         self.revision = int(revision)
 
     @classmethod
     def _parse_component(self, c: str) -> Tuple[bool, int]:
@@ -110,93 +118,131 @@
                 raise ValueError(f"Cannot parse revision field from: {parts[3]}")
         else:
             revision = 0
         return cls(major, minor, build, revision)
 
 
 class NEF(serialization.ISerializable):
-    def __init__(self, compiler_name: str = None, version: Version = None, script: bytes = None):
-        self.magic = 0x3346454E
+    def __init__(self,
+                 compiler_name: str = None,
+                 script: bytes = None,
+                 tokens: List[MethodToken] = None,
+                 source: str = None,
+                 _magic: int = 0x3346454E):
+        self.magic = _magic
         if compiler_name is None:
             self.compiler = 'unknown'
         else:
-            self.compiler = compiler_name[:32]
-        self.version = version if version else Version()
+            self.compiler = compiler_name[:64]
+        self.source = source if source else ""
         self.script = script if script else b''
-        self.checksum = self.compute_checksum()
+        self._checksum = 0
+        self.tokens = [] if tokens is None else tokens
+        # this is intentional, because NEO computes the initial checksum by serializing itself while checksum is 0
+        self._checksum = self.compute_checksum()
 
     def __len__(self):
         return (
             s.uint32  # magic
-            + 32  # compiler
-            + (s.uint64 * 4)  # version
-            + 2   # reserve
-            + utils.get_var_size(bytes())   # TODO: method tokens
-            + 2   # reserve
+            + 64  # compiler
+            + utils.get_var_size(self.source)
+            + 1  # reserved
+            + utils.get_var_size(self.tokens)
+            + 2  # reserved
+            + s.uint32  # checksum
             + utils.get_var_size(self.script)
-            + s.uint32)  # checksum
+        )
 
     def __eq__(self, other):
         if not isinstance(other, type(self)):
             return False
         return (self.magic == other.magic
                 and self.compiler == other.compiler
-                and self.version == other.version
+                and self.source == other.source
                 and self.script == other.script
-                and self.checksum == other.checksum)
+                and self.tokens == other.tokens
+                and self.checksum == other.checksum
+                )
 
     @property
-    def compiler_with_version(self) -> bytes:
-        result = '{0}-'.format(self.compiler).encode('utf-8') + self.version.to_array()
-        return result[:64] + bytes(64 - len(result))
+    def checksum(self) -> int:
+        if self._checksum == 0:
+            self._checksum = self.compute_checksum()
+        return self._checksum
 
     def serialize(self, writer: serialization.BinaryWriter) -> None:
         writer.write_uint32(self.magic)
-        writer.write_bytes(self.compiler_with_version)
-
-        writer.write_uint16(0)    # 2 reserved bytes
-        writer.write_var_bytes(bytes())   # TODO: method tokens
-        writer.write_uint16(0)    # 2 reserved bytes
-
+        writer.write_bytes(self.compiler.encode('utf-8').ljust(64, b'\x00'))
+        writer.write_var_string(self.source)
+        writer.write_bytes(b'\x00')
+        writer.write_serializable_list(self.tokens)
+        writer.write_bytes(b'\x00\x00')
         writer.write_var_bytes(self.script)
-        writer.write_bytes(self.checksum)
+        writer.write_uint32(self._checksum)
 
     def deserialize(self, reader: serialization.BinaryReader) -> None:
-        self.magic = reader.read_uint32()
-        compiler_with_version = reader.read_bytes(64).decode('utf-8')
-        self.compiler, version = compiler_with_version.rsplit('-', maxsplit=1)
-        self.version = Version.deserialize_from_bytes(version[:32].encode('utf-8'))
-
-        assert reader.read_uint16() == 0    # 2 reserved bytes
-        reader.read_var_int(128)            # TODO: method tokens
-        assert reader.read_uint16() == 0    # 2 reserved bytes
-
-        self.script = reader.read_var_bytes()
-        self.checksum = reader.read_bytes(4)
-        if self.checksum != self.compute_checksum():
-            raise ValueError("Deserialization error - invalid checksum")
-
-    def script_to_array(self):
-        from boa3.neo3.core.serialization import BinaryWriter
-        with BinaryWriter() as bw:
-            bw.write_var_bytes(self.script)
-            return bw._stream.getvalue()
-
-    def tokens_to_array(self):
-        from boa3.neo3.core.serialization import BinaryWriter
-        with BinaryWriter() as bw:
-            bw.write_var_bytes(bytes())
-            return bw._stream.getvalue()
-
-    def compute_checksum(self) -> bytes:
-        data = (self.magic.to_bytes(4, 'little')
-                + self.compiler_with_version
-                + bytes(2)  # reserved bytes
-                + self.tokens_to_array()   # TODO: method tokens
-                + bytes(2)  # reserved bytes
-                + self.script_to_array())
-
-        return hashlib.sha256(hashlib.sha256(data).digest()).digest()[:s.uint32]
-
-    def compute_script_hash(self) -> types.UInt160:
-        hash = hashlib.new('ripemd160', hashlib.sha256(self.script).digest()).digest()
-        return types.UInt160(data=hash)
+        if reader.read_uint32() != self.magic:
+            raise ValueError("Deserialization error - Incorrect magic")
+        self.compiler = reader.read_bytes(64).decode('utf-8').rstrip(b'\x00'.decode())
+        self.source = reader.read_var_string(256)
+        if reader.read_uint8() != 0:
+            raise ValueError("Reserved bytes must be 0")
+        self.tokens = reader.read_serializable_list(MethodToken)
+        if reader.read_uint16() != 0:
+            raise ValueError("Reserved bytes must be 0")
+
+        self.script = reader.read_var_bytes(max=512 * 1024)
+        if len(self.script) == 0:
+            raise ValueError("Deserialization error - Script can't be empty")
+
+        checksum = int.from_bytes(reader.read_bytes(4), 'little')
+        if checksum != self.compute_checksum():
+            raise ValueError("Deserialization error - Invalid checksum")
+        else:
+            self._checksum = checksum
+
+    def compute_checksum(self) -> int:
+        return int.from_bytes(
+            hashlib.sha256(hashlib.sha256(self.to_array()[:-4]).digest()).digest()[:s.uint32],
+            'little'
+        )
+
+    @classmethod
+    def _serializable_init(cls):
+        c = cls()
+        c._checksum = 0
+        return c
+
+
+class MethodToken(serialization.ISerializable):
+    def __init__(self,
+                 hash: types.UInt160,
+                 method: str,
+                 parameters_count: int,
+                 has_return_value: bool,
+                 call_flags: contracts.CallFlags):
+        self.hash = hash
+        self.method = method
+        self.parameters_count = parameters_count
+        self.has_return_value = has_return_value
+        self.call_flags = call_flags
+
+    def __len__(self):
+        return s.uint160 + utils.get_var_size(self.method) + s.uint16 + s.uint8 + s.uint8
+
+    def serialize(self, writer: serialization.BinaryWriter):
+        writer.write_serializable(self.hash)
+        writer.write_var_string(self.method)
+        writer.write_uint16(self.parameters_count)
+        writer.write_uint8(self.has_return_value)
+        writer.write_uint8(self.call_flags.value)
+
+    def deserialize(self, reader: serialization.BinaryReader):
+        self.hash = reader.read_serializable(types.UInt160)
+        self.method = reader.read_var_string(32)
+        self.parameters_count = reader.read_uint16()
+        self.has_return_value = bool(reader.read_uint8())
+        self.call_flags = contracts.CallFlags(reader.read_uint8())
+
+    @classmethod
+    def _serializable_init(cls):
+        return cls(types.UInt160.zero(), "", 0, False, contracts.CallFlags.NONE)
```

### Comparing `neo3-boa-0.9.0/boa3/neo3/core/serialization.py` & `neo3-boa-1.0.0/boa3/internal/neo3/core/serialization.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 __all__ = ['ISerializable', 'BinaryReader', 'BinaryWriter']
 
 
 class ISerializable(abc.ABC):
     """
     An interface like class supporting NEO's network serialization protocol.
     """
+
     @abc.abstractmethod
     def serialize(self, writer: BinaryWriter) -> None:
         """
         Serialize the object into a binary stream.
 
         Args:
             writer: instance.
@@ -284,16 +285,14 @@
         length = self.read_var_int(max)
         return self.read_bytes(length, _skip_length_check=True)
 
     def read_bytes_with_grouping(self, group_size) -> bytes:
         """
         Read bytes from the stream that were stored using the special grouping format.
 
-        TODO: add documentation explaining grouping
-
         See also: :func:`~neo3.core.serialization.BinaryWriter.write_bytes_with_grouping`
 
         Args:
             group_size: size to group data bytes in. Value must be < 254. Common value is 16.
 
         Returns:
             bytes with the grouping format removed.
@@ -348,19 +347,19 @@
     def read_serializable(self, obj_type: Type[ISerializable_T]) -> ISerializable_T:
         """
         Read and deserialize an object of `obj_type` from the stream.
 
         Args:
             obj_type: the object class to deserialize into.
         """
-        obj = obj_type()
+        obj = obj_type._serializable_init()
         obj.deserialize(self)
         return obj
 
-    def read_serializable_list(self, obj_type: Type[ISerializable_T], max: int = None) -> List[ISerializable_T]:
+    def read_serializable_list(self, obj_type: Type[ISerializable_T], max: int = None) -> list[ISerializable_T]:
         """
         Read and deserialize a list of objects of `obj_type` from the stream.
 
         Expects to start with a `varint` list length indicator.
 
         Args:
             obj_type: the object class to deserialize into.
@@ -370,18 +369,21 @@
             list[ISerializable]: list of deserialized objects.
         """
         obj_array = []
         count = self.read_var_int()
         if max and count > max:
             count = max
 
-        for _ in range(count):
-            obj = obj_type()
-            obj.deserialize(self)
-            obj_array.append(obj)
+        try:
+            for _ in range(count):
+                obj = obj_type._serializable_init()
+                obj.deserialize(self)
+                obj_array.append(obj)
+        except Exception as e:
+            raise ValueError(f"Insufficient data - {str(e)}")
         return obj_array
 
     def close(self) -> None:
         """
         Close the internal stream to prevent resource leaking.
 
         Note:
@@ -429,14 +431,23 @@
         io.seek(0, SEEK_END)
         # Remember position, which is equal to the full length
         full_size = io.tell()
         # Seek back to the current position
         io.seek(cur_pos)
         return full_size
 
+    @classmethod
+    def _serializable_init(cls):
+        """
+        If the interface inheritor has mandatory arguments, override this functin and provide dummy values. These values
+        will be overwritten by the read_serializable, read_serializable_list and deserialize_from_bytes methods that
+        rely on this function for class instantiation.
+        """
+        return cls()
+
     def write_bytes(self, value: bytes) -> int:
         """
         Write a `bytes` type to the stream.
 
         Args:
             value: array of bytes to write to the stream.
 
@@ -648,15 +659,14 @@
     def write_bytes_with_grouping(self, value: bytes, group_size) -> None:
         """
         Write bytes into a stream with a special grouping format.
 
         Note:
             This is a helper function specifically made to help serialize keys to be stored in the backend that must
             be prefix searchable via `DataCache.Find`.
-            TODO: write small page explaining the problem of varint usage
 
         Args:
             value: bytes to write to the stream.
             group_size: size to group data bytes in. Value must be < 254. Common value is 16.
         """
         if group_size <= 0 or group_size >= 255:
             raise ValueError("group_size must be > 0 and <= 254")
```

### Comparing `neo3-boa-0.9.0/boa3/neo3/core/types/biginteger.py` & `neo3-boa-1.0.0/boa3/internal/neo3/core/types/biginteger.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3/neo3/core/types/uint.py` & `neo3-boa-1.0.0/boa3/internal/neo3/core/types/uint.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from __future__ import annotations
 
 import binascii
 from typing import Type, Union
 
-from boa3.neo import to_hex_str
-from boa3.neo3.core import serialization
+from boa3.internal.neo import to_hex_str
+from boa3.internal.neo3.core import serialization
 
 __all__ = ['UInt160', 'UInt256']
 
 
 class _UIntBase(serialization.ISerializable):
     def __init__(self, num_bytes: int, data: Union[bytes, bytearray] = None) -> None:
         """
@@ -113,14 +113,18 @@
         """
         Return an array of bytes representing the UInt
 
         Returns:
         """
         return bytes(self._data)
 
+    @classmethod
+    def _serializable_init(cls):
+        return cls(b'\x00' * cls._BYTE_LEN)
+
 
 class UInt160(_UIntBase):
     _BYTE_LEN = 20
 
     def __init__(self, data: bytes = None):
         """
         Initialize an instance.
@@ -156,14 +160,16 @@
 
         Args:
             value: accepts the same input as :py:meth:`bytearray.fromhex`.
 
         Raises:
             ValueError: if the length of the supplied string does not match.
         """
+        if isinstance(value, str) and value.startswith('0x'):
+            value = value[2:]
         if len(value) != cls._BYTE_LEN * 2:
             raise ValueError(f"Invalid {cls.__name__} Format: {len(value)} chars != {cls._BYTE_LEN * 2} chars")
         reversed_data = bytearray.fromhex(value)
         reversed_data.reverse()
         return cls(data=reversed_data)
 
     @classmethod
@@ -231,14 +237,16 @@
 
         Args:
             value: accepts the same input as :py:meth:`bytearray.fromhex`.
 
         Raises:
             ValueError: if the length of the supplied string does not match.
         """
+        if isinstance(value, str) and value.startswith('0x'):
+            value = value[2:]
         if len(value) != cls._BYTE_LEN * 2:
             raise ValueError(f"Invalid {cls.__name__} Format: {len(value)} chars != {cls._BYTE_LEN * 2} chars")
         reversed_data = bytearray.fromhex(value)
         reversed_data.reverse()
         return cls(data=reversed_data)
 
     @classmethod
```

### Comparing `neo3-boa-0.9.0/boa3/neo3/core/utils.py` & `neo3-boa-1.0.0/boa3/internal/neo3/core/utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # type: ignore
 
-from collections import Iterable
 from enum import Enum
+from typing import Iterable
 
-from boa3.neo3.core import Size, serialization
+from boa3.internal.neo3.core import Size, serialization
 
 
 def get_var_size(value: object) -> int:
     """
     Determine the variable size of an object.
 
     Note:
```

### Comparing `neo3-boa-0.9.0/boa3/neo3/network/payloads/oracleresponsecode.py` & `neo3-boa-1.0.0/boa3/internal/neo3/network/payloads/oracleresponsecode.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/binaryserializer/__init__.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/binaryserializer/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from typing import Any
 
-from boa3.neo.vm.type.Integer import Integer
-from boa3.neo.vm.type.StackItem import StackItemType
-from boa3.neo3.core.serialization import BinaryReader
+from boa3.internal.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.type.StackItem import StackItemType
+from boa3.internal.neo3.core.serialization import BinaryReader
 
 
 def deserialize_binary(reader: BinaryReader) -> Any:
     deserialized_items = []
     underserialized = 1
 
     while underserialized > 0:
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/block.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/block.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,32 +1,24 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional
 
-from boa3.neo import from_hex_str
-from boa3.neo3.core.types import UInt256
+from boa3_test.test_drive.model.network.payloads.testblock import TestBlock
 from boa3_test.tests.test_classes.transaction import Transaction
 
 
-class Block:
+class Block(TestBlock):
     def __init__(self, index: int):
+        self._transactions: List[Transaction] = []
+        super().__init__()
+
         import time
-        self._index: int = index
         # time() returns timestamp in nanoseconds and Neo uses timestamp in milliseconds
         self._timestamp: int = int(time.time_ns() / 1_000_000)
-        self._hash: Optional[UInt256] = None
-        self._transactions: List[Transaction] = []
-
-    @property
-    def index(self) -> int:
-        return self._index
-
-    @property
-    def timestamp(self) -> int:
-        return self._timestamp
+        self._index: int = index
 
     def get_transactions(self) -> List[Transaction]:
         """
         Gets a list of the block transactions. Changes in those transactions don't affect the ones inside the block.
 
         :return: the block transactions
         :rtype: List[Transaction]
@@ -41,29 +33,23 @@
     def hash(self) -> Optional[bytes]:
         if self._hash is None:
             return None
         else:
             return self._hash.to_array()
 
     def to_json(self) -> Dict[str, Any]:
-        return {
-            'index': self._index,
-            'timestamp': self._timestamp,
-            'transactions': [tx.to_json() for tx in self._transactions]
-        }
+        json_block = super().to_json()
+
+        if self._hash is not None:
+            json_block['hash'] = str(self._hash)
+
+        return json_block
 
     @classmethod
     def from_json(cls, json: Dict[str, Any]) -> Block:
+        block: Block = super().from_json(json)
+
         # 'index' and 'timestamp' fields are required
-        block = cls(int(json['index']))
+        block._index = int(json['index'])
         block._timestamp = int(json['timestamp'])
 
-        if 'transactions' in json:
-            tx_json = json['transactions']
-            if not isinstance(tx_json, list):
-                tx_json = [tx_json]
-            block._transactions = [Transaction.from_json(js) for js in tx_json]
-
-        if 'hash' in json and isinstance(json['hash'], str):
-            block._hash = UInt256(from_hex_str(json['hash']))
-
         return block
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neoabistruct.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neoabistruct.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neoeventstruct.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neoeventstruct.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 
 from typing import Any, Dict
 
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
 class NeoEventStruct(NeoStruct):
-
     _name_field = 'name'
     _parameters_field = 'parameters'
 
     @classmethod
     def from_json(cls, json: Dict[str, Any]) -> NeoEventStruct:
         required_fields = [cls._name_field,
                            cls._parameters_field
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neomanifeststruct.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neomanifeststruct.py`

 * *Files 14% similar despite different names*

```diff
@@ -28,17 +28,17 @@
                            cls._features_field,
                            cls._extra_field
                            ]
         cls._validate_json(json, required_fields)
 
         struct = cls()
         struct.append(json[cls._name_field])
-        struct.append(json[cls._groups_field])  # TODO: groups aren't implemented yet
-        struct.append({})   # TODO: features aren't implemented yet
-        struct.append(json[cls._supported_standards_field])  # TODO: supported standards aren't implemented
+        struct.append(json[cls._groups_field])
+        struct.append({})  # TODO: features aren't implemented yet
+        struct.append(json[cls._supported_standards_field])
         struct.append(NeoAbiStruct.from_json(json[cls._abi_field]))
         struct.append([NeoPermissionsStruct.from_json(permission) for permission in json[cls._permissions_field]])
-        struct.append(json[cls._trusts_field])  # TODO: trusts aren't implemented
+        struct.append(json[cls._trusts_field])
         extras = json[cls._extra_field]
         struct.append(extras if extras is not None else "null")
 
         return struct
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neomethodstruct.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neomethodstruct.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 from __future__ import annotations
 
 from typing import Any, Dict
 
-from boa3.neo.vm.type.ContractParameterType import ContractParameterType
+from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
 class NeoMethodStruct(NeoStruct):
-
     _name_field = 'name'
     _parameters_field = 'parameters'
     _return_type_field = 'returntype'
     _offset_field = 'offset'
     _is_safe_field = 'safe'
 
     @classmethod
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neopermissionsstruct.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neopermissionsstruct.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 from __future__ import annotations
 
-from typing import Any, Dict, Optional
+from typing import Any, Dict, Optional, Union
 
-from boa3.neo3.core.types import UInt160
+from boa3.internal.neo3.core.types import UInt160
 from boa3_test.tests.test_classes.contract.neostruct import NeoStruct
 
 
 class NeoPermissionsStruct(NeoStruct):
-
     _contract_fields = 'contract'
     _methods_fields = 'methods'
 
     @classmethod
     def from_json(cls, json: Dict[str, Any]) -> NeoPermissionsStruct:
         required_fields = [cls._contract_fields,
                            cls._methods_fields
@@ -23,24 +22,25 @@
         struct.append(cls.get_methods(json[cls._methods_fields]))
         return struct
 
     @classmethod
     def _is_wildcard(cls, value: Any) -> bool:
         if value is None:
             return True
-        return value is '*'
+        return value == '*'
 
     @classmethod
-    def get_contract(cls, value: Any) -> Optional[UInt160]:
+    def get_contract(cls, value: Any) -> Optional[Union[UInt160, bytes]]:
         if cls._is_wildcard(value):
             return None
 
-        # TODO: Permissions are not implemented yet
-        return UInt160()
+        if isinstance(value, str):
+            if len(value) == 40 or len(value) == 42:
+                return UInt160.from_string(value)
+            return bytes.fromhex(value)
 
     @classmethod
     def get_methods(cls, value: Any) -> Optional[list]:
         if cls._is_wildcard(value):
             return None
-
-        # TODO: Permissions are not implemented yet
-        return []
+        else:
+            return [method for method in value]
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/contract/neostruct.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/contract/neostruct.py`

 * *Files 1% similar despite different names*

```diff
@@ -22,14 +22,14 @@
         _name = 'name'
         _type = 'type'
 
         required_fields = [_name, _type]
         cls._validate_json(json, required_fields)
 
         name = json[_name]
-        from boa3.neo.vm.type.ContractParameterType import ContractParameterType
+        from boa3.internal.neo.vm.type.ContractParameterType import ContractParameterType
         try:
             param_type = ContractParameterType._get_by_name(json[_type])
         except BaseException:
             param_type = None
 
         return [name, param_type]
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/nativeaccountstate.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/nativeaccountstate.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from typing import Any
 
-from boa3.neo.vm.type import StackItem
-from boa3.neo.vm.type.StackItem import StackItemType
+from boa3.internal.neo.vm.type import StackItem
+from boa3.internal.neo.vm.type.StackItem import StackItemType
 
 
 class NativeAccountState:
     def __init__(self, balance: int):
         self.balance: int = balance if balance > 0 else 0
         self._balance_height: int = 0
         self._vote_to: Any = None
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/nativecontractprefix.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/nativecontractprefix.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from enum import IntEnum
 from typing import Optional, Tuple
 
-from boa3 import constants
-from boa3.neo.vm.type.Integer import Integer
+from boa3.internal import constants
+from boa3.internal.neo.vm.type.Integer import Integer
 
 
 def get_native_contract_data(token_script: bytes) -> Tuple[Optional[bytes], Optional[int]]:
     prefix: Optional[NativeContractPrefix] = None
     contract_id: NativeContractId = NativeContractId.NONE
 
     if token_script is constants.NEO_SCRIPT:
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/storage.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/storage.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,29 +1,37 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Union
 
-from boa3.neo.utils import contract_parameter_to_json, stack_item_from_json
-from boa3.neo.vm.type.Integer import Integer
-from boa3.neo.vm.type.String import String
-from boa3.neo3.core.serialization import BinaryReader
+from boa3.internal import constants
+from boa3.internal.neo.utils import contract_parameter_to_json, stack_item_from_json
+from boa3.internal.neo.vm.type.Integer import Integer
+from boa3.internal.neo.vm.type.String import String
+from boa3.internal.neo3.core.serialization import BinaryReader
 from boa3_test.tests.test_classes.nativecontractprefix import get_native_contract_data
 
 
 class Storage:
     def __init__(self):
         self._dict: Dict[StorageKey, StorageItem] = {}
 
     def pop(self, key: bytes) -> StorageItem:
         storage_key = StorageKey(key)
         return self._dict.pop(storage_key)
 
-    def clear(self):
+    def clear(self, delete_deploy_data: bool = True):
+        prefix, native_id = get_native_contract_data(constants.MANAGEMENT_SCRIPT)
         for key in list(self._dict.keys()):
-            if key._ID > 0:
+            should_delete = (key._ID > 0  # it's a deployd contract
+                             or (delete_deploy_data
+                                 and key._ID == native_id
+                                 and key._key.startswith(prefix)  # it's a deployed contract register
+                                 )
+                             )
+            if should_delete:
                 # keep native contracts storage
                 self._dict.pop(key)
 
     def copy(self) -> Storage:
         storage = Storage()
         storage._dict = self._dict.copy()
         return storage
@@ -69,24 +77,22 @@
         from boa3_test.tests.test_classes.nativeaccountstate import NativeAccountState
         key = StorageKey(balance_key)
         key._ID = token_id
         self._dict[key] = StorageItem(NativeAccountState(balance).serialize())
         return True
 
     def has_contract(self, script_hash: bytes) -> bool:
-        from boa3 import constants
         prefix, native_id = get_native_contract_data(constants.MANAGEMENT_SCRIPT)
         if prefix is None or native_id is None:
             return False
 
         storage_key = self.build_key(prefix + script_hash, native_id)
         return storage_key in self
 
     def get_contract_id(self, script_hash: bytes) -> int:
-        from boa3 import constants
         prefix, native_id = get_native_contract_data(constants.MANAGEMENT_SCRIPT)
         if prefix is None or native_id is None:
             return False
 
         storage_key = self.build_key(prefix + script_hash, native_id)
         if storage_key in self:
             result = self[storage_key]
@@ -101,15 +107,15 @@
     def __contains__(self, item: StorageKey) -> bool:
         return item in self._dict
 
     def __getitem__(self, item: StorageKey) -> Any:
         return self._dict[item].value
 
     def __setitem__(self, key: StorageKey, value: Any):
-        from boa3.neo.vm.type import StackItem
+        from boa3.internal.neo.vm.type import StackItem
         if isinstance(value, int):
             storage_value = Integer(value).to_byte_array()
         elif isinstance(value, str):
             storage_value = String(value).to_bytes()
         else:
             storage_value = StackItem.serialize(value)
         self._dict[key] = StorageItem(storage_value)
@@ -129,15 +135,15 @@
                 'key': contract_parameter_to_json(self._key)
                 }
 
     @classmethod
     def from_json(cls, json: Dict[str, Any]) -> StorageKey:
         k = stack_item_from_json(json['key'])
         if isinstance(k, str):
-            from boa3.neo.vm.type.String import String
+            from boa3.internal.neo.vm.type.String import String
             k = String(k).to_bytes()
 
         key = StorageKey(k)
         key._ID = json['id']
         return key
 
     def __eq__(self, other) -> bool:
@@ -164,15 +170,15 @@
                 'value': contract_parameter_to_json(self._value)
                 }
 
     @classmethod
     def from_json(cls, json: Dict[str, Any]) -> StorageItem:
         value = stack_item_from_json(json['value'])
         if isinstance(value, str):
-            from boa3.neo.vm.type.String import String
+            from boa3.internal.neo.vm.type.String import String
             value = String(value).to_bytes()
 
         item = StorageItem(value, json['isconstant'])
         return item
 
     def __str__(self) -> str:
         return self._value.__str__()
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/testengine.py` & `neo3-boa-1.0.0/boa3_test/test_drive/testrunner/neo_test_runner.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,361 +1,461 @@
-from os import path
-from typing import Any, Dict, List, Optional, Tuple, Union
+import json
+import os.path
+import subprocess
+import threading
+from typing import Any, List, Tuple, Dict, Optional, Union, Type
+
+from boa3.internal import env, constants
+from boa3.internal.neo import utils as neo_utils
+from boa3.internal.neo.vm.type.String import String
+from boa3.internal.neo3.core.types import UInt256
+from boa3.internal.neo3.vm import vmstate, VMState
+from boa3_test.test_drive.model.invoker.neobatchinvoke import NeoBatchInvoke
+from boa3_test.test_drive.model.invoker.neoinvokecollection import NeoInvokeCollection
+from boa3_test.test_drive.model.invoker.neoinvokeresult import NeoInvokeResult
+from boa3_test.test_drive.model.network.payloads.witnessscope import WitnessScope
+from boa3_test.test_drive.model.smart_contract.contractcollection import ContractCollection
+from boa3_test.test_drive.model.smart_contract.testcontract import TestContract
+from boa3_test.test_drive.model.wallet.account import Account
+from boa3_test.test_drive.neoxp import utils as neoxp_utils
+from boa3_test.test_drive.neoxp.batch import NeoExpressBatch
+from boa3_test.test_drive.testrunner import utils
+from boa3_test.test_drive.testrunner.blockchain.block import TestRunnerBlock as Block
+from boa3_test.test_drive.testrunner.blockchain.log import TestRunnerLog as Log
+from boa3_test.test_drive.testrunner.blockchain.notification import TestRunnerNotification as Notification
+from boa3_test.test_drive.testrunner.blockchain.storage import TestRunnerStorage as Storage
+from boa3_test.test_drive.testrunner.blockchain.storagecollection import StorageCollection
+from boa3_test.test_drive.testrunner.blockchain.transaction import TestRunnerTransaction as Transaction
+from boa3_test.test_drive.testrunner.blockchain.transactionlog import TestRunnerTransactionLog as TransactionLog
+
+
+class NeoTestRunner:
+    _FOLDER_NAME = 'test-runner'
+    _ROOT_FOLDER = os.path.abspath(os.path.curdir) + os.path.sep + _FOLDER_NAME
+    _INVOKE_FILE = f'{_FOLDER_NAME}.neo-invoke.json'
+    _BATCH_FILE = f'{_FOLDER_NAME}.batch'
+    _CHECKPOINT_FILE = f'{_FOLDER_NAME}.neoxp-checkpoint'
 
-from boa3 import constants
-from boa3.neo import to_hex_str
-from boa3.neo.smart_contract.VoidType import VoidType
-from boa3.neo.smart_contract.notification import Notification
-from boa3.neo.utils import contract_parameter_to_json, stack_item_from_json
-from boa3.neo.vm.type.String import String
-from boa3.neo3.core.types import UInt160
-from boa3.neo3.vm import VMState
-from boa3_test.tests.test_classes.block import Block
-from boa3_test.tests.test_classes.storage import Storage
-from boa3_test.tests.test_classes.testcontract import TestContract
-from boa3_test.tests.test_classes.transaction import Transaction
-from boa3_test.tests.test_classes.transactionattribute import oracleresponse
-
-
-class TestEngine:
-    def __init__(self, root_path: Optional[str] = None):
-        if root_path is None:
-            from boa3 import env
-            root_path = env.TEST_ENGINE_DIRECTORY
-
-        engine_path = '{0}/Neo.TestEngine.dll'.format(root_path)
-        if not path.exists(engine_path):
-            raise FileNotFoundError(
-                "File at {0} was not found.\n"
-                "Visit the docs or the README file and search for 'TestEngine' to correctly install it."
-                .format(engine_path))
+    _DEFAULT_ACCOUNT = neoxp_utils.get_default_account()
 
-        self._test_engine_path = engine_path
+    def __init__(self, neoxp_path: str = None, runner_id: str = None):
         self._vm_state: VMState = VMState.NONE
         self._gas_consumed: int = 0
         self._result_stack: List[Any] = []
+        self._error_message: Optional[str] = None
+        self._last_cli_log: Optional[str] = None
+        self._cli_log: str = ''
 
-        self._storage: Storage = Storage()
+        self._calling_account: Optional[Account] = None
         self._notifications: List[Notification] = []
-        self._height: int = 0
-        self._blocks: List[Block] = []
+        self._logs: List[Log] = []
+        self._storages: StorageCollection = StorageCollection()
+
+        if not isinstance(neoxp_path, str):
+            neoxp_path = f'{env.NEO_EXPRESS_INSTANCE_DIRECTORY}{os.path.sep}default.neo-express'
+        self._neoxp_abs_path = os.path.abspath(neoxp_path)
+
+        if isinstance(runner_id, str):
+            self._file_name: str = None  # defined in the following line
+            self.file_name = self._FOLDER_NAME if not runner_id else runner_id
+        else:
+            self._file_name = self._FOLDER_NAME
 
-        self._current_tx: Optional[Transaction] = None
-        self._accounts: List[bytes] = []
-        self._contract_paths: List[TestContract] = []
+        self._clear_files_when_destroyed = True
+        self._first_execution = True
 
-        self._error_message: Optional[str] = None
-        self._neo_balance_prefix: bytes = b'\x14'
+        self._batch = NeoExpressBatch()
+        self._contracts = ContractCollection()
+        self._invokes = NeoInvokeCollection()
+        self._invokes_to_batch = 0
+        self._last_execution_results: List[NeoInvokeResult] = []
 
     @property
-    def error(self) -> Optional[str]:
-        return self._error_message
+    def file_name(self) -> str:
+        return self._file_name
+
+    @file_name.setter
+    def file_name(self, value: str):
+        if isinstance(value, str) and not value.isspace():
+            from boa3_test.test_drive import utils
+            runner_specific_id = utils.create_custom_id(value)
+            self._file_name = value
+            self._INVOKE_FILE = f'{runner_specific_id}.neo-invoke.json'
+            self._BATCH_FILE = f'{runner_specific_id}.batch'
+            self._CHECKPOINT_FILE = f'{runner_specific_id}.neoxp-checkpoint'
 
     @property
     def vm_state(self) -> VMState:
         return self._vm_state
 
     @property
     def gas_consumed(self) -> int:
         return self._gas_consumed
 
     @property
     def result_stack(self) -> List[Any]:
         return self._result_stack.copy()
 
     @property
-    def notifications(self) -> List[Notification]:
-        return self._notifications.copy()
-
-    def get_events(self, event_name: str = None, origin: Union[UInt160, bytes] = None) -> List[Notification]:
-        if origin is None:
-            return [n for n in self._notifications if n.name == event_name or event_name is None]
-        else:
-            origin_bytes = origin.to_array() if isinstance(origin, UInt160) else bytes(origin)
-            return [n for n in self._notifications if ((n.name == event_name or event_name is None)
-                                                       and n.origin == origin_bytes)]
-
-    @property
-    def storage(self) -> Storage:
-        return self._storage.copy()
-
-    def storage_get(self, key: Union[str, bytes], contract_path: str) -> Any:
-        if isinstance(key, str):
-            key = String(key).to_bytes()
-
-        if contract_path.endswith('.py'):
-            contract_path = contract_path.replace('.py', '.nef')
-        if contract_path not in self.contracts:
-            return None
-
-        contract_id = self._get_contract_id(contract_path)
-        storage_key = Storage.build_key(key, contract_id)
-        if storage_key in self._storage:
-            return self._storage[storage_key]
-        else:
-            return None
-
-    def storage_put(self, key: Union[str, bytes], value: Any, contract_path: str):
-        if isinstance(key, str):
-            key = String(key).to_bytes()
-
-        if contract_path.endswith('.py'):
-            contract_path = contract_path.replace('.py', '.nef')
-        if contract_path in self.contracts:
-            contract_id = self._get_contract_id(contract_path)
-            storage_key = Storage.build_key(key, contract_id)
-
-            self._storage[storage_key] = value
-
-    def set_storage(self, storage: Dict[Tuple[Union[str, bytes], str], Any]):
-        self._storage.clear()
-        for (key, contract_path), value in storage.items():
-            self.storage_put(key, value, contract_path)
-
-    def storage_delete(self, key: Union[str, bytes], contract_path: str):
-        if isinstance(key, str):
-            key = String(key).to_bytes()
-
-        if contract_path.endswith('.py'):
-            contract_path = contract_path.replace('.py', '.nef')
-        if contract_path not in self.contracts:
-            return None
-
-        contract_id = self._get_contract_id(contract_path)
-        storage_key = Storage.build_key(key, contract_id)
-
-        if storage_key in self._storage:
-            self._storage.pop(key)
-
-    def add_neo(self, script_hash: bytes, amount: int) -> bool:
-        return self._storage.add_token(constants.NEO_SCRIPT, script_hash, amount)
-
-    def add_gas(self, script_hash: bytes, amount: int) -> bool:
-        return self._storage.add_token(constants.GAS_SCRIPT, script_hash, amount)
-
-    def add_signer_account(self, account: bytes):
-        if account not in self._accounts:
-            self._accounts.append(account)
+    def error(self) -> Optional[str]:
+        return self._error_message
 
     @property
-    def contracts(self) -> List[str]:
-        return [contract.path for contract in self._contract_paths]
+    def cli_log(self) -> str:
+        return self._cli_log
 
-    def add_contract(self, contract_nef_path: str):
-        if contract_nef_path.endswith('.nef') and contract_nef_path not in self._contract_paths:
-            self._contract_paths.append(TestContract(contract_nef_path))
+    @property
+    def notifications(self) -> List[Notification]:
+        return self._notifications.copy()
 
-    def remove_contract(self, contract_index_or_path: Union[int, str]):
-        if isinstance(contract_index_or_path, str):
-            contracts = self.contracts
-            if contract_index_or_path in contracts:
-                index = contracts.index(contract_index_or_path)
-            else:
-                index = -1
-        else:
-            index = contract_index_or_path
+    def get_events(self, event_name: str = None, origin: TestContract = None) -> List[Notification]:
+        return self._filter_events(self._notifications, event_name, origin)
 
-        if 0 <= index < len(self._contract_paths):
-            return self._contract_paths.pop(index)
+    def get_logs(self, origin: TestContract = None) -> List[Log]:
+        return self._filter_events(self._logs, origin=origin)
 
-    def _get_contract_id(self, contract_path: str) -> int:
-        if path.isfile(contract_path):
-            with open(contract_path, mode='rb') as nef:
-                from boa3.neo.contracts.neffile import NefFile
-                script_hash = NefFile.deserialize(nef.read()).script_hash
+    def _filter_events(self, events: list, event_name: str = None, origin: TestContract = None) -> list:
+        if origin is None and event_name is None:
+            return events.copy()
+        elif origin is None:
+            return [n for n in events if n.name == event_name]
+        else:
+            if hasattr(origin, 'script_hash'):
+                origin_bytes = origin.script_hash
+            elif hasattr(origin, 'to_array'):
+                origin_bytes = origin.to_array()
+            else:
+                origin_bytes = bytes(origin)
 
-            return self._storage.get_contract_id(script_hash)
+            if event_name is None:
+                return [n for n in events if n.origin == origin_bytes]
+            else:
+                return [n for n in events if (n.name == event_name
+                                              and n.origin == origin_bytes)]
 
-        contracts = self.contracts
-        if contract_path in contracts:
-            return contracts.index(contract_path)
-        return -1
+    @property
+    def logs(self) -> List[Log]:
+        return self._logs.copy()
 
     @property
-    def height(self) -> int:
-        return self.current_block.index if self.current_block is not None else self._height
+    def contracts(self) -> ContractCollection:
+        return self._contracts
 
     @property
-    def blocks(self) -> List[Block]:
-        return sorted(self._blocks, key=lambda block: block.index)
+    def storages(self) -> StorageCollection:
+        return self._storages
 
     @property
-    def current_block(self) -> Optional[Block]:
-        return self.blocks[-1] if len(self._blocks) > 0 else None
+    def _root(self) -> str:
+        return self._ROOT_FOLDER
 
-    def increase_block(self, new_height: int = None) -> Block:
-        if self.current_block is None:
-            if new_height is None or new_height <= self._height:
-                new_height = self._height
+    @_root.setter
+    def _root(self, value: str):
+        if isinstance(value, str) and os.path.exists(value) and os.path.isdir(value):
+            sep = os.path.sep
+            root = os.path.abspath(value) + sep + self._FOLDER_NAME
+            self._ROOT_FOLDER = root
+
+    def _update_cli_log(self, log_to_append: str):
+        if self._last_cli_log is None:
+            log_connector = '\n' if len(self._cli_log) > 0 and len(log_to_append) > 0 else ''
+            self._cli_log += f'{log_connector}{log_to_append}'
         else:
-            if new_height is None or new_height <= self._height:
-                new_height = self.height + 1
-            self._height = new_height
-
-        if new_height < 1:
-            # don't use height 0 because this is the genesis block index
-            new_height = 1
-        new_block = Block(new_height)
-        self.add_block(new_block)
-        return new_block
-
-    def add_block(self, block: Block) -> bool:
-        success = len(list(filter(lambda b: b.index == block.index, self._blocks))) == 0
-        if success:
-            self._blocks.append(block)
-        return success
-
-    def get_transactions(self) -> List[Transaction]:
-        txs = []
-        for block in self._blocks:
-            txs.extend(block.get_transactions())
-        return txs
-
-    def add_transaction(self, *transaction: Transaction):
-        if self.current_block is None:
-            self.increase_block()
-
-        current_block = self.current_block
-        for tx in transaction:
-            current_block.add_transaction(tx)
-
-    def run_oracle_response(self, request_id: int, oracle_response: oracleresponse.OracleResponseCode,
-                            result: bytes, reset_engine: bool = False,
-                            rollback_on_fault: bool = True) -> Any:
-        request_ids = [x.arguments[0] if isinstance(x.arguments, (tuple, list)) and len(x.arguments) > 0
-                       else x.arguments
-                       for x in self.get_events('OracleRequest', constants.ORACLE_SCRIPT)]
-
-        assert request_id in request_ids, 'Request ID not found'
-        self._current_tx = Transaction(b'')
-        self._current_tx.add_attribute(oracleresponse.OracleResponse(request_id, oracle_response, result))
-
-        return self.run(UInt160(constants.ORACLE_SCRIPT), 'finish',
-                        reset_engine=reset_engine,
-                        rollback_on_fault=rollback_on_fault)
-
-    def run(self, nef_path: Union[str, UInt160], method: str, *arguments: Any, reset_engine: bool = False,
-            rollback_on_fault: bool = True) -> Any:
-        import json
-        import subprocess
+            self._last_cli_log = self._cli_log
+            self._cli_log = log_to_append
 
-        if isinstance(nef_path, str) and nef_path not in self.contracts:
-            self.add_contract(nef_path)
+    def add_neo(self, script_hash_or_address: Union[bytes, str], amount: int):
+        address = neoxp_utils.get_account_from_script_hash_or_id(script_hash_or_address)
+        self._batch.transfer_assets(sender=self._DEFAULT_ACCOUNT, receiver=address,
+                                    quantity=amount,
+                                    asset='NEO')
+
+    def add_gas(self, script_hash_or_address: Union[bytes, str], amount: int):
+        address = neoxp_utils.get_account_from_script_hash_or_id(script_hash_or_address)
+        gas_decimals = 8
+        self._batch.transfer_assets(sender=self._DEFAULT_ACCOUNT, receiver=address,
+                                    asset='GAS', decimals=gas_decimals,
+                                    quantity=(amount / (10 ** gas_decimals)))
+
+    def get_genesis_block(self) -> Block:
+        return self.get_block(0)
+
+    def get_latest_block(self) -> Block:
+        return self.get_block(None)
+
+    def get_block(self, block_hash_or_index: Union[UInt256, bytes, int]) -> Optional[Block]:
+        genesis = neoxp_utils.get_genesis_block()
+        if isinstance(genesis, Block) and block_hash_or_index in (genesis.hash, genesis.index):
+            # genesis block doesn't change between neo express resets
+            return genesis
+
+        check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
+        block = neoxp_utils.get_block(self._neoxp_abs_path, block_hash_or_index,
+                                      check_point_file=check_point_path)
+
+        if not isinstance(genesis, Block) and isinstance(block, Block) and block.index == 0:
+            neoxp_utils._set_genesis_block(block)  # optimization for consecutive executions
+        return block
+
+    def get_transaction(self, tx_hash: Union[UInt256, bytes]) -> Optional[Transaction]:
+        check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
+        return neoxp_utils.get_transaction(self._neoxp_abs_path, tx_hash,
+                                           check_point_file=check_point_path)
+
+    def get_transaction_result(self, tx_hash: Union[UInt256, bytes]) -> Optional[TransactionLog]:
+        check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
+        return neoxp_utils.get_transaction_log(self._neoxp_abs_path, tx_hash,
+                                               check_point_file=check_point_path,
+                                               contract_collection=self._contracts)
+
+    def deploy_contract(self, nef_path: str, account: Account = None) -> TestContract:
+        if not isinstance(nef_path, str) or not nef_path.endswith('.nef'):
+            raise ValueError('Requires a .nef file to deploy a contract')
+
+        if nef_path not in self._contracts:
+            contract = self._batch.deploy_contract(nef_path, account)
+            if contract.name in self._contracts:
+                raise ValueError('Contract with duplicated name')
+            self._contracts.append(contract)
+        else:
+            contract = self._contracts[nef_path]
+        return contract
 
-        test_engine_args = self.to_json(nef_path, method, *arguments)
-        param_json = json.dumps(test_engine_args, separators=(',', ':'))
+    def call_contract(self, nef_path: str, method: str, *arguments: Any,
+                      expected_result_type: Type = None) -> NeoInvokeResult:
+        if nef_path not in self._contracts:
+            contract = self.deploy_contract(nef_path)
+        else:
+            contract = self._contracts[nef_path]
 
-        try:
-            process = subprocess.Popen(['dotnet', self._test_engine_path, param_json],
-                                       stdout=subprocess.PIPE,
-                                       stderr=subprocess.STDOUT,
-                                       text=True)
-        except BaseException:
-            json_path = '{0}/test-engine-test.json'.format(path.curdir)
-            with open(json_path, 'wb+') as json_file:
-                json_file.write(String(param_json).to_bytes())
-                json_file.close()
-
-            process = subprocess.Popen(['dotnet', self._test_engine_path, json_path],
-                                       stdout=subprocess.PIPE,
-                                       stderr=subprocess.STDOUT,
-                                       text=True)
+        return self._invokes.append_contract_invoke(contract, method, *arguments,
+                                                    expected_result_type=expected_result_type)
 
-        stdout, stderr = process.communicate()
+    def run_contract(self, nef_path: str, method: str, *arguments: Any,
+                     account: Account = None, witness_scope: WitnessScope = WitnessScope.CalledByEntry,
+                     expected_result_type: Type = None) -> NeoBatchInvoke:
+        if nef_path not in self._contracts:
+            contract = self.deploy_contract(nef_path)
+        else:
+            contract = self._contracts[nef_path]
 
-        if reset_engine:
-            self.reset_engine()
+        if witness_scope != WitnessScope.CalledByEntry:
+            # neo express only supports CalledByEntry and Global as witness scopes
+            witness_scope = WitnessScope.Global
+
+        invoke = self._invokes.create_contract_invoke(contract, method, *arguments)
+        if isinstance(account, Account):
+            invoke._invoker = account
+        return self._batch.run_contract(invoke,
+                                        witness_scope=witness_scope,
+                                        expected_result_type=expected_result_type)
+
+    def get_contract(self, contract_id: Union[str, bytes]) -> TestContract:
+        return self._contracts[contract_id]
+
+    def update_contracts(self, export_checkpoint: bool = False):
+        self._generate_root_folder()
+        if export_checkpoint:
+            self._create_checkpoint_from_batch()
         else:
-            self.reset_state()
+            self._update_contracts()
 
-        stdout = stdout.splitlines()[-1]
+    def _update_contracts(self):
+        batch_file_path = self.get_full_path(self._BATCH_FILE)
+        if self._first_execution:
+            check_point_path = None
+            self._first_execution = False
+        else:
+            check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
 
-        try:
-            result = json.loads(stdout)
+        batch_has_deploys = self._batch.has_new_deploys()
+        log = self._batch.execute(self._neoxp_abs_path, batch_file_path,
+                                  check_point_file=check_point_path,
+                                  reset=True
+                                  )
+        self._update_cli_log(log)
+
+        if batch_has_deploys:
+            self._contracts.update_after_deploy()
+
+    def execute(self, account: Account = None, get_storage_from: Union[str, TestContract] = None,
+                clear_invokes: bool = True, add_invokes_to_batch: bool = False):
+        self._generate_files()
+        invoke_file_path = self.get_full_path(self._INVOKE_FILE)
+        cli_args = ['neo-test-runner', invoke_file_path
+                    ]
+
+        checkpoint_file = self.get_full_path(self._CHECKPOINT_FILE)
+        if os.path.isfile(checkpoint_file):
+            cli_args.extend(['--checkpoint', checkpoint_file])
+
+        if isinstance(account, Account):
+            cli_args.extend(['--account', account.get_identifier()])
+            cli_args.extend(['--express', self._neoxp_abs_path])
+        elif account is not None:
+            account = None
+        self._calling_account = account
+
+        if isinstance(get_storage_from, TestContract):
+            get_storage_from = get_storage_from.get_identifier()
+        if isinstance(get_storage_from, str):
+            cli_args.extend(['--storages', get_storage_from])
+        stdout, stderr = self._run_command_line(cli_args)
 
-            self._error_message = result['error'] if 'error' in result else None
+        try:
+            self.reset_state()
+            try:
+                result = json.loads(stdout)
+            except json.JSONDecodeError:
+                result = utils.handle_return_error(stdout)
 
-            if 'vmstate' in result:
-                self._vm_state = VMState.get_vm_state(result['vmstate'])
+            self._update_runner(result)
+        except BaseException:
+            self._error_message = stdout
 
-            if 'gasconsumed' in result:
-                self._gas_consumed = int(result['gasconsumed'])
-
-            if 'resultstack' in result:
-                if isinstance(result['resultstack'], list):
-                    self._result_stack = [stack_item_from_json(value) for value in result['resultstack']]
-                else:
-                    self._result_stack = [stack_item_from_json(result['resultstack'])]
-
-            if self._vm_state is VMState.HALT or not rollback_on_fault:
-                if 'notifications' in result:
-                    json_storage = result['notifications']
-                    if not isinstance(json_storage, list):
-                        json_storage = [json_storage]
-
-                    notifications = []
-                    for n in json_storage:
-                        new = Notification.from_json(n)
-                        if new is not None:
-                            notifications.append(new)
-                    self._notifications.extend(notifications)
-
-                if 'storage' in result:
-                    json_storage = result['storage']
-                    self._storage = Storage.from_json(json_storage)
-
-                    for contract in self._contract_paths.copy():
-                        if (not isinstance(contract, TestContract)
-                                or contract.script_hash is None
-                                or not self._storage.has_contract(contract.script_hash)):
-                            self.remove_contract(contract.path)
-
-                if 'currentblock' in result:
-                    current_block = Block.from_json(result['currentblock'])
-
-                    existing_block = next((block for block in self._blocks if block.index == current_block.index), None)
-                    if existing_block is not None:
-                        self._blocks.remove(existing_block)
-                    self._blocks.append(current_block)
-
-                if 'transaction' in result and self._vm_state is VMState.HALT:
-                    block = self.current_block
-                    if block is None:
-                        block = self.increase_block(self.height)
+        if add_invokes_to_batch:
+            import shutil
+            self._invokes_to_batch += 1
+            invoke_file_path_to_batch = self.get_full_path(f'{self._file_name}_{self._invokes_to_batch}.neo-invoke.json')
+            shutil.copy(invoke_file_path, invoke_file_path_to_batch)
+            self._batch.invoke_file(invoke_file_path_to_batch, account=account)
 
-                    tx = Transaction.from_json(result['transaction'])
-                    block.add_transaction(tx)
+        if clear_invokes:
+            self._invokes.clear(state=self._vm_state)
 
-        except BaseException as e:
-            self._error_message = str(e)
+        if self._error_message is not None:
+            return self._error_message
+        else:
+            return self._last_execution_results
 
-        # TODO: convert the result to the return type of the function in the manifest
-        return self._result_stack[-1] if len(self._result_stack) > 0 else VoidType
+    def __del__(self):
+        self.reset()
+        if self._clear_files_when_destroyed:
+            paths_to_delete = [
+                self.get_full_path(self._CHECKPOINT_FILE),
+                self.get_full_path(self._BATCH_FILE),
+                self.get_full_path(self._INVOKE_FILE)
+            ]
+            for path in paths_to_delete:
+                try:
+                    if os.path.exists(path):
+                        os.remove(path)
+                except BaseException as e:
+                    print(e)
+                    continue
 
     def reset_state(self):
         self._vm_state = VMState.NONE
         self._gas_consumed = 0
         self._result_stack = []
-        self._accounts = []
-        self._current_tx = None
+        self._last_execution_results = []
+        self._notifications.clear()
+        self._logs.clear()
+        self._storages.clear()
+        self._last_cli_log = None
         self._error_message = None
 
-    def reset_engine(self):
+    def reset(self):
         self.reset_state()
-        self._notifications.clear()
-        self._storage.clear()
+        self._first_execution = True
+
+        self._batch.clear()
+        self._contracts.clear()
+        self._invokes.clear()
+        self._invokes_to_batch = 0
+
+    def _update_runner(self, result: Dict[str, Any]):
+        self.reset_state()
+        self._error_message = result['exception'] if 'exception' in result else None
+
+        self._last_cli_log = self._cli_log
+        if 'state' in result:
+            self._vm_state = vmstate.get_vm_state(result['state'])
+
+        if 'gasconsumed' in result:
+            self._gas_consumed = int(float(result['gasconsumed']) * 10 ** constants.GAS_DECIMALS)
+
+        if 'stack' in result:
+            result_stack = result['stack']
+            if isinstance(result_stack, list):
+                new_result_stack = [neo_utils.stack_item_from_json(value) for value in result_stack]
+            else:
+                new_result_stack = [neo_utils.stack_item_from_json(result_stack)]
+
+            self._last_execution_results = self._invokes.set_results(new_result_stack,
+                                                                     calling_account=self._calling_account)
+            self._result_stack = new_result_stack
+
+        if 'notifications' in result:
+            json_notifications = result['notifications']
+            if not isinstance(json_notifications, list):
+                json_notifications = [json_notifications]
+
+            notifications = []
+            for n in json_notifications:
+                new = Notification.from_json(n, contract_collection=self._contracts)
+                if new is not None:
+                    notifications.append(new)
+            self._notifications.extend(notifications)
+
+        if 'logs' in result:
+            json_logs = result['logs']
+            if not isinstance(json_logs, list):
+                json_logs = [json_logs]
+
+            logs = []
+            for l in json_logs:
+                new = Log.from_json(l)
+                if new is not None:
+                    logs.append(new)
+            self._logs.extend(logs)
+
+        if 'storages' in result:
+            json_storages = result['storages']
+            if not isinstance(json_storages, list):
+                json_storages = [json_storages]
+
+            for s in json_storages:
+                new = Storage.from_json(s, self._contracts)
+                if new is not None:
+                    self._storages.append(new)
+
+    def _generate_root_folder(self):
+        if not os.path.exists(self._root):
+            os.mkdir(self._root)
+
+    def _generate_files(self):
+        self._generate_root_folder()
+
+        checkpoint_thread = threading.Thread(target=self._create_checkpoint_from_batch)
+        checkpoint_thread.start()
+
+        self._generate_invoke_file()
+        checkpoint_thread.join()
+
+    def _create_checkpoint_from_batch(self):
+        check_point_path = self.get_full_path(self._CHECKPOINT_FILE)
+
+        if not os.path.exists(check_point_path) or self._batch.cur_size() > 0:
+            self._batch.create_neo_express_checkpoint(check_point_path,
+                                                      overwrite=True)
+        # update list of contracts
+        self._update_contracts()
+
+    def _generate_invoke_file(self):
+        invoke_file_content = self._invokes.to_json()
+        param_json = json.dumps(invoke_file_content, separators=(',', ':'))
+        with open(self.get_full_path(self._INVOKE_FILE), 'wb+') as json_file:
+            json_file.write(String(param_json).to_bytes())
+
+    def get_full_path(self, file_name: str):
+        return self._root + os.path.sep + file_name
+
+    def _run_command_line(self, args: List[str]) -> Tuple[str, str]:
+        process = subprocess.Popen(args,
+                                   stdout=subprocess.PIPE,
+                                   stderr=subprocess.STDOUT,
+                                   text=True)
+        return process.communicate()
 
-    def to_json(self, path: Union[str, UInt160], method: str, *args: Any) -> Dict[str, Any]:
-        json = {
-            'path': path if isinstance(path, str) else '',
-            'scripthash': str(path) if isinstance(path, UInt160) else None,
-            'method': method,
-            'arguments': [contract_parameter_to_json(x) for x in args],
-            'storage': self._storage.to_json(),
-            'contracts': [{'nef': contract_path} for contract_path in self.contracts],
-            'signeraccounts': [to_hex_str(address) for address in self._accounts],
-            'height': self.height,
-            'blocks': [block.to_json() for block in self.blocks]
-        }
-        if isinstance(self._current_tx, Transaction):
-            json['currenttx'] = self._current_tx.to_json()
-        return json
+    def increase_block(self, block_to_mint: int = None, time_interval_in_secs: int = 0):
+        self._batch.mint_block(block_to_mint, time_interval_in_secs)
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/transaction.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/transaction.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,71 +1,60 @@
 from __future__ import annotations
 
-import base64
 from typing import Any, Dict, List, Optional
 
-from boa3.neo import from_hex_str
-from boa3.neo3.core.types import UInt256
+from boa3.internal.neo3.vm import VMState, vmstate
+from boa3_test.test_drive.model.network.payloads.testtransaction import TestTransaction
 from boa3_test.tests.test_classes import transactionattribute as tx_attribute
 from boa3_test.tests.test_classes.signer import Signer
 from boa3_test.tests.test_classes.witness import Witness
 
 
-class Transaction:
+class Transaction(TestTransaction):
     def __init__(self, script: bytes, signers: List[Signer] = None, witnesses: List[Witness] = None):
-        self._signers: List[Signer] = signers if signers is not None else []
-        self._witnesses: List[Witness] = witnesses if witnesses is not None else []
+        super().__init__(None, script, signers, witnesses)
         self._attributes: List[tx_attribute.TransactionAttribute] = []
-        self._script: bytes = script
-        self._hash: Optional[UInt256] = None
+        self._state: VMState = VMState.NONE
 
     def add_attribute(self, tx_attr: tx_attribute.TransactionAttribute):
         if tx_attr not in self._attributes:
             self._attributes.append(tx_attr)
 
     @property
     def hash(self) -> Optional[bytes]:
         if self._hash is None:
             return None
-        else:
-            return self._hash.to_array()
+
+        return super().hash.to_array()
+
+    @property
+    def state(self) -> VMState:
+        return self._state
 
     def to_json(self) -> Dict[str, Any]:
-        from boa3.neo.vm.type.String import String
-        return {
-            'signers': [signer.to_json() for signer in self._signers],
-            'witnesses': [witness.to_json() for witness in self._witnesses],
-            'attributes': [attr.to_json() for attr in self._attributes],
-            'script': String.from_bytes(base64.b64encode(self._script))
-        }
+        json = super().to_json()
+
+        json.pop('hash')  # don't include hash in this json
+        json['state'] = self._state.name
+
+        return json
 
     @classmethod
     def from_json(cls, json: Dict[str, Any]) -> Transaction:
-        script = base64.b64decode(json['script'])
-        tx = cls(script)
-        if 'signers' in json:
-            signers_json = json['signers']
-            if not isinstance(signers_json, list):
-                signers_json = [signers_json]
-            tx._signers = [Signer.from_json(js) for js in signers_json]
-
-        if 'witnesses' in json:
-            witnesses_json = json['witnesses']
-            if not isinstance(witnesses_json, list):
-                witnesses_json = [witnesses_json]
-            tx._witnesses = [Witness.from_json(js) for js in witnesses_json]
+        tx: Transaction = super().from_json(json)
 
         if 'attributes' in json:
             attributes_json = json['attributes']
             if not isinstance(attributes_json, list):
                 attributes_json = [attributes_json]
             tx._attributes = [tx_attribute.TransactionAttribute.from_json(js) for js in attributes_json]
 
-        if 'hash' in json and isinstance(json['hash'], str):
-            tx._hash = UInt256(from_hex_str(json['hash']))
+        if 'state' in json and isinstance(json['state'], str):
+            tx._state = vmstate.get_vm_state(json['state'])
+
         return tx
 
     def copy(self):
         copied = Transaction(self._script, self._signers, self._witnesses)
         copied._hash = self._hash
         return copied
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/oracleresponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from __future__ import annotations
 
 import base64
 import enum
 from typing import Any, Dict
 
-from boa3.neo.vm.type.String import String
+from boa3.internal.neo.vm.type.String import String
 from boa3_test.tests.test_classes.transactionattribute import TransactionAttribute, TransactionAttributeType
 
 
 class OracleResponse(TransactionAttribute):
     def __init__(self, request_id: int, code: OracleResponseCode, result: bytes):
         super().__init__(TransactionAttributeType.OracleResponse)
         self._id: int = request_id
```

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py` & `neo3-boa-1.0.0/boa3_test/tests/test_classes/transactionattribute/transactionattribute.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/boa3_test/tests/test_classes/witness.py` & `neo3-boa-1.0.0/boa3_test/test_drive/model/network/payloads/witness.py`

 * *Files identical despite different names*

### Comparing `neo3-boa-0.9.0/setup.py` & `neo3-boa-1.0.0/setup.py`

 * *Files 8% similar despite different names*

```diff
@@ -57,37 +57,45 @@
 
     # See https://pypi.python.org/pypi?%3Aaction=list_classifiers
     classifiers=[
         # How mature is this project? Common values are
         #   3 - Alpha
         #   4 - Beta
         #   5 - Production/Stable
-        'Development Status :: 3 - Alpha',
+        'Development Status :: 5 - Production/Stable',
 
         # Indicate who your project is intended for
         'Intended Audience :: Developers',
         'Topic :: Software Development :: Build Tools',
 
         # Pick your license as you wish (should match "license" above)
         'License :: OSI Approved :: Apache Software License',
 
         # Specify the Python versions you support here. In particular, ensure
         # that you indicate whether you support Python 2, Python 3 or both.
         'Programming Language :: Python :: 3.7',
         'Programming Language :: Python :: 3.8',
+        'Programming Language :: Python :: 3.9',
+        'Programming Language :: Python :: 3.10',
     ],
 
     # What does your project relate to?
 
     keywords='compiler NEO .nef blockchain smartcontract development dApp',
 
     # You can just specify the packages manually here if your project is
     # simple. Or you can use find_packages().
 
-    packages=find_packages(),
+    packages=find_packages(
+        # do not include the compiler unit tests in the installed package
+        exclude=('boa3_test.tests.*_tests*',),
+        include=('boa3', 'boa3.*',
+                 'boa3_test.tests', 'boa3_test.tests.*',
+                 'boa3_test.test_drive', 'boa3_test.test_drive.*'),
+    ),
 
     # Alternatively, if you want to distribute just a my_module.py, uncomment
     # this:
     #   py_modules=["my_module"],
 
     # List run-time dependencies here.  These will be installed by pip when
     # your project is installed. For an analysis of "install_requires" vs pip's
@@ -121,10 +129,11 @@
 
     # To provide executable scripts, use entry points in preference to the
     # "scripts" keyword. Entry points provide cross-platform support and allow
     # pip to create the appropriate form of executable for the target platform.
     entry_points={
        'console_scripts': [
            'neo3-boa=boa3.cli:main',
+           'install_cpm=boa3.cpm:main',
        ],
     },
 )
```

