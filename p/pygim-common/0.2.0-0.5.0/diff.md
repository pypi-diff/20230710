# Comparing `tmp/pygim_common-0.2.0-py3-none-any.whl.zip` & `tmp/pygim_common-0.5.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,52 +1,43 @@
-Zip file size: 34732 bytes, number of entries: 50
--rw-r--r--  2.0 unx       66 b- defN 16-Jan-01 00:00 _pygim/__init__.py
--rw-r--r--  2.0 unx      139 b- defN 16-Jan-01 00:00 _pygim/_cli/__init__.py
--rw-r--r--  2.0 unx       45 b- defN 16-Jan-01 00:00 _pygim/_cli/__init__.pyi
--rw-r--r--  2.0 unx     1492 b- defN 16-Jan-01 00:00 _pygim/_cli/cliapp.py
--rw-r--r--  2.0 unx      209 b- defN 16-Jan-01 00:00 _pygim/_cli/support.py
--rw-r--r--  2.0 unx      102 b- defN 16-Jan-01 00:00 _pygim/_magic/__init__.py
--rw-r--r--  2.0 unx     5128 b- defN 16-Jan-01 00:00 _pygim/_magic/_cached_type.py
--rw-r--r--  2.0 unx     3461 b- defN 16-Jan-01 00:00 _pygim/_magic/_dispatcher.py
--rw-r--r--  2.0 unx     6673 b- defN 16-Jan-01 00:00 _pygim/_magic/_gimmick.py
--rw-r--r--  2.0 unx     7985 b- defN 16-Jan-01 00:00 _pygim/_magic/_patch.py
--rw-r--r--  2.0 unx      284 b- defN 16-Jan-01 00:00 _pygim/_magic/_support.py
--rw-r--r--  2.0 unx     1931 b- defN 16-Jan-01 00:00 _pygim/_magic/_traits.py
--rw-r--r--  2.0 unx      337 b- defN 16-Jan-01 00:00 _pygim/_utils/__init__.py
--rw-r--r--  2.0 unx     3933 b- defN 16-Jan-01 00:00 _pygim/_utils/_inspect.py
--rw-r--r--  2.0 unx     2975 b- defN 16-Jan-01 00:00 _pygim/_utils/_iterable.py
--rw-r--r--  2.0 unx      662 b- defN 16-Jan-01 00:00 pygim/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 16-Jan-01 00:00 pygim/__init__.pyi
--rw-r--r--  2.0 unx     1087 b- defN 16-Jan-01 00:00 pygim/__main__.py
--rw-r--r--  2.0 unx      215 b- defN 16-Jan-01 00:00 pygim/__main__.pyi
--rw-r--r--  2.0 unx       85 b- defN 16-Jan-01 00:00 pygim/__version__.py
--rw-r--r--  2.0 unx      450 b- defN 16-Jan-01 00:00 pygim/exceptions.py
--rw-r--r--  2.0 unx      161 b- defN 16-Jan-01 00:00 pygim/exceptions.pyi
--rw-r--r--  2.0 unx       78 b- defN 16-Jan-01 00:00 pygim/kernel/__init__.py
--rw-r--r--  2.0 unx       75 b- defN 16-Jan-01 00:00 pygim/kernel/__init__.pyi
--rw-r--r--  2.0 unx     6735 b- defN 16-Jan-01 00:00 pygim/kernel/entangled_class.py
--rw-r--r--  2.0 unx      780 b- defN 16-Jan-01 00:00 pygim/kernel/entangled_class.pyi
--rw-r--r--  2.0 unx        0 b- defN 16-Jan-01 00:00 pygim/kernel/magic/__init__.py
--rw-r--r--  2.0 unx     1319 b- defN 16-Jan-01 00:00 pygim/kernel/magic/cached_type.pyi
--rw-r--r--  2.0 unx      224 b- defN 16-Jan-01 00:00 pygim/kernel/magic/support.pyi
--rw-r--r--  2.0 unx     9973 b- defN 16-Jan-01 00:00 pygim/kernel/pathset.py
--rw-r--r--  2.0 unx     1506 b- defN 16-Jan-01 00:00 pygim/kernel/pathset.pyi
--rw-r--r--  2.0 unx      109 b- defN 16-Jan-01 00:00 pygim/kernel/traits.py
--rw-r--r--  2.0 unx     1241 b- defN 16-Jan-01 00:00 pygim/typing.py
--rw-r--r--  2.0 unx     1607 b- defN 16-Jan-01 00:00 pygim/utils/__init__.py
--rw-r--r--  2.0 unx      297 b- defN 16-Jan-01 00:00 pygim/utils/__init__.pyi
--rw-r--r--  2.0 unx      290 b- defN 16-Jan-01 00:00 pygim/utils/iterable.pyi
--rw-r--r--  2.0 unx      513 b- defN 16-Jan-01 00:00 pygim/utils/misc.py
--rw-r--r--  2.0 unx       81 b- defN 16-Jan-01 00:00 pygim/utils/misc.pyi
--rw-r--r--  2.0 unx     2385 b- defN 16-Jan-01 00:00 pygim/utils/performance.py
--rw-r--r--  2.0 unx      256 b- defN 16-Jan-01 00:00 pygim/utils/performance.pyi
--rw-r--r--  2.0 unx     3954 b- defN 16-Jan-01 00:00 pygim/utils/persistence.py
--rw-r--r--  2.0 unx      374 b- defN 16-Jan-01 00:00 pygim/utils/persistence.pyi
--rw-r--r--  2.0 unx     1175 b- defN 16-Jan-01 00:00 pygim/utils/security.py
--rw-r--r--  2.0 unx      112 b- defN 16-Jan-01 00:00 pygim/utils/security.pyi
--rw-r--r--  2.0 unx     2448 b- defN 16-Jan-01 00:00 pygim/utils/testing.py
--rw-r--r--  2.0 unx      334 b- defN 16-Jan-01 00:00 pygim/utils/testing.pyi
--rw-r--r--  2.0 unx     2160 b- defN 16-Jan-01 00:00 pygim_common-0.2.0.dist-info/METADATA
--rw-r--r--  2.0 unx       87 b- defN 16-Jan-01 00:00 pygim_common-0.2.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       44 b- defN 16-Jan-01 00:00 pygim_common-0.2.0.dist-info/entry_points.txt
-?rw-------  2.0 unx     3996 b- defN 16-Jan-01 00:00 pygim_common-0.2.0.dist-info/RECORD
-50 files, 79573 bytes uncompressed, 28428 bytes compressed:  64.3%
+Zip file size: 33036 bytes, number of entries: 41
+-rw-r--r--  2.0 unx       66 b- defN 23-Jul-09 15:19 _pygim/__init__.py
+-rw-r--r--  2.0 unx     1040 b- defN 23-Jul-09 17:22 _pygim/_error_msgs.py
+-rw-r--r--  2.0 unx      565 b- defN 23-Jul-09 15:19 _pygim/_exceptions.py
+-rw-r--r--  2.0 unx     1828 b- defN 23-Jul-09 16:53 _pygim/_iterlib.py
+-rw-r--r--  2.0 unx     1241 b- defN 23-Jul-10 04:56 _pygim/typing.py
+-rw-r--r--  2.0 unx      102 b- defN 23-Jul-09 15:19 _pygim/_magic/__init__.py
+-rw-r--r--  2.0 unx     5102 b- defN 23-Jul-09 15:19 _pygim/_magic/_cached_type.py
+-rw-r--r--  2.0 unx     3649 b- defN 23-Jul-09 15:19 _pygim/_magic/_dispatcher.py
+-rw-r--r--  2.0 unx     6549 b- defN 23-Jul-09 15:19 _pygim/_magic/_entangled.py
+-rw-r--r--  2.0 unx     6775 b- defN 23-Jul-09 16:55 _pygim/_magic/_gimmick.py
+-rw-r--r--  2.0 unx     8010 b- defN 23-Jul-09 15:19 _pygim/_magic/_patch.py
+-rw-r--r--  2.0 unx      284 b- defN 23-Jul-09 15:19 _pygim/_magic/_support.py
+-rw-r--r--  2.0 unx     1982 b- defN 23-Jul-09 15:19 _pygim/_magic/_traits.py
+-rw-r--r--  2.0 unx      109 b- defN 23-Jul-09 15:19 _pygim/_magic/traits.py
+-rw-r--r--  2.0 unx      337 b- defN 23-Jul-09 15:46 _pygim/_utils/__init__.py
+-rw-r--r--  2.0 unx      374 b- defN 23-Jul-09 16:28 _pygim/_utils/_fileutils.py
+-rw-r--r--  2.0 unx      617 b- defN 23-Jul-09 15:46 _pygim/_utils/_inspect.py
+-rw-r--r--  2.0 unx     1206 b- defN 23-Jul-09 15:46 pygim/__init__.py
+-rw-r--r--  2.0 unx       85 b- defN 23-Jul-09 16:10 pygim/__version__.py
+-rw-r--r--  2.0 unx     1821 b- defN 23-Jul-09 15:46 pygim/checklib.py
+-rw-r--r--  2.0 unx      411 b- defN 23-Jul-09 15:46 pygim/explib.py
+-rw-r--r--  2.0 unx      560 b- defN 23-Jul-09 15:56 pygim/iterlib.py
+-rw-r--r--  2.0 unx      654 b- defN 23-Jul-09 15:19 pygim/fileio/__init__.py
+-rw-r--r--  2.0 unx     3928 b- defN 23-Jul-09 15:19 pygim/fileio/fileops.py
+-rw-r--r--  2.0 unx    11471 b- defN 23-Jul-09 17:07 pygim/fileio/pathset.py
+-rw-r--r--  2.0 unx      935 b- defN 23-Jul-09 15:19 pygim/gimmicks/__init__.py
+-rw-r--r--  2.0 unx      368 b- defN 23-Jul-09 15:19 pygim/gimmicks/entangled.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Jul-09 15:19 pygim/performance/__init__.py
+-rw-r--r--  2.0 unx      840 b- defN 23-Jul-09 15:19 pygim/performance/dispatch.py
+-rw-r--r--  2.0 unx     2355 b- defN 23-Jul-09 15:19 pygim/performance/timing_and_profiling.py
+-rw-r--r--  2.0 unx      257 b- defN 23-Jul-09 15:19 pygim/security/__init__.py
+-rw-r--r--  2.0 unx     3217 b- defN 23-Jul-09 15:19 pygim/security/shasum.py
+-rw-r--r--  2.0 unx      478 b- defN 23-Jul-09 15:19 pygim/testing/__init__.py
+-rw-r--r--  2.0 unx     2713 b- defN 23-Jul-10 06:19 pygim/testing/diff.py
+-rw-r--r--  2.0 unx     2680 b- defN 23-Jul-09 15:19 pygim/testing/testing.py
+-rw-r--r--  2.0 unx      360 b- defN 23-Jul-09 15:19 pygim/utils/__init__.py
+-rw-r--r--  2.0 unx      511 b- defN 23-Jul-09 15:19 pygim/utils/attributes.py
+-rw-r--r--  2.0 unx     1007 b- defN 23-Jul-10 07:21 pygim_common-0.5.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-10 07:21 pygim_common-0.5.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       13 b- defN 23-Jul-10 07:21 pygim_common-0.5.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3281 b- defN 23-Jul-10 07:21 pygim_common-0.5.0.dist-info/RECORD
+41 files, 78426 bytes uncompressed, 27852 bytes compressed:  64.5%
```

## zipnote {}

```diff
@@ -1,151 +1,124 @@
 Filename: _pygim/__init__.py
 Comment: 
 
-Filename: _pygim/_cli/__init__.py
+Filename: _pygim/_error_msgs.py
 Comment: 
 
-Filename: _pygim/_cli/__init__.pyi
+Filename: _pygim/_exceptions.py
 Comment: 
 
-Filename: _pygim/_cli/cliapp.py
+Filename: _pygim/_iterlib.py
 Comment: 
 
-Filename: _pygim/_cli/support.py
+Filename: _pygim/typing.py
 Comment: 
 
 Filename: _pygim/_magic/__init__.py
 Comment: 
 
 Filename: _pygim/_magic/_cached_type.py
 Comment: 
 
 Filename: _pygim/_magic/_dispatcher.py
 Comment: 
 
+Filename: _pygim/_magic/_entangled.py
+Comment: 
+
 Filename: _pygim/_magic/_gimmick.py
 Comment: 
 
 Filename: _pygim/_magic/_patch.py
 Comment: 
 
 Filename: _pygim/_magic/_support.py
 Comment: 
 
 Filename: _pygim/_magic/_traits.py
 Comment: 
 
-Filename: _pygim/_utils/__init__.py
-Comment: 
-
-Filename: _pygim/_utils/_inspect.py
-Comment: 
-
-Filename: _pygim/_utils/_iterable.py
+Filename: _pygim/_magic/traits.py
 Comment: 
 
-Filename: pygim/__init__.py
+Filename: _pygim/_utils/__init__.py
 Comment: 
 
-Filename: pygim/__init__.pyi
+Filename: _pygim/_utils/_fileutils.py
 Comment: 
 
-Filename: pygim/__main__.py
+Filename: _pygim/_utils/_inspect.py
 Comment: 
 
-Filename: pygim/__main__.pyi
+Filename: pygim/__init__.py
 Comment: 
 
 Filename: pygim/__version__.py
 Comment: 
 
-Filename: pygim/exceptions.py
-Comment: 
-
-Filename: pygim/exceptions.pyi
-Comment: 
-
-Filename: pygim/kernel/__init__.py
-Comment: 
-
-Filename: pygim/kernel/__init__.pyi
-Comment: 
-
-Filename: pygim/kernel/entangled_class.py
-Comment: 
-
-Filename: pygim/kernel/entangled_class.pyi
+Filename: pygim/checklib.py
 Comment: 
 
-Filename: pygim/kernel/magic/__init__.py
+Filename: pygim/explib.py
 Comment: 
 
-Filename: pygim/kernel/magic/cached_type.pyi
+Filename: pygim/iterlib.py
 Comment: 
 
-Filename: pygim/kernel/magic/support.pyi
+Filename: pygim/fileio/__init__.py
 Comment: 
 
-Filename: pygim/kernel/pathset.py
+Filename: pygim/fileio/fileops.py
 Comment: 
 
-Filename: pygim/kernel/pathset.pyi
+Filename: pygim/fileio/pathset.py
 Comment: 
 
-Filename: pygim/kernel/traits.py
+Filename: pygim/gimmicks/__init__.py
 Comment: 
 
-Filename: pygim/typing.py
+Filename: pygim/gimmicks/entangled.py
 Comment: 
 
-Filename: pygim/utils/__init__.py
+Filename: pygim/performance/__init__.py
 Comment: 
 
-Filename: pygim/utils/__init__.pyi
+Filename: pygim/performance/dispatch.py
 Comment: 
 
-Filename: pygim/utils/iterable.pyi
+Filename: pygim/performance/timing_and_profiling.py
 Comment: 
 
-Filename: pygim/utils/misc.py
+Filename: pygim/security/__init__.py
 Comment: 
 
-Filename: pygim/utils/misc.pyi
+Filename: pygim/security/shasum.py
 Comment: 
 
-Filename: pygim/utils/performance.py
+Filename: pygim/testing/__init__.py
 Comment: 
 
-Filename: pygim/utils/performance.pyi
+Filename: pygim/testing/diff.py
 Comment: 
 
-Filename: pygim/utils/persistence.py
+Filename: pygim/testing/testing.py
 Comment: 
 
-Filename: pygim/utils/persistence.pyi
-Comment: 
-
-Filename: pygim/utils/security.py
-Comment: 
-
-Filename: pygim/utils/security.pyi
-Comment: 
-
-Filename: pygim/utils/testing.py
+Filename: pygim/utils/__init__.py
 Comment: 
 
-Filename: pygim/utils/testing.pyi
+Filename: pygim/utils/attributes.py
 Comment: 
 
-Filename: pygim_common-0.2.0.dist-info/METADATA
+Filename: pygim_common-0.5.0.dist-info/METADATA
 Comment: 
 
-Filename: pygim_common-0.2.0.dist-info/WHEEL
+Filename: pygim_common-0.5.0.dist-info/WHEEL
 Comment: 
 
-Filename: pygim_common-0.2.0.dist-info/entry_points.txt
+Filename: pygim_common-0.5.0.dist-info/top_level.txt
 Comment: 
 
-Filename: pygim_common-0.2.0.dist-info/RECORD
+Filename: pygim_common-0.5.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## _pygim/_magic/_cached_type.py

```diff
@@ -1,16 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 This module implements cached type that can be used to manage singletons.
 """
 
 __all__ = ["CachedTypeMeta", "CachedType", "create_cached_class"]
 
-import pygim.typing as t
-
 
 class CachedInstanceMeta(type):
     __instance_cache = {}
 
     def __new__(mcls, name, bases, namespace):
         return super(CachedInstanceMeta, mcls).__new__(mcls, name, bases, namespace)
```

## _pygim/_magic/_dispatcher.py

```diff
@@ -1,8 +1,17 @@
+# -*- coding: utf-8 -*-
+"""
+Dispatcher class internal implementation.
+"""
+
+from itertools import product
+from functools import wraps
 from dataclasses import dataclass, field
+from .._exceptions import GimError
+from .._utils._inspect import class_names
 
 
 def _arg_identifier(arg):
     """
     Determine the type of the given argument.
 
     Parameters
@@ -18,47 +27,32 @@
     if isinstance(arg, type):
         return type
     return lambda v: v
 
 
 @dataclass
 class _Dispatcher:
-    """
-    A dispatcher that routes calls to different functions depending on the type of arguments.
-
-    Parameters
-    ----------
-    callable : `object`
-        A callable object for which a dispatcher is needed.
-    registry : `dict`, optional
-        A dictionary of functions mapped to specific argument types.
-    args : `tuple`, optional
-        A tuple of functions (argument type identifiers) for the dispatcher.
-    start_index : `int`, optional
-        An integer that defines the starting index of the method call.
-
-    Methods
-    -------
-    register(*specs)
-        Register a function with specific argument types.
-    """
-
     __callable: object
     __registry: dict = field(default_factory=dict)
     __args: tuple = None
     __start_index: int = 0
 
     def __post_init__(self):
         """
         Post-initialization method that sets the starting index for method calls
         if the callable object appears to be a method.
         """
         if "." in self.__callable.__qualname__ and self.__callable.__code__.co_argcount > 0:
             # This looks like a method.
             self.__start_index = 1
+        wraps(self.__callable)(self)
+
+    @property
+    def supported_types(self):
+        return list(self.__registry)
 
     def register(self, *specs):
         """
         Register a function for specific argument types.
 
         Parameters
         ----------
@@ -103,18 +97,29 @@
         Returns
         -------
         object
             Result of the function call.
         """
         # TODO: This code is ineffective and needs some extra magic to make it more performant.
         its_type = tuple(self.__args[i](args[i]) for i in range(len(self.__args)))
+        if its_type not in self.__registry:
+            prod_type = [t.__mro__[:-1] for t in its_type]
+            prods = set(product(*prod_type))
+            common = set(prods).intersection(self.__registry)
+
+            if len(common) > 1:
+                raise GimError(f"Multiple base class combinations: {class_names(common)}")
+
+            if not common:
+                return self.__callable(*args, **kwargs)
+
+            func = self.__registry[list(common)[0]]
+
+            for key in prods - common:
+                if object in key:
+                    continue
+                self.__registry[key] = func
+
         if self.__start_index:
             args = (self.__instance,) + args
-        try:
-            return self.__registry[its_type](*args, **kwargs)
-        except KeyError:
-            return self.__callable(*args, **kwargs)
-
-
-
 
-dispatch = _Dispatcher
+        return self.__registry[its_type](*args, **kwargs)
```

## _pygim/_magic/_gimmick.py

```diff
@@ -2,20 +2,22 @@
 '''
 This module implmements class gimmick.
 '''
 
 from traceback import format_stack
 from types import FunctionType
 
-from ._dispatcher import dispatch
+from ._dispatcher import _Dispatcher
 from ._patch import MutableFuncObject
-from .._utils import type_error_msg, flatten
+from .._utils import flatten
+from .._error_msgs import type_error_msg
 
 __all__ = ['gimmick']
 
+dispatch = _Dispatcher
 
 class GimTypeMeta(type):
     def __prepare__(*args):
         return dict(__pygim_traits__={})
 
     def __lshift__(self, other):
         print("thing")
@@ -175,14 +177,15 @@
     ...     def original(self):
     ...         return self.public
     ...
     >>> def new_method(self):
     ...     return self.public + 1
     ...
     >>> ExampleObject << new_method
+    <class '_pygim._magic._gimmick.ExampleObject'>
     >>> obj = ExampleObject()
     >>> obj.new_method()
     2
 
     Limitations
     -----------
     - The `gimmick` object is not compatible with classes that use metaclasses or have
```

## _pygim/_magic/_patch.py

```diff
@@ -8,15 +8,16 @@
 from abc import ABCMeta
 from dataclasses import dataclass
 import sys
 import types
 import inspect
 import types
 
-from .._utils import has_instances, format_dict, type_error_msg, TraitFunctions, is_subset
+from .._utils import has_instances, format_dict, TraitFunctions, is_subset
+from .._error_msgs import type_error_msg
 
 PY37, PY38, PY39, PY310, PY311 = (3, 7), (3, 8), (3, 9), (3, 10), (3, 11)
 ____ = _____ = ()
 
 _PY_CODE_ARGS = dict(
     argcount        = (PY37, PY38, PY39, PY310, PY311),
     posonlyargcount = (____, PY38, PY39, PY310, PY311),
```

## _pygim/_magic/_traits.py

```diff
@@ -3,18 +3,20 @@
 
 '''
 
 from types import FunctionType
 from dataclasses import dataclass, field
 import inspect
 
-from ._dispatcher import dispatch
+from ._dispatcher import _Dispatcher
 from ._patch import MutableFuncObject
-from .._utils import flatten, type_error_msg
+from .._utils import flatten
+from .._error_msgs import type_error_msg
 
+dispatch = _Dispatcher
 
 def transfer_ownership(target, *funcs):
     """ Transfer ownership of source object to target object.
 
     The point of transferring the ownership is to ensure that the
     target things it has belonged into that object right from the
     creation of the object. This is particularly useful with traits
```

## _pygim/_utils/__init__.py

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 '''
 Internal utilities package.
 '''
 
-from ._iterable import *
+from .._iterlib import *
 from ._inspect import *
 
 
 def format_dict(dct, *, indent=0):
     indention = " " * indent
     lines = [''] + [f"{indention}{key}={repr(value)}," for key, value in dct.items()] + ['']
     formatted_string = "\n".join(lines)
```

## _pygim/_utils/_inspect.py

```diff
@@ -1,144 +1,29 @@
 # -*- coding: utf-8 -*-
 '''
 Internal package for complaining functions.
 '''
 
+import inspect
 import types
-import tabulate
 
-__all__ = ('type_error_msg', 'TraitFunctions', 'has_instances', 'is_subset')
+from .._iterlib import flatten
 
-TraitFunctions = (types.FunctionType, types.MethodType)
-
-def type_error_msg(obj, expected_type):
-    """
-    Returns a formatted error message for a type error.
-
-    Parameters
-    ----------
-    obj : Any
-        The object that was found to have a type error.
-    expected_type : type or tuple of types
-        The expected type(s) of the object.
-
-    Returns
-    -------
-    str
-        The formatted error message.
-
-    Examples
-    --------
-    >>> type_error_msg(2, str)
-    "Expected to get type `str`, got `2 [int]`"
-    >>> type_error_msg([], (tuple, list))
-    "Expected to get type `(tuple,list)`, got `[] [list]`"
-    """
-    if isinstance(expected_type, tuple):
-        type_names = ",".join(f"`{t.__name__}`" for t in expected_type)
-        expected_type_name = "tuple"
-    else:
-        type_names = type(obj).__name__
-        expected_type_name = expected_type.__name__
-    return f"Expected to get type `{expected_type_name}`, got `{repr(obj)} [{type_names}]`"
-
-
-def diff(_left, _right):
-    """
-    Compare two dictionaries visualizing differences.
-
-    Parameters
-    ----------
-    _left : dict
-        A dictionary to be compared with `_right`.
-    _right : dict
-        A dictionary to be compared with `_left`.
-
-    Returns
-    -------
-    str
-        A table of differences between `_left` and `_right`, visualizing the keys and values that are missing or mismatched.
-
-    Notes
-    -----
-    This function returns a string representation of a table that shows the differences between two dictionaries.
-    It compares the keys of the dictionaries, and for each key present in either dictionary, it displays the
-    corresponding values side by side, highlighting any differences. If a key is present in one dictionary but not
-    the other, the corresponding value is replaced with "<<MISSING>>" in the table.
-
-    """
-    lines = []
-    for key in sorted(set(_right) | set(_left)):
-        try:
-            left = _right[key]
-        except KeyError:
-            left = "<<MISSING>>"
-
-        try:
-            right = _left[key]
-        except KeyError:
-            right = "<<MISSING>>"
+__all__ = ('TraitFunctions', 'has_instances', 'is_subset')
 
-        matching = "!=" if left != right else ""
-
-        lines.append((key, left, matching, right))
-    return tabulate.tabulate(lines)
+TraitFunctions = (types.FunctionType, types.MethodType)
 
 
 def has_instances(iterable, types, *, how=all):
-    """
-    Check if all or any items in an iterable are instances of a specified type.
-
-    Parameters
-    ----------
-    iterable : iterable
-        The iterable to check.
-    types : type or tuple of types
-        The expected type(s) of the items.
-    how : callable, optional
-        A callable that will be used to aggregate the results of the checks
-        (e.g. `all` to check if all items are instances of the specified type(s),
-        `any` to check if any items are instances of the specified type(s)).
-        Defaults to `all`.
-
-    Returns
-    -------
-    bool
-        True if all/any items in the iterable are instances of the specified type(s),
-        False otherwise.
-
-    Examples
-    --------
-    >>> has_instances([1,2,3], int)
-    True
-    >>> has_instances([1,2,'3'], int)
-    False
-    >>> has_instances([1,2,'3'], int, how=any)
-    True
-    """
     return how(isinstance(it, types) for it in iterable)
 
 
 def is_subset(iterable, other):
-    """
-    Check if an iterable is a subset of another iterable.
-
-    Parameters
-    ----------
-    iterable : iterable
-        The iterable to check.
-    other : iterable
-        The iterable to check against.
-
-    Returns
-    -------
-    bool
-        True if `iterable` is a subset of `other`, False otherwise.
-
-    Examples
-    --------
-    >>> is_subset([1, 2], [1, 2, 3])
-    True
-    >>> is_subset([1, 2, 3], [1, 2])
-    False
-    """
     return set(iterable).issubset(other)
+
+
+def class_names(*classes):
+    for cls in flatten(classes):
+        if inspect.isclass(cls):
+            yield cls.__name__
+        else:
+            yield cls.__class__.__name__
```

## pygim/__init__.py

```diff
@@ -1,22 +1,44 @@
 # -*- coding: utf-8 -*-
 """
 Python Gimmicks Library.
+
+This module provides various classes and functions for working with Python gimmicks.
+
+Classes
+-------
+gimmick.gimmick
+    This class is equivalent to Python's `object`. Inherit from this class to create gimmick objects.
+gimmick.gim_type
+    This class is equivalent to Python's `type`. It creates `gimmick` objects.
+entanged.EntangledClass
+    A class that can be shared and extended across modules.
+pathset.PathSet
+    A class to manage multiple Path objects.
+
+Functions
+---------
+dispatch.dispatch
+    A function that supersedes `singledispatch(method)`.
+iterlib.flatten(iterable)
+    Convert nested arrays into a single flat array.
+iterlib.is_container(obj)
+    Check whether an object is iterable but not a string or bytes.
+iterlib.split(iterable, condition)
+    Split an iterable into two iterables based on a condition function.
+
+Examples
+--------
+Example usage of `gimmick`:
+```python
+from pygim.gimmick import gimmick
+
+class MyGimmick(gimmick):
+    def __init__(self):
+        super().__init__()
+        # Additional initialization code
 """
 
 from .__version__ import __version__
 
 __author__ = "Teppo Perä"
 __email__ = "debith-dev@outlook.com"
-
-from .kernel import *
-from _pygim._magic._gimmick import gimmick, gim_type
-from _pygim._magic._dispatcher import dispatch
-
-__all__ = [
-    "gimmick",      # This is equivalent to Python's `object`. Inherit this!
-    "gim_type",     # This is equivalent to Python's `type`, creates `gimmick`s.
-    "dispatch",     # This is supercedes singledispatch(method).
-
-    "EntangledClass",  # A class that can be shared and extended across modules.
-    "PathSet",  # A class to manage multiple Path objects.
-]
```

## pygim/__version__.py

```diff
@@ -1,2 +1,2 @@
-__version_info__ = (0, 2, 0)
+__version_info__ = (0, 5, 0)
 __version__ = '.'.join(str(v) for v in __version_info__)
```

## pygim/utils/__init__.py

```diff
@@ -1,31 +1,20 @@
 # -*- coding: utf-8 -*-
 """
-This package contains various utilities.
+Utilities
+
+This module provides various utility functions for general-purpose tasks.
+
+Functions
+---------
+safedelattr(obj, attr_name)
+    Safely delete an attribute from an object, ignoring errors if the attribute is missing.
 
-NOTE: All the utilities here must be standalone, therefore never should
-      import any modules outside from this package.
 """
 
-from .performance import *
-from .persistence import *
-from .security import *
-from .misc import *
-from _pygim._utils import format_dict
-from _pygim._utils._iterable import split, flatten, is_container
-from _pygim._utils._inspect import has_instances, diff
+# Your module code goes here
+
+from .attributes import safedelattr
 
 __all__ = [
-    "decompress_and_unpickle",  # Decompress obj, unpickle it, while optionally read it from file.
-    "diff",                     # Compares two dictionaries and visually displays their differences.
-    "flatten",                  # Convert nested arrays in to a one flat array.
-    "format_dict",              # Function that formats dict in pretty way.
-    "has_instances",            # As `isinstance` but for objects inside iterable.
-    "is_container",             # Check whether object is iterable but not string or bytes.
-    "pickle_and_compress",      # Pickle object, compress it, and optionally write to file.
-    "quick_profile",            # Profile code inside `with`-statement.
-    "quick_timer",              # Calculate time spent inside code within ´with´-statement.
-    "safedelattr",              # Delete attribute, ignoring error when its missing.
-    "sha256sum",                # Provides sha256 for a any arguments.
-    "split",                    # Split iterable in two iterables based on condition function.
-    "write_bytes",              # Write bytes into a file, can ensure folder structure on write.
+    "safedelattr",
 ]
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## Comparing `_pygim/_utils/_iterable.py` & `_pygim/_iterlib.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 # -*- coding: utf-8 -*-
 """
 This module contains internal utility functions.
 """
 
+from pathlib import Path
+
 __all__ = ("split", "flatten", "is_container")
 
 
 def split(iterable, condition):
     """
     Split an iterable object into two lists based on a given condition.
 
@@ -31,15 +33,15 @@
 
     Examples
     --------
     >>> numbers = [1, 2, 3, 4, 5]
     >>> def is_even(n):
     ...     return n % 2 == 0
     ...
-    >>> even_numbers, odd_numbers = split_iterable(numbers, is_even)
+    >>> even_numbers, odd_numbers = split(numbers, is_even)
     >>> even_numbers
     [2, 4]
     >>> odd_numbers
     [1, 3, 5]
     """
     left = []
     right = []
@@ -49,78 +51,31 @@
             left.append(it)
         else:
             right.append(it)
 
     return left, right
 
 
-def is_container(obj):
-    """
-    Determine whether an object is a container.
+def tuplify(obj):
+    if isinstance(obj, dict):
+        return tuple((k, v) for k, v in obj.items())
+    if is_container(obj):
+        return tuple(list(obj))
+    return obj,
 
-    A container is considered an object that contains other objects. This
-    function returns `False` for strings, bytes, and types, even though they
-    implement the iterator protocol.
 
-    Parameters
-    ----------
-    obj : `object`
-        The object to check.
-
-    Returns
-    -------
-    `bool`
-        `True` if `obj` is a container, `False` otherwise.
-
-    Examples
-    --------
-    >>> is_container("text")
-    False
-
-    >>> is_container(tuple())
-    True
-    """
-    if isinstance(obj, (str, bytes, type)):
+def is_container(obj):
+    if isinstance(obj, (str, bytes, type, Path, memoryview)):
         return False
 
     if hasattr(obj, "__iter__"):
         return True
 
-    return isinstance(obj, memoryview)
+    return False
 
 
 def flatten(iterable):
-    """
-    Flatten a nested iterable into a single list.
-
-    This function flattens nested iterables such as lists, tuples, and sets
-    into a single list. It can handle deeply nested and irregular structures.
-
-    Parameters
-    ----------
-    iterable : `iterable`
-        The nested iterable to flatten.
-
-    Yields
-    ------
-    `object`
-        The flattened objects from the nested iterable.
-
-    Examples
-    --------
-    Flatten a list of lists:
-    >>> list(flatten([[1, 2], [3, 4]]))
-    [1, 2, 3, 4]
-
-    Flatten a deeply nested irregular list:
-    >>> list(flatten([[[1, 2]], [[[3]]], 4, 5, [[6, [7, 8]]]]))
-    [1, 2, 3, 4, 5, 6, 7, 8]
-
-    Flatten a list of strings:
-    >>> list(flatten(["one", "two", ["three", "four"]]))
-    ['one', 'two', 'three', 'four']
-    """
-    for subitem in iterable:
-        if is_container(subitem):
-            yield from flatten(subitem)
-        else:
-            yield subitem
+    if is_container(iterable):
+        for o in iterable:
+            yield from flatten(o)
+    else:
+        yield iterable
```

## Comparing `pygim/kernel/entangled_class.py` & `_pygim/_magic/_entangled.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,19 +1,15 @@
 # -*- coding: utf-8 -*-
 """
-This creates a shared class that can be extended
+Internal implementation of the magic behind EntangledClass.
 """
 
-from pygim import exceptions
 from collections.abc import Mapping, MutableMapping
-from _pygim._magic._cached_type import CachedTypeMeta
-
-
-__all__ = ["EntangledClass", "overrideable", "overrides"]
-
+from _pygim._exceptions import EntangledClassError, EntangledMethodError
+from ._cached_type import CachedTypeMeta
 
 def setdefaultattr(obj, name, default):
     """ Sets attribute to object in case it is missing. """
     if isinstance(obj, property):
         obj = obj.fget
 
     if hasattr(obj, name):
@@ -98,15 +94,15 @@
 
         common = set(new_namespace).intersection(old_newspace)
         allowed = set(["__module__", "overrides", "overrideable", _NAMESPACE_KEY, _ABSTRACT_ATTR])
         overriding = set(f for f in common if _can_override(f, new_namespace, old_newspace))
         unhandled = common - allowed - overriding
 
         if unhandled:
-            raise exceptions.EntangledMethodError(f"Can't override following names: {','.join(unhandled)}")
+            raise EntangledMethodError(f"Can't override following names: {','.join(unhandled)}")
 
         return overriding
 
     def __call__(self, _class_name, _bases, _namespace):
         """Create a new class or find existing from the namespaces."""
         assert isinstance(_class_name, str)
         assert isinstance(_bases, tuple)
@@ -179,15 +175,9 @@
             )
 
         return EntangledClass
 
     def __call__(self, *args, **kwds):
         """Create instance of the EntangledClass, ensuring only subclasses can be created."""
         if getattr(self, _ABSTRACT_ATTR):
-            raise exceptions.EntangledClassError("EntangledClass is abstract class, so please use inheritance!")
+            raise EntangledClassError("EntangledClass is abstract class, so please use inheritance!")
         return super().__call__(*args, **kwds)
-
-
-class EntangledClass(metaclass=EntangledClassMeta):
-    """Helper class to create an entangled class using inheritance."""
-
-    __slots__ = ()
```

## Comparing `pygim/kernel/pathset.py` & `pygim/fileio/pathset.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,27 +3,18 @@
 This module contains implementation of PathSet class.
 """
 
 import shutil
 from pathlib import Path
 from dataclasses import dataclass
 
-from pygim.utils import is_container, flatten
+from pygim.iterlib import is_container
+from _pygim._utils._fileutils import flatten_paths
 
-
-def _flatten_paths(paths):
-    for path in flatten(paths):
-        path = Path(path)
-
-        if path.is_dir():
-            yield path
-            for p in _flatten_paths(path.glob("*")):
-                yield p
-        else:
-            yield path
+__all__ = ["PathSet"]
 
 
 class _FileSystemOps:
     """Functionality to manipulate the filesystem."""
 
     def __get__(self, __instance, _):
         self.__pathset = __instance
@@ -41,48 +32,69 @@
         for p in self.__pathset:
             self.delete(p)
 
 
 @dataclass(frozen=True)
 class PathSet:
     """
-    This class encapsulates manipulation of multiple path objects at once.
-
-    Overview (further info in function docs):
-        - len(PathSet()) provides the total number of files and directories read recursively.
-        - list(PathSet()) provides a list of all Path objects in the list.
-        - bool(PathSet()) tells whether there are any Path objects in the list.
-        - repr(PathSet()) provides a nice string representation of this object.
-        - PathSet.prefixed() creates a new PathSet with another path as a prefix (e.g., folder+files).
-        - PathSet() + PathSet() creates a new object containing Path objects from both sets.
-        - PathSet().clone() creates an identical copy of the list.
-        - PathSet().filter() generator that yields Path objects whose properties match the filters.
-        - PathSet().drop() generator that yields Path objects whose properties do NOT match the filters.
-        - PathSet().filtered() as above, but returns a new PathSet object.
-        - PathSet().dirs() a shorthand for a list of directories.
-        - PathSet().files() a shorthand for a list of files.
-        - PathSet().by_suffix() a shorthand for filtering by suffix(es).
-        - PathSet().delete_all() deletes all contained Path objects from the file system.
+    A class for manipulating multiple Path objects at once.
 
+    Methods
+    -------
+    prefixed(paths: iterable, *, prefix : str) -> PathSet
+        Returns a new PathSet with `prefix` added to each path.
+    clone() -> PathSet
+        Returns a new PathSet that is a copy of this one.
+    filter(filter : callable) -> Generator
+        Yields paths from this set that pass a filter function.
+    drop(filter : callable) -> Generator
+        Yields paths from this set that do not pass a filter function.
+    filtered(filter : callable) -> PathSet
+        Returns a new PathSet of paths from this set that pass a filter function.
+    dirs() -> List
+        Returns a list of directories in this set.
+    files() -> List
+        Returns a list of files in this set.
+    by_suffix(suffix : str) -> PathSet
+        Returns a new PathSet of paths from this set with a given suffix.
+    FS.delete_all() -> None
+        Deletes all paths in this set from the file system.
+    transform(container_type : type = list, path_type : type = str) -> container_type
+        Returns a new container of `container_type` with elements of `path_type`.
+
+    Examples
+    --------
+    >>> paths = PathSet([Path('path1'), Path('path2')])
+    >>> len(paths)
+    2
+    >>> bool(paths)
+    True
+    >>> [p.stem for p in sorted(paths)]
+    ['path1', 'path2']
+    >>> repr(paths)
+    "PathSet(['path1', 'path2'])"
+    >>> paths.prefixed(["file1.txt", "file2.txt"], prefix="/root_folder")
+    PathSet(['/root_folder/file1.txt', '/root_folder/file2.txt'])
     """
+
     # TODO: This class could allow multiple different path types (not just pathlib.Path).
     _paths: Path = None  # type: ignore    # this is invariant
     _pattern: str = "*"
     FS = _FileSystemOps()  # File system
 
     def __post_init__(self):
         paths = self._paths
 
         if paths is None:
             paths = Path.cwd()
 
         # We just handled the optional part, let's make mypy happy.
         assert paths is not None
 
-        super().__setattr__("_paths", frozenset(_flatten_paths([paths])))
+        super().__setattr__("_paths", frozenset(flatten_paths(paths, pattern=self._pattern)))
         assert all([isinstance(p, Path) for p in self._paths])
         assert isinstance(self._paths, frozenset)
 
     @classmethod
     def prefixed(cls, paths, *, prefix=None):
         """
         Create a new PathSet object with a specified prefix for each path.
@@ -95,14 +107,16 @@
             The prefix to add to each path in the input `paths`. Defaults to the current working directory.
 
         Returns
         -------
         PathSet
             New PathSet object with the specified prefix for each path.
         """
+        assert is_container(paths), f"Paths must be a container, not {type(paths)}."
+
         if prefix is None:
             prefix = Path.cwd()
         prefix = Path(prefix)  # Ensure path-like object is Path.
 
         return cls([prefix.joinpath(p) for p in paths])
 
     def __len__(self):
@@ -115,15 +129,15 @@
 
     def __bool__(self):
         assert self._paths is not None
         return bool(self._paths)
 
     def __repr__(self):  # pragma: no cover
         assert self._paths is not None
-        return f"{self.__class__.__name__}({list(str(p) for p in self._paths)})"
+        return f"{self.__class__.__name__}({sorted(str(p) for p in self._paths)})"
 
     def clone(self, paths=None):
         """
         Create a copy of the object.
 
         Parameters
         ----------
@@ -262,12 +276,46 @@
         return self.filtered(suffix=suffix)
 
     def __add__(self, other):
         """Combine paths together."""
         assert isinstance(other, self.__class__)
         return self.clone(set(self._paths) | set(other._paths))
 
+    def transform(self, container_type=list, path_type=str):
+        """
+        Transform the container and elements of the instance to specified types.
+
+        This function transforms the elements of the instance using the
+        `path_type` argument, and then packs them into a new container
+        specified by the `container_type` argument.
+
+        Parameters
+        ----------
+        container_type : type, optional
+            The type of the output container (default is `list`). This should
+            be a type (like `list` or `set`), not an instance of a type (like `[]` or `{}`).
+        path_type : type, optional
+            The type to convert each path in the instance (default is `str`).
+            This should be a callable that takes a path as input and returns
+            a new path of the desired type.
+
+        Returns
+        -------
+        container_type
+            The container filled with `path_type` objects.
+
+        Examples
+        --------
+        Given a class `PathSet` that holds a list of `Path` objects:
+
+        >>> paths = PathSet([Path('path1'), Path('path2')])
+        >>> transformed = paths.transform(container_type=set, path_type=str)
+        >>> print(sorted(transformed))
+        ['path1', 'path2']
+        """
+        return container_type(path_type(p) for p in self)
+
 
 if __name__ == "__main__":
     import doctest
 
     doctest.testmod()
```

## Comparing `pygim/typing.py` & `_pygim/typing.py`

 * *Files identical despite different names*

## Comparing `pygim/utils/performance.py` & `pygim/performance/timing_and_profiling.py`

 * *Files 5% similar despite different names*

```diff
@@ -3,21 +3,20 @@
 This module contains utilities to get profiling quickly.
 """
 
 from contextlib import contextmanager
 import cProfile
 import pstats
 import time
-import pygim.typing as t
 
 __all__ = ("quick_timer", "quick_profile")
 
 
 @contextmanager
-def quick_timer(title: str = "Code block", *, printer=print):
+def quick_timer(title = "Code block", *, printer=print):
     """
     Measure the execution time of a code block using a context manager.
 
     Parameters:
     -----------
     title : `str`, optional
         The title to display when printing the execution time. Default is "Code block".
```

## Comparing `pygim/utils/persistence.py` & `pygim/fileio/fileops.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,16 +3,14 @@
 Useful tools to write something into disk.
 """
 
 import pathlib
 import gzip
 import pickle
 
-import pygim.typing as t
-
 __all__ = ("write_bytes", "pickle_and_compress", "decompress_and_unpickle")
 
 
 def _drop_file_suffixes(p):
     while p.suffixes:
         p = p.with_suffix("")
     return p
```

## Comparing `pygim/utils/testing.py` & `pygim/testing/testing.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 """
 This module contains script to run coverage for specific module.
 """
 
 import sys
 from importlib import reload
 from contextlib import contextmanager
-import coverage
 import pytest
 
 __all__ = ["measure_coverage", "run_tests"]
 
 
 @contextmanager
 def measure_coverage(*, include=None, show_missing: bool = True):
@@ -19,14 +18,18 @@
     Parameters
     ----------
     include : bool, optional
         File to be included in the coverage report. If None, all shown.
     show_missing : bool, optional
         True, if coverage report should include lines that were not run.
     """
+    # FIXME: Running pytest fails, when `coverage` module is being imported.
+    #        The error appears to be originating from os.getcwd(), which
+    #        indicates that some folder is interpreted as current is deleted.
+    import coverage
     cov = coverage.Coverage()
     cov.start()
 
     yield
 
     cov.stop()
     cov.save()
```

## Comparing `pygim_common-0.2.0.dist-info/RECORD` & `pygim_common-0.5.0.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,50 +1,41 @@
 _pygim/__init__.py,sha256=jKfsQqKF_ii4RX3ZBHxGLBppqxH8C3FedJpBWLrQqSc,66
-_pygim/_cli/__init__.py,sha256=gV90JRktAGbcthzPK1XMs1Bd0v8OIZ3193ZxZp-i2fk,139
-_pygim/_cli/__init__.pyi,sha256=NBz_qb0qj89auWo2smjGuRNTuijURrk57rsNBPU-8tM,45
-_pygim/_cli/cliapp.py,sha256=FpfQfxrkOKDFqqv2Wi9bh_j18GXKYfucwZRl_FUIJyc,1492
-_pygim/_cli/support.py,sha256=wCIdDCB_N8DynUsl4aVGULdTjuVJUBrca70WoNUgeIA,209
+_pygim/_error_msgs.py,sha256=dyxUfqCwB38TN21rlE9o4ZYIefJn4X_Trq9Fr6J0enU,1040
+_pygim/_exceptions.py,sha256=09UZkrfjV-4VEZYznCFF7sKx94_NG22WMc0bGWMJwPU,565
+_pygim/_iterlib.py,sha256=rXW2z4HQVme574AGYAnktrd0wsKqDhemqddDKncbJFU,1828
+_pygim/typing.py,sha256=sZ9nUmmeVfabwcs8pMlIxaufPimkYLbkfZyzhwhVs-4,1241
 _pygim/_magic/__init__.py,sha256=v8SRP8vg6BNNOeoIFEUBPCLX9_PiwfpKmu2IvCKJ_OE,102
-_pygim/_magic/_cached_type.py,sha256=A1fxc01nGCS6FTo0KugVHF4_78UFMeuea2H5_2PwV2o,5128
-_pygim/_magic/_dispatcher.py,sha256=nbvLXW1xUUn3FIFqsRy5IqfeX7OcRdvV078NPogiSh4,3461
-_pygim/_magic/_gimmick.py,sha256=qfYUzPmOa69n8gPdihgo2tZReVe6cSbzElZTSX3FSos,6673
-_pygim/_magic/_patch.py,sha256=EI-BDdEUNGtVQLDOXmcIpYCtep83tW-h_xtJVrygNKY,7985
+_pygim/_magic/_cached_type.py,sha256=4NaeBqROD-FMW6Y5Zn6_NM_2yZHzUCnanFUv7wct2SI,5102
+_pygim/_magic/_dispatcher.py,sha256=whxvmGnROIx_RiAdJ9GsZhqI_QLguj3Qx4H6knH_7Qw,3649
+_pygim/_magic/_entangled.py,sha256=-4QkDbKjEfKITAXOspc4r0JlKb7PYkKitT5V-pVFHjo,6549
+_pygim/_magic/_gimmick.py,sha256=TprexGh3ofN95uiyJwGBPLHfrony0VOjDWV5T26zRxE,6775
+_pygim/_magic/_patch.py,sha256=VLuEegfKzgVXaUkuVJRt6gY7dgT5a366yI-yZhBnlCU,8010
 _pygim/_magic/_support.py,sha256=GRMKWwBhi-bc_gwL33OdfyXBNSUfsVzVC6g_8YeidAk,284
-_pygim/_magic/_traits.py,sha256=m4LfcuG_--hPwRUaIWXzhsJhjil_RDIg4PiHJrYokZQ,1931
-_pygim/_utils/__init__.py,sha256=hjSwAjTZ7snvS5MKFSoVJXbvsBI9NV9cE5VrgfMwvR0,337
-_pygim/_utils/_inspect.py,sha256=CqetNhIRreUTDoUtCAFUBqNbZjvayLs5jbjs176_DHQ,3933
-_pygim/_utils/_iterable.py,sha256=_b8XjmuoxoBCbZVosNpHaF4Uq4jzh10TeET0wAFWDqY,2975
-pygim/__init__.py,sha256=QS_2ojmXarBTIf6M8tAUw__1MLYD0P8_oXKuPij7Uuw,662
-pygim/__init__.pyi,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pygim/__main__.py,sha256=m_bigByNz-iGWka64OenaDTgyAcGb4fe8MYgT7iHkps,1087
-pygim/__main__.pyi,sha256=h2NuJrWnaiRaUW6eMqOx9PRkmZdAVDF9Oc5aun84z1E,215
-pygim/__version__.py,sha256=jzmD60gGPC766WLMrnK0qKXx9_2FTKCjTY3c1PMSdtI,85
-pygim/exceptions.py,sha256=3WDbppO8PPp3zsLfCzQkIMVMGgzzSleay_2JgT8nM9c,450
-pygim/exceptions.pyi,sha256=BFSURjDp_cbgrbUxJbUCjd0NRrbUjDWacri3ISsXGGU,161
-pygim/kernel/__init__.py,sha256=gKJc5vcXzqLeLXMy8LnRzQX5ViPJNeShG3IJiSZk9-c,78
-pygim/kernel/__init__.pyi,sha256=EjB29FWDePAtFZ1plQFiZdQq9hdOyFuYd5_YlHh55cc,75
-pygim/kernel/entangled_class.py,sha256=cnm7GfyEOU_EbQafZuuXLlFfm30cfAZO3UasXc2lkrg,6735
-pygim/kernel/entangled_class.pyi,sha256=lX2jSgWG10QA71nP_iykoriF-CjeaVgkmOFGgfmzjS0,780
-pygim/kernel/magic/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-pygim/kernel/magic/cached_type.pyi,sha256=rDUZO7qZMAFzFIU5WpspaQiZZMCU2OyFpvpP7_aSOw8,1319
-pygim/kernel/magic/support.pyi,sha256=lxWs7vDgA7R9YrqrIB9u8sqa8LQ2QZFsvN3UsLLNDow,224
-pygim/kernel/pathset.py,sha256=QDZ41RAcuBnWaop4qQjlqXbSATtkMbvbd_xO4f1sQJY,9973
-pygim/kernel/pathset.pyi,sha256=rcNWXx74Z8Sj4Jus9X8f41P2XYGnZzdFxhKjThrObvQ,1506
-pygim/kernel/traits.py,sha256=dmN0ymvKyhPsevEMXRLNgKTUuUv02EwqUY9yoVyQqxY,109
-pygim/typing.py,sha256=sZ9nUmmeVfabwcs8pMlIxaufPimkYLbkfZyzhwhVs-4,1241
-pygim/utils/__init__.py,sha256=nHc84WlUlzXFyh-RlzgrOdRgrZSwPngxiA4b_VeTLS0,1607
-pygim/utils/__init__.pyi,sha256=6JBnQw0bL3npqOaquuqe7tI2ySE9ygruw9NISFZulRU,297
-pygim/utils/iterable.pyi,sha256=O6WdBJW25Ivd3FEJVUPHSmh5MRcVkLnerO1uOCI5ksk,290
-pygim/utils/misc.py,sha256=7iBlQFoXq4u-40u9BFKSgmX31LVPxlLNi36VFDyfyC4,513
-pygim/utils/misc.pyi,sha256=_SWeQrUT79n7Om7rWCe2hysdmDrf9Kh-f-o3Zvtsp-U,81
-pygim/utils/performance.py,sha256=L6eIwkJzW34fpDu32_ctjM-kIQF5_zFj5R0k_AMBZAw,2385
-pygim/utils/performance.pyi,sha256=1nrbgXRy3CFKKQwoa9FXTQNotffyg1NnpEsSJLqob_4,256
-pygim/utils/persistence.py,sha256=4CLSg8HOIVZjbbFasqeEX3LFMckmkSUjhF6psNocQw0,3954
-pygim/utils/persistence.pyi,sha256=LqFdyHhyRem8kO54A1o11xMMo1RdFqTtOsvoHLL-_SQ,374
-pygim/utils/security.py,sha256=Aves3sDmuBu28zYP2qFdRHfACDsnBD1Q0uGTIFXJmA4,1175
-pygim/utils/security.pyi,sha256=6GHqwXooyIgKhXdYmnpfoK5T9_hzancfFFCc7RWj4Fs,112
-pygim/utils/testing.py,sha256=yD-sjsdmeq2B7eUvxCyXyEOw07cK4KmedctAtClu_78,2448
-pygim/utils/testing.pyi,sha256=1b10LG3_gv7WjCju8NTjdMSQh7FVADy46a6fiv5AHGI,334
-pygim_common-0.2.0.dist-info/METADATA,sha256=GfFdudGXiuDDH9I3AJv5YAN_I18WVTsns_Uws8IWHwQ,2160
-pygim_common-0.2.0.dist-info/WHEEL,sha256=B19PGBCYhWaz2p_UjAoRVh767nYQfk14Sn4TpIZ-nfU,87
-pygim_common-0.2.0.dist-info/entry_points.txt,sha256=_FtsIDeAPuH_mZwHkY3bQ0NKDk5b9VpFWyC2C35xq1U,44
-pygim_common-0.2.0.dist-info/RECORD,,
+_pygim/_magic/_traits.py,sha256=kEHHT7OrNfxiBtH837r0fNiV5KaGhDcL7xRoQ0U4zbk,1982
+_pygim/_magic/traits.py,sha256=dmN0ymvKyhPsevEMXRLNgKTUuUv02EwqUY9yoVyQqxY,109
+_pygim/_utils/__init__.py,sha256=cYEIKNrXzbC7il1B0VNc2TnbawrwMoqcs7U-mqvwf7U,337
+_pygim/_utils/_fileutils.py,sha256=AAWLXUso5Yp8QArqJkUMEh-vJTnIW088emTW5UhVGF0,374
+_pygim/_utils/_inspect.py,sha256=x6ltlywaHNdexiQTEzw7INqFcdQEA_wMkAgIP0fqM4s,617
+pygim/__init__.py,sha256=-TcrFkOue9MuMg_zlc5o5EB8SLpQwuw93o8WJqJV788,1206
+pygim/__version__.py,sha256=JuPB_5Ps8wS3J97RugzpRA6wJnkUJH2CeNHBpTNgJy4,85
+pygim/checklib.py,sha256=o1OpzNpXcfw3HB6bRbkEnNzgP5zGAfcsDVI9-5-kIOE,1821
+pygim/explib.py,sha256=B7br3puSZKSQ_iizax2R7Ws5DKjHfYL19cM1I0VK3R4,411
+pygim/iterlib.py,sha256=XTeeuVvTHM6JN1S2t0xn8oD_oG9FSXezl9UZ_HvCJnw,560
+pygim/fileio/__init__.py,sha256=jxzVIgxDcrFR1o5ssnsW9GQlT8Yew-tg0fR6IVp9y1Q,654
+pygim/fileio/fileops.py,sha256=Kp_z0JoPYjp1hh2oeRhWwUXK2ivSvMh76JT89X4Zg0I,3928
+pygim/fileio/pathset.py,sha256=5Cv_WLaM724bWIF8jxpatKi3zc6hMdklbr597PlyME0,11471
+pygim/gimmicks/__init__.py,sha256=0Gl18Pu7NITKmV_cVKi0711R-9MS1TgvO5HMtEUOzsg,935
+pygim/gimmicks/entangled.py,sha256=LFSU2ZwMtvrTDtYHfuktDEc8QFc4f8dBVCbSRrPnWEg,368
+pygim/performance/__init__.py,sha256=_dyYgiJUXJEc2ax-d3LUvohh1RRWmyW7kJm7VUmklyw,553
+pygim/performance/dispatch.py,sha256=UXUcYwMV7v2MxC4Br4YCnv-7TNkHjNYbfCl_GrepUIQ,840
+pygim/performance/timing_and_profiling.py,sha256=CtKrUYuhpQFM4berzNVNif77nCc-9uTx3Qi3ehj2i-8,2355
+pygim/security/__init__.py,sha256=kJu0ZgFN93GX5qYXzULFplWalXrtxEktvyK7-fC2CKQ,257
+pygim/security/shasum.py,sha256=y0iSNhAUHMazj0s_SSwQc2_FReixPM2Pi7vdcJQoAOE,3217
+pygim/testing/__init__.py,sha256=aAJXo4OhrW63hR2y2UyLPidSy4CrFV0yok_Q4cJbFHs,478
+pygim/testing/diff.py,sha256=-8YPWUwcBqFQeauCIEJ9kgWU-GBXFARHTKUNKRxbS1E,2713
+pygim/testing/testing.py,sha256=0hHMJLc-w5JcdKLCulFFmD42sc0C2pM8d90WtgSsJI4,2680
+pygim/utils/__init__.py,sha256=Z3uR8SxZls21bDJWG2rdQoYUNlu7LpuUHNAUWqaEcvY,360
+pygim/utils/attributes.py,sha256=13zpTAuU0bhxP2ZiZ7DHWxcSPMt-hSgCiQ4vCI2G1o8,511
+pygim_common-0.5.0.dist-info/METADATA,sha256=Nkt8hypxuaduneoXWBsayn6Oe6y-kctF25YgC3X9wJY,1007
+pygim_common-0.5.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+pygim_common-0.5.0.dist-info/top_level.txt,sha256=wTo-EmYqVTzVmoEUDavK4Uhkjcr2HoTs_NUMS_cCcjQ,13
+pygim_common-0.5.0.dist-info/RECORD,,
```

