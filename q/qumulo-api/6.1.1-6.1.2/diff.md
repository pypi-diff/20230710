# Comparing `tmp/qumulo_api-6.1.1-py3-none-any.whl.zip` & `tmp/qumulo_api-6.1.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,109 +1,109 @@
-Zip file size: 254717 bytes, number of entries: 107
--rw-r--r--  2.0 unx       22 b- defN 23-May-16 05:43 qumulo/__init__.py
--rw-r--r--  2.0 unx    11049 b- defN 23-May-16 05:43 qumulo/rest_client.py
--rw-r--r--  2.0 unx     5463 b- defN 23-May-16 05:43 qumulo/retry.py
--rw-r--r--  2.0 unx     1178 b- defN 23-May-16 05:43 qumulo/commands/__init__.py
--rw-r--r--  2.0 unx     7430 b- defN 23-May-16 05:43 qumulo/commands/access_tokens.py
--rw-r--r--  2.0 unx    16853 b- defN 23-May-16 05:43 qumulo/commands/ad.py
--rw-r--r--  2.0 unx     5048 b- defN 23-May-16 05:43 qumulo/commands/analytics.py
--rw-r--r--  2.0 unx     6531 b- defN 23-May-16 05:43 qumulo/commands/audit.py
--rw-r--r--  2.0 unx    35605 b- defN 23-May-16 05:43 qumulo/commands/auth.py
--rw-r--r--  2.0 unx     1045 b- defN 23-May-16 05:43 qumulo/commands/checksumming.py
--rw-r--r--  2.0 unx    18172 b- defN 23-May-16 05:43 qumulo/commands/cluster.py
--rw-r--r--  2.0 unx     4605 b- defN 23-May-16 05:43 qumulo/commands/dns.py
--rw-r--r--  2.0 unx     1506 b- defN 23-May-16 05:43 qumulo/commands/encryption.py
--rw-r--r--  2.0 unx     2843 b- defN 23-May-16 05:43 qumulo/commands/file_permissions_help.py
--rw-r--r--  2.0 unx   129900 b- defN 23-May-16 05:43 qumulo/commands/fs.py
--rw-r--r--  2.0 unx     3933 b- defN 23-May-16 05:43 qumulo/commands/ftp.py
--rw-r--r--  2.0 unx     3596 b- defN 23-May-16 05:43 qumulo/commands/kerberos.py
--rw-r--r--  2.0 unx    18150 b- defN 23-May-16 05:43 qumulo/commands/key_store.py
--rw-r--r--  2.0 unx    12310 b- defN 23-May-16 05:43 qumulo/commands/ldap.py
--rw-r--r--  2.0 unx     6846 b- defN 23-May-16 05:43 qumulo/commands/login.py
--rw-r--r--  2.0 unx     1070 b- defN 23-May-16 05:43 qumulo/commands/metrics.py
--rw-r--r--  2.0 unx    16823 b- defN 23-May-16 05:43 qumulo/commands/multitenancy.py
--rw-r--r--  2.0 unx     9981 b- defN 23-May-16 05:43 qumulo/commands/multitenancy_nfs.py
--rw-r--r--  2.0 unx     8845 b- defN 23-May-16 05:43 qumulo/commands/multitenancy_smb.py
--rw-r--r--  2.0 unx    20655 b- defN 23-May-16 05:43 qumulo/commands/network.py
--rw-r--r--  2.0 unx    34897 b- defN 23-May-16 05:43 qumulo/commands/nfs.py
--rw-r--r--  2.0 unx     1015 b- defN 23-May-16 05:43 qumulo/commands/node_state.py
--rw-r--r--  2.0 unx    10630 b- defN 23-May-16 05:43 qumulo/commands/object_replication.py
--rw-r--r--  2.0 unx     6173 b- defN 23-May-16 05:43 qumulo/commands/quota.py
--rw-r--r--  2.0 unx     2531 b- defN 23-May-16 05:43 qumulo/commands/raw.py
--rw-r--r--  2.0 unx    35414 b- defN 23-May-16 05:43 qumulo/commands/replication.py
--rw-r--r--  2.0 unx    14355 b- defN 23-May-16 05:43 qumulo/commands/roles.py
--rw-r--r--  2.0 unx    15644 b- defN 23-May-16 05:43 qumulo/commands/s3.py
--rw-r--r--  2.0 unx     5323 b- defN 23-May-16 05:43 qumulo/commands/saml.py
--rw-r--r--  2.0 unx     3259 b- defN 23-May-16 05:43 qumulo/commands/shutdown.py
--rw-r--r--  2.0 unx    52180 b- defN 23-May-16 05:43 qumulo/commands/smb.py
--rw-r--r--  2.0 unx    44057 b- defN 23-May-16 05:43 qumulo/commands/snapshot.py
--rw-r--r--  2.0 unx     7403 b- defN 23-May-16 05:43 qumulo/commands/support.py
--rw-r--r--  2.0 unx     2935 b- defN 23-May-16 05:43 qumulo/commands/time_config.py
--rw-r--r--  2.0 unx     4604 b- defN 23-May-16 05:43 qumulo/commands/tree_delete.py
--rw-r--r--  2.0 unx     1403 b- defN 23-May-16 05:43 qumulo/commands/unconfigured_node_operations.py
--rw-r--r--  2.0 unx    22129 b- defN 23-May-16 05:43 qumulo/commands/upgrade.py
--rw-r--r--  2.0 unx      976 b- defN 23-May-16 05:43 qumulo/commands/version.py
--rw-r--r--  2.0 unx     7374 b- defN 23-May-16 05:43 qumulo/commands/web_ui.py
--rw-r--r--  2.0 unx      669 b- defN 23-May-16 05:43 qumulo/lib/__init__.py
--rw-r--r--  2.0 unx    12849 b- defN 23-May-16 05:43 qumulo/lib/acl_util.py
--rw-r--r--  2.0 unx     4047 b- defN 23-May-16 05:43 qumulo/lib/auth.py
--rw-r--r--  2.0 unx     1833 b- defN 23-May-16 05:43 qumulo/lib/duration.py
--rw-r--r--  2.0 unx    11107 b- defN 23-May-16 05:43 qumulo/lib/identity_util.py
--rw-r--r--  2.0 unx     3551 b- defN 23-May-16 05:43 qumulo/lib/keys.py
--rw-r--r--  2.0 unx     2230 b- defN 23-May-16 05:43 qumulo/lib/obj.py
--rw-r--r--  2.0 unx     8901 b- defN 23-May-16 05:43 qumulo/lib/opts.py
--rw-r--r--  2.0 unx     6063 b- defN 23-May-16 05:43 qumulo/lib/qq.py
--rw-r--r--  2.0 unx    25203 b- defN 23-May-16 05:43 qumulo/lib/request.py
--rw-r--r--  2.0 unx     1058 b- defN 23-May-16 05:43 qumulo/lib/rest_util.py
--rw-r--r--  2.0 unx      926 b- defN 23-May-16 05:43 qumulo/lib/rfc3339.py
--rw-r--r--  2.0 unx     2009 b- defN 23-May-16 05:43 qumulo/lib/tenant.py
--rw-r--r--  2.0 unx     3350 b- defN 23-May-16 05:43 qumulo/lib/uri.py
--rw-r--r--  2.0 unx    14792 b- defN 23-May-16 05:43 qumulo/lib/util.py
--rw-r--r--  2.0 unx     1167 b- defN 23-May-16 05:43 qumulo/rest/__init__.py
--rw-r--r--  2.0 unx     4501 b- defN 23-May-16 05:43 qumulo/rest/access_tokens.py
--rw-r--r--  2.0 unx     7046 b- defN 23-May-16 05:43 qumulo/rest/ad.py
--rw-r--r--  2.0 unx     2204 b- defN 23-May-16 05:43 qumulo/rest/analytics.py
--rw-r--r--  2.0 unx     5909 b- defN 23-May-16 05:43 qumulo/rest/audit.py
--rw-r--r--  2.0 unx     8419 b- defN 23-May-16 05:43 qumulo/rest/auth.py
--rw-r--r--  2.0 unx      914 b- defN 23-May-16 05:43 qumulo/rest/checksumming.py
--rw-r--r--  2.0 unx     8793 b- defN 23-May-16 05:43 qumulo/rest/cluster.py
--rw-r--r--  2.0 unx     3056 b- defN 23-May-16 05:43 qumulo/rest/dns.py
--rw-r--r--  2.0 unx     1148 b- defN 23-May-16 05:43 qumulo/rest/encryption.py
--rw-r--r--  2.0 unx    49583 b- defN 23-May-16 05:43 qumulo/rest/fs.py
--rw-r--r--  2.0 unx     4531 b- defN 23-May-16 05:43 qumulo/rest/ftp.py
--rw-r--r--  2.0 unx     4410 b- defN 23-May-16 05:43 qumulo/rest/groups.py
--rw-r--r--  2.0 unx     2897 b- defN 23-May-16 05:43 qumulo/rest/kerberos.py
--rw-r--r--  2.0 unx     4490 b- defN 23-May-16 05:43 qumulo/rest/ldap.py
--rw-r--r--  2.0 unx     1251 b- defN 23-May-16 05:43 qumulo/rest/metrics.py
--rw-r--r--  2.0 unx     4909 b- defN 23-May-16 05:43 qumulo/rest/multitenancy.py
--rw-r--r--  2.0 unx     5260 b- defN 23-May-16 05:43 qumulo/rest/multitenancy_nfs.py
--rw-r--r--  2.0 unx     3616 b- defN 23-May-16 05:43 qumulo/rest/multitenancy_smb.py
--rw-r--r--  2.0 unx     8417 b- defN 23-May-16 05:43 qumulo/rest/network.py
--rw-r--r--  2.0 unx     8467 b- defN 23-May-16 05:43 qumulo/rest/nfs.py
--rw-r--r--  2.0 unx      910 b- defN 23-May-16 05:43 qumulo/rest/node_state.py
--rw-r--r--  2.0 unx     4468 b- defN 23-May-16 05:43 qumulo/rest/object_replication.py
--rw-r--r--  2.0 unx     3426 b- defN 23-May-16 05:43 qumulo/rest/quota.py
--rw-r--r--  2.0 unx    11002 b- defN 23-May-16 05:43 qumulo/rest/replication.py
--rw-r--r--  2.0 unx     6628 b- defN 23-May-16 05:43 qumulo/rest/roles.py
--rw-r--r--  2.0 unx     9857 b- defN 23-May-16 05:43 qumulo/rest/s3.py
--rw-r--r--  2.0 unx     2687 b- defN 23-May-16 05:43 qumulo/rest/saml.py
--rw-r--r--  2.0 unx     1944 b- defN 23-May-16 05:43 qumulo/rest/shutdown.py
--rw-r--r--  2.0 unx    11128 b- defN 23-May-16 05:43 qumulo/rest/smb.py
--rw-r--r--  2.0 unx    12759 b- defN 23-May-16 05:43 qumulo/rest/snapshot.py
--rw-r--r--  2.0 unx     3265 b- defN 23-May-16 05:43 qumulo/rest/support.py
--rw-r--r--  2.0 unx     1972 b- defN 23-May-16 05:43 qumulo/rest/time_config.py
--rw-r--r--  2.0 unx     2706 b- defN 23-May-16 05:43 qumulo/rest/tree_delete.py
--rw-r--r--  2.0 unx     1780 b- defN 23-May-16 05:43 qumulo/rest/unconfigured_node_operations.py
--rw-r--r--  2.0 unx     1960 b- defN 23-May-16 05:43 qumulo/rest/upgrade.py
--rw-r--r--  2.0 unx     2968 b- defN 23-May-16 05:43 qumulo/rest/upgrade_v2.py
--rw-r--r--  2.0 unx     1234 b- defN 23-May-16 05:43 qumulo/rest/upgrade_v3.py
--rw-r--r--  2.0 unx     4689 b- defN 23-May-16 05:43 qumulo/rest/users.py
--rw-r--r--  2.0 unx     1593 b- defN 23-May-16 05:43 qumulo/rest/version.py
--rw-r--r--  2.0 unx     3679 b- defN 23-May-16 05:43 qumulo/rest/web_ui.py
--rw-r--r--  2.0 unx    11358 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     3776 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/METADATA
--r--r--r--  2.0 unx      290 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/NOTICE
--rw-r--r--  2.0 unx       92 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       68 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     8728 b- defN 23-May-16 05:43 qumulo_api-6.1.1.dist-info/RECORD
-107 files, 976311 bytes uncompressed, 241221 bytes compressed:  75.3%
+Zip file size: 259418 bytes, number of entries: 107
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-29 18:26 qumulo/__init__.py
+-rw-r--r--  2.0 unx    11049 b- defN 23-Jun-29 18:26 qumulo/rest_client.py
+-rw-r--r--  2.0 unx     5463 b- defN 23-Jun-29 18:26 qumulo/retry.py
+-rw-r--r--  2.0 unx     1178 b- defN 23-Jun-29 18:26 qumulo/commands/__init__.py
+-rw-r--r--  2.0 unx     7430 b- defN 23-Jun-29 18:26 qumulo/commands/access_tokens.py
+-rw-r--r--  2.0 unx    16778 b- defN 23-Jun-29 18:26 qumulo/commands/ad.py
+-rw-r--r--  2.0 unx     5048 b- defN 23-Jun-29 18:26 qumulo/commands/analytics.py
+-rw-r--r--  2.0 unx     6531 b- defN 23-Jun-29 18:26 qumulo/commands/audit.py
+-rw-r--r--  2.0 unx    35605 b- defN 23-Jun-29 18:26 qumulo/commands/auth.py
+-rw-r--r--  2.0 unx     1045 b- defN 23-Jun-29 18:26 qumulo/commands/checksumming.py
+-rw-r--r--  2.0 unx    40293 b- defN 23-Jun-29 18:26 qumulo/commands/cluster.py
+-rw-r--r--  2.0 unx     4605 b- defN 23-Jun-29 18:26 qumulo/commands/dns.py
+-rw-r--r--  2.0 unx     1506 b- defN 23-Jun-29 18:26 qumulo/commands/encryption.py
+-rw-r--r--  2.0 unx     2843 b- defN 23-Jun-29 18:26 qumulo/commands/file_permissions_help.py
+-rw-r--r--  2.0 unx   129890 b- defN 23-Jun-29 18:26 qumulo/commands/fs.py
+-rw-r--r--  2.0 unx     3933 b- defN 23-Jun-29 18:26 qumulo/commands/ftp.py
+-rw-r--r--  2.0 unx     3596 b- defN 23-Jun-29 18:26 qumulo/commands/kerberos.py
+-rw-r--r--  2.0 unx    18150 b- defN 23-Jun-29 18:26 qumulo/commands/key_store.py
+-rw-r--r--  2.0 unx    12310 b- defN 23-Jun-29 18:26 qumulo/commands/ldap.py
+-rw-r--r--  2.0 unx     6846 b- defN 23-Jun-29 18:26 qumulo/commands/login.py
+-rw-r--r--  2.0 unx     1070 b- defN 23-Jun-29 18:26 qumulo/commands/metrics.py
+-rw-r--r--  2.0 unx    16823 b- defN 23-Jun-29 18:26 qumulo/commands/multitenancy.py
+-rw-r--r--  2.0 unx     9981 b- defN 23-Jun-29 18:26 qumulo/commands/multitenancy_nfs.py
+-rw-r--r--  2.0 unx     8845 b- defN 23-Jun-29 18:26 qumulo/commands/multitenancy_smb.py
+-rw-r--r--  2.0 unx    20655 b- defN 23-Jun-29 18:26 qumulo/commands/network.py
+-rw-r--r--  2.0 unx    34897 b- defN 23-Jun-29 18:26 qumulo/commands/nfs.py
+-rw-r--r--  2.0 unx     1015 b- defN 23-Jun-29 18:26 qumulo/commands/node_state.py
+-rw-r--r--  2.0 unx    10630 b- defN 23-Jun-29 18:26 qumulo/commands/object_replication.py
+-rw-r--r--  2.0 unx     6173 b- defN 23-Jun-29 18:26 qumulo/commands/quota.py
+-rw-r--r--  2.0 unx     2531 b- defN 23-Jun-29 18:26 qumulo/commands/raw.py
+-rw-r--r--  2.0 unx    35414 b- defN 23-Jun-29 18:26 qumulo/commands/replication.py
+-rw-r--r--  2.0 unx    14355 b- defN 23-Jun-29 18:26 qumulo/commands/roles.py
+-rw-r--r--  2.0 unx    15644 b- defN 23-Jun-29 18:26 qumulo/commands/s3.py
+-rw-r--r--  2.0 unx     5323 b- defN 23-Jun-29 18:26 qumulo/commands/saml.py
+-rw-r--r--  2.0 unx     3259 b- defN 23-Jun-29 18:26 qumulo/commands/shutdown.py
+-rw-r--r--  2.0 unx    52180 b- defN 23-Jun-29 18:26 qumulo/commands/smb.py
+-rw-r--r--  2.0 unx    44057 b- defN 23-Jun-29 18:26 qumulo/commands/snapshot.py
+-rw-r--r--  2.0 unx     7403 b- defN 23-Jun-29 18:26 qumulo/commands/support.py
+-rw-r--r--  2.0 unx     2935 b- defN 23-Jun-29 18:26 qumulo/commands/time_config.py
+-rw-r--r--  2.0 unx     4604 b- defN 23-Jun-29 18:26 qumulo/commands/tree_delete.py
+-rw-r--r--  2.0 unx     1403 b- defN 23-Jun-29 18:26 qumulo/commands/unconfigured_node_operations.py
+-rw-r--r--  2.0 unx    22129 b- defN 23-Jun-29 18:26 qumulo/commands/upgrade.py
+-rw-r--r--  2.0 unx      976 b- defN 23-Jun-29 18:26 qumulo/commands/version.py
+-rw-r--r--  2.0 unx     7374 b- defN 23-Jun-29 18:26 qumulo/commands/web_ui.py
+-rw-r--r--  2.0 unx      669 b- defN 23-Jun-29 18:26 qumulo/lib/__init__.py
+-rw-r--r--  2.0 unx    12849 b- defN 23-Jun-29 18:26 qumulo/lib/acl_util.py
+-rw-r--r--  2.0 unx     4047 b- defN 23-Jun-29 18:26 qumulo/lib/auth.py
+-rw-r--r--  2.0 unx     1833 b- defN 23-Jun-29 18:26 qumulo/lib/duration.py
+-rw-r--r--  2.0 unx    11107 b- defN 23-Jun-29 18:26 qumulo/lib/identity_util.py
+-rw-r--r--  2.0 unx     3551 b- defN 23-Jun-29 18:26 qumulo/lib/keys.py
+-rw-r--r--  2.0 unx     2230 b- defN 23-Jun-29 18:26 qumulo/lib/obj.py
+-rw-r--r--  2.0 unx     8901 b- defN 23-Jun-29 18:26 qumulo/lib/opts.py
+-rw-r--r--  2.0 unx     6063 b- defN 23-Jun-29 18:26 qumulo/lib/qq.py
+-rw-r--r--  2.0 unx    25203 b- defN 23-Jun-29 18:26 qumulo/lib/request.py
+-rw-r--r--  2.0 unx     1058 b- defN 23-Jun-29 18:26 qumulo/lib/rest_util.py
+-rw-r--r--  2.0 unx      926 b- defN 23-Jun-29 18:26 qumulo/lib/rfc3339.py
+-rw-r--r--  2.0 unx     2009 b- defN 23-Jun-29 18:26 qumulo/lib/tenant.py
+-rw-r--r--  2.0 unx     3350 b- defN 23-Jun-29 18:26 qumulo/lib/uri.py
+-rw-r--r--  2.0 unx    14820 b- defN 23-Jun-29 18:26 qumulo/lib/util.py
+-rw-r--r--  2.0 unx     1167 b- defN 23-Jun-29 18:26 qumulo/rest/__init__.py
+-rw-r--r--  2.0 unx     4501 b- defN 23-Jun-29 18:26 qumulo/rest/access_tokens.py
+-rw-r--r--  2.0 unx     7358 b- defN 23-Jun-29 18:26 qumulo/rest/ad.py
+-rw-r--r--  2.0 unx     2204 b- defN 23-Jun-29 18:26 qumulo/rest/analytics.py
+-rw-r--r--  2.0 unx     5909 b- defN 23-Jun-29 18:26 qumulo/rest/audit.py
+-rw-r--r--  2.0 unx     8419 b- defN 23-Jun-29 18:26 qumulo/rest/auth.py
+-rw-r--r--  2.0 unx      914 b- defN 23-Jun-29 18:26 qumulo/rest/checksumming.py
+-rw-r--r--  2.0 unx    12868 b- defN 23-Jun-29 18:26 qumulo/rest/cluster.py
+-rw-r--r--  2.0 unx     3056 b- defN 23-Jun-29 18:26 qumulo/rest/dns.py
+-rw-r--r--  2.0 unx     1148 b- defN 23-Jun-29 18:26 qumulo/rest/encryption.py
+-rw-r--r--  2.0 unx    49583 b- defN 23-Jun-29 18:26 qumulo/rest/fs.py
+-rw-r--r--  2.0 unx     4531 b- defN 23-Jun-29 18:26 qumulo/rest/ftp.py
+-rw-r--r--  2.0 unx     4410 b- defN 23-Jun-29 18:26 qumulo/rest/groups.py
+-rw-r--r--  2.0 unx     2897 b- defN 23-Jun-29 18:26 qumulo/rest/kerberos.py
+-rw-r--r--  2.0 unx     4490 b- defN 23-Jun-29 18:26 qumulo/rest/ldap.py
+-rw-r--r--  2.0 unx     1251 b- defN 23-Jun-29 18:26 qumulo/rest/metrics.py
+-rw-r--r--  2.0 unx     4909 b- defN 23-Jun-29 18:26 qumulo/rest/multitenancy.py
+-rw-r--r--  2.0 unx     5260 b- defN 23-Jun-29 18:26 qumulo/rest/multitenancy_nfs.py
+-rw-r--r--  2.0 unx     3616 b- defN 23-Jun-29 18:26 qumulo/rest/multitenancy_smb.py
+-rw-r--r--  2.0 unx     8417 b- defN 23-Jun-29 18:26 qumulo/rest/network.py
+-rw-r--r--  2.0 unx     8467 b- defN 23-Jun-29 18:26 qumulo/rest/nfs.py
+-rw-r--r--  2.0 unx      910 b- defN 23-Jun-29 18:26 qumulo/rest/node_state.py
+-rw-r--r--  2.0 unx     4468 b- defN 23-Jun-29 18:26 qumulo/rest/object_replication.py
+-rw-r--r--  2.0 unx     3426 b- defN 23-Jun-29 18:26 qumulo/rest/quota.py
+-rw-r--r--  2.0 unx    11002 b- defN 23-Jun-29 18:26 qumulo/rest/replication.py
+-rw-r--r--  2.0 unx     6628 b- defN 23-Jun-29 18:26 qumulo/rest/roles.py
+-rw-r--r--  2.0 unx     9857 b- defN 23-Jun-29 18:26 qumulo/rest/s3.py
+-rw-r--r--  2.0 unx     2687 b- defN 23-Jun-29 18:26 qumulo/rest/saml.py
+-rw-r--r--  2.0 unx     1944 b- defN 23-Jun-29 18:26 qumulo/rest/shutdown.py
+-rw-r--r--  2.0 unx    11128 b- defN 23-Jun-29 18:26 qumulo/rest/smb.py
+-rw-r--r--  2.0 unx    12759 b- defN 23-Jun-29 18:26 qumulo/rest/snapshot.py
+-rw-r--r--  2.0 unx     3750 b- defN 23-Jun-29 18:26 qumulo/rest/support.py
+-rw-r--r--  2.0 unx     1972 b- defN 23-Jun-29 18:26 qumulo/rest/time_config.py
+-rw-r--r--  2.0 unx     2706 b- defN 23-Jun-29 18:26 qumulo/rest/tree_delete.py
+-rw-r--r--  2.0 unx     1780 b- defN 23-Jun-29 18:26 qumulo/rest/unconfigured_node_operations.py
+-rw-r--r--  2.0 unx     1960 b- defN 23-Jun-29 18:26 qumulo/rest/upgrade.py
+-rw-r--r--  2.0 unx     2968 b- defN 23-Jun-29 18:26 qumulo/rest/upgrade_v2.py
+-rw-r--r--  2.0 unx     1234 b- defN 23-Jun-29 18:26 qumulo/rest/upgrade_v3.py
+-rw-r--r--  2.0 unx     4689 b- defN 23-Jun-29 18:26 qumulo/rest/users.py
+-rw-r--r--  2.0 unx     1593 b- defN 23-Jun-29 18:26 qumulo/rest/version.py
+-rw-r--r--  2.0 unx     3679 b- defN 23-Jun-29 18:26 qumulo/rest/web_ui.py
+-rw-r--r--  2.0 unx    11358 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3776 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/METADATA
+-r--r--r--  2.0 unx      290 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/NOTICE
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       68 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     8729 b- defN 23-Jun-29 18:26 qumulo_api-6.1.2.dist-info/RECORD
+107 files, 1003248 bytes uncompressed, 245922 bytes compressed:  75.5%
```

## zipnote {}

```diff
@@ -294,29 +294,29 @@
 
 Filename: qumulo/rest/version.py
 Comment: 
 
 Filename: qumulo/rest/web_ui.py
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/LICENSE
+Filename: qumulo_api-6.1.2.dist-info/LICENSE
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/METADATA
+Filename: qumulo_api-6.1.2.dist-info/METADATA
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/NOTICE
+Filename: qumulo_api-6.1.2.dist-info/NOTICE
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/WHEEL
+Filename: qumulo_api-6.1.2.dist-info/WHEEL
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/entry_points.txt
+Filename: qumulo_api-6.1.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/top_level.txt
+Filename: qumulo_api-6.1.2.dist-info/top_level.txt
 Comment: 
 
-Filename: qumulo_api-6.1.1.dist-info/RECORD
+Filename: qumulo_api-6.1.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qumulo/__init__.py

```diff
@@ -1 +1 @@
-__version__ = "6.1.1"
+__version__ = "6.1.2"
```

## qumulo/commands/ad.py

```diff
@@ -167,56 +167,53 @@
         )
 
         posix_action = parser.add_mutually_exclusive_group(required=False)
         posix_action.add_argument(
             '--enable-ad-posix-attributes',
             action='store_true',
             required=False,
+            default=None,
+            dest='use_ad_posix_attributes',
             help='Use AD POSIX attributes.',
         )
         posix_action.add_argument(
             '--disable-ad-posix-attributes',
-            action='store_true',
+            action='store_false',
             required=False,
+            default=None,
+            dest='use_ad_posix_attributes',
             help='Do not use AD POSIX attributes.',
         )
 
         parser.add_argument(
             '--base-dn',
             type=str_decode,
             required=False,
+            default=None,
             help='When using AD POSIX extensions, query using this base DN',
         )
 
+        # Fully-qualified name of Active Directory Domain
+        parser.add_argument('-d', '--domain', type=str_decode, default=None, help=argparse.SUPPRESS)
+
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if (
             args.search_trusted_domains is None
-            and not args.enable_ad_posix_attributes
-            and not args.disable_ad_posix_attributes
+            and args.use_ad_posix_attributes is None
             and args.base_dn is None
         ):
             raise ValueError('No changes specified')
 
-        ad_status = rest_client.ad.list_ad()
-
-        if args.enable_ad_posix_attributes:
-            use_ad_posix_attributes = True
-        elif args.disable_ad_posix_attributes:
-            use_ad_posix_attributes = False
-        else:
-            use_ad_posix_attributes = ad_status['use_ad_posix_attributes']
-
-        base_dn = ad_status['base_dn'] if args.base_dn is None else args.base_dn
-
         print(
             rest_client.ad.reconfigure_ad(
-                enable_ldap=use_ad_posix_attributes,
-                base_dn=base_dn,
+                enable_ldap=args.use_ad_posix_attributes,
+                base_dn=args.base_dn,
                 search_trusted_domains=args.search_trusted_domains,
+                domain=args.domain,
             )
         )
 
 
 class LeaveAdCommand(qumulo.lib.opts.Subcommand):
     NAME = 'ad_leave'
     SYNOPSIS = 'Leave an Active Directory Domain'
```

## qumulo/commands/cluster.py

```diff
@@ -10,25 +10,28 @@
 # License for the specific language governing permissions and limitations under
 # the License.
 
 
 import argparse
 import time
 
-from typing import List, Optional, Tuple
+from dataclasses import dataclass
+from typing import List, Optional, Sequence, Tuple
 
 import qumulo.lib.opts
 import qumulo.lib.util
 import qumulo.rest.cluster as cluster
 import qumulo.rest.node_state as node_state
 import qumulo.rest.unconfigured_node_operations as unconfigured_node_operations
 
 from qumulo.lib.auth import Credentials
 from qumulo.lib.opts import str_decode
-from qumulo.lib.request import Connection
+from qumulo.lib.request import Connection, RequestError, RestResponse
+from qumulo.lib.util import are_you_sure
+from qumulo.rest.cluster import get_node_replacement_plan, ModifyDryRunResponse, StripeConfig
 from qumulo.rest_client import RestClient
 
 
 class PasswordMismatchError(ValueError):
     pass
 
 
@@ -437,69 +440,655 @@
         )
 
         wait_for_first_quorum_following_cluster_create(
             rest_client.conninfo, rest_client.credentials
         )
 
 
-class AddNode(qumulo.lib.opts.Subcommand):
+def _humanize_bytes(byte_size: int) -> Tuple[str, str]:
+    base = 1000
+    units = ['B', 'K', 'M', 'G', 'T', 'P']
+    for i, unit in enumerate(units):
+        val = round(byte_size / base ** i)
+        if val < base:
+            return str(val), unit
+    return str(byte_size), 'B'
+
+
+def humanize_decimal(byte_size: int) -> Tuple[str, str]:
+    """
+    Format number of bytes to a tuple of integer value and decimal unit (B, KB,
+    MB, GB, TB, or PB) as strings.
+    """
+    val, unit = _humanize_bytes(byte_size)
+    if unit != 'B':
+        unit += 'B'
+    return val, unit
+
+
+def add_nodes_group(
+    parser: argparse.ArgumentParser, required: bool
+) -> argparse._MutuallyExclusiveGroup:
+    result = parser.add_mutually_exclusive_group(required=required)
+    result.add_argument(
+        '--node-uuids',
+        help=(
+            'The UUIDs of the unconfigured nodes to add to the cluster. The system adds nodes to '
+            'the cluster in the same order that you list them after this flag.'
+        ),
+        nargs='+',
+        default=[],
+    )
+    result.add_argument(
+        '--node-ips',
+        help=(
+            'The IP addresses of the unconfigured nodes to add to the cluster. The system adds '
+            'nodes to the cluster in the same order that you list them after this flag.'
+        ),
+        nargs='+',
+        default=[],
+    )
+    result.add_argument(
+        '--all-unconfigured',
+        '-A',
+        help=(
+            'Add all network-connected, unconfigured nodes to the cluster. This flag does not '
+            'allow specifying the order of the nodes and does not apply to cloud clusters.'
+        ),
+        action='store_true',
+    )
+    return result
+
+
+def set_up_node_add_parser(parser: argparse.ArgumentParser) -> None:
+    add_nodes_group(parser, required=True)
+    parser.add_argument(
+        '--target-stripe-config',
+        action='store',
+        type=int,
+        nargs=2,
+        metavar=('BLOCKS_PER_STRIPE', 'DATA_BLOCKS_PER_STRIPE'),
+        help='The stripe configuration to use',
+    )
+    parser.add_argument(
+        '--target-max-node-failures',
+        action='store',
+        type=int,
+        help=(
+            'The minimum node fault tolerance level for the resulting cluster configuration. Note:'
+            ' In certain cases, a lower node fault tolerance level can result in higher usable'
+            ' capacity'
+        ),
+    )
+    parser.add_argument(
+        '--dry-run',
+        action='store_true',
+        help=(
+            'Validate the node-add operation and calculate the resulting usable cluster capacity.'
+            ' When you use this flag, Qumulo Core does not add nodes or begin to change data'
+            ' protection configuration'
+        ),
+    )
+    parser.add_argument(
+        '--batch',
+        action='store_true',
+        help='Begin the node-add operation without asking for confirmation.',
+    )
+
+
+class NodeAdderOps:
+    def print(self, output: str) -> None:
+        raise NotImplementedError()
+
+    def are_you_sure(self, question: str) -> bool:
+        raise NotImplementedError()
+
+    def modify_nodes(
+        self,
+        node_uuids: Optional[Sequence[str]],
+        node_ips: Optional[Sequence[str]],
+        target_max_node_failures: Optional[int],
+        target_stripe_config: Optional[StripeConfig],
+        nodes_to_replace: Optional[Sequence[int]],
+    ) -> str:
+        raise NotImplementedError()
+
+    def modify_nodes_dry_run(
+        self,
+        node_uuids: Optional[Sequence[str]],
+        node_ips: Optional[Sequence[str]],
+        target_max_node_failures: Optional[int],
+        target_stripe_config: Optional[StripeConfig],
+        nodes_to_replace: Optional[Sequence[int]],
+    ) -> ModifyDryRunResponse:
+        raise NotImplementedError()
+
+    def list_unconfigured_nodes(self) -> RestResponse:
+        raise NotImplementedError()
+
+    def get_target_stripe_config_from_node_replacement_plan(self) -> Optional[StripeConfig]:
+        raise NotImplementedError()
+
+    def get_nodes_to_be_replaced_from_node_replacement_plan(self) -> List[int]:
+        raise NotImplementedError()
+
+
+class NodeAdderAdapter(NodeAdderOps):
+    def __init__(self, rest_client: RestClient):
+        self.rest_client = rest_client
+
+    def print(self, output: str) -> None:
+        print(output)
+
+    def are_you_sure(self, question: str) -> bool:
+        print(question)
+        return are_you_sure()
+
+    def modify_nodes(
+        self,
+        node_uuids: Optional[Sequence[str]],
+        node_ips: Optional[Sequence[str]],
+        target_max_node_failures: Optional[int],
+        target_stripe_config: Optional[StripeConfig],
+        nodes_to_replace: Optional[Sequence[int]],
+    ) -> str:
+        return str(
+            qumulo.rest.cluster.modify_nodes(
+                self.rest_client.conninfo,
+                self.rest_client.credentials,
+                node_uuids=node_uuids,
+                node_ips=node_ips,
+                target_max_node_failures=target_max_node_failures,
+                target_stripe_config=target_stripe_config,
+                nodes_to_replace=nodes_to_replace,
+            )
+        )
+
+    def modify_nodes_dry_run(
+        self,
+        node_uuids: Optional[Sequence[str]],
+        node_ips: Optional[Sequence[str]],
+        target_max_node_failures: Optional[int],
+        target_stripe_config: Optional[StripeConfig],
+        nodes_to_replace: Optional[Sequence[int]],
+    ) -> ModifyDryRunResponse:
+        response = qumulo.rest.cluster.modify_nodes_dry_run(
+            self.rest_client.conninfo,
+            self.rest_client.credentials,
+            node_uuids=node_uuids,
+            node_ips=node_ips,
+            target_max_node_failures=target_max_node_failures,
+            target_stripe_config=target_stripe_config,
+            nodes_to_replace=nodes_to_replace,
+        )
+        return ModifyDryRunResponse.from_dict(response.data)
+
+    def list_unconfigured_nodes(self) -> RestResponse:
+        return unconfigured_node_operations.list_unconfigured_nodes(
+            self.rest_client.conninfo, self.rest_client.credentials
+        )
+
+    def get_target_stripe_config_from_node_replacement_plan(self) -> Optional[StripeConfig]:
+        plan = get_node_replacement_plan(self.rest_client.conninfo, self.rest_client.credentials)
+        target_stripe_config = plan.data['target_stripe_config']
+        if target_stripe_config is None:
+            return None
+        return StripeConfig(**target_stripe_config)
+
+    def get_nodes_to_be_replaced_from_node_replacement_plan(self) -> List[int]:
+        plan = get_node_replacement_plan(self.rest_client.conninfo, self.rest_client.credentials)
+        return plan.data['nodes_to_be_replaced']
+
+
+def render_node_fault_tolerance_level(node_fault_tolerance_level: int) -> str:
+    if node_fault_tolerance_level == 1:
+        return '1 node'
+    else:
+        return f'{node_fault_tolerance_level} nodes'
+
+
+CapacityAndNodeFaultTolerance = Tuple[int, int]
+
+
+@dataclass
+class CapacityProjections:
+    current: CapacityAndNodeFaultTolerance
+    selected: CapacityAndNodeFaultTolerance
+    alternative: Optional[CapacityAndNodeFaultTolerance] = None
+
+
+class NoPlannedReconfigError(Exception):
+    pass
+
+
+class NoNodeReplacementPlanError(Exception):
+    pass
+
+
+class NodeAdder:
+    """
+    Responsible for handling the v2 node-add CLI (corresponding to the /v2/cluster/nodes API).
+
+    Extracted from the Subcommand to facilitate unit-testing.
+    """
+
+    def __init__(self, ops: NodeAdderOps):
+        self.ops = ops
+
+    def print_dry_run_info(self, dry_run_info: CapacityAndNodeFaultTolerance) -> None:
+        (capacity, node_fault_tolerance) = dry_run_info
+        (value, unit) = humanize_decimal(capacity)
+        # This case is obviously not important for real clusters, but it makes the unit tests a
+        # little nicer
+        if unit == 'B':
+            self.ops.print(f'    Usable capacity: {capacity} bytes')
+        else:
+            self.ops.print(f'    Usable capacity: {value} {unit} ({capacity} bytes)')
+        self.ops.print(
+            '    Node fault tolerance level: '
+            + render_node_fault_tolerance_level(node_fault_tolerance)
+        )
+
+    def get_capacity_projections(
+        self,
+        target_stripe_config: Optional[StripeConfig],
+        target_max_node_failures: Optional[int],
+        node_uuids: Optional[Sequence[str]] = None,
+        node_ips: Optional[Sequence[str]] = None,
+        nodes_to_replace: Optional[Sequence[int]] = None,
+    ) -> CapacityProjections:
+        def dry_run_for_nft(node_fault_tolerance: Optional[int]) -> ModifyDryRunResponse:
+            return self.ops.modify_nodes_dry_run(
+                node_uuids=node_uuids,
+                node_ips=node_ips,
+                target_max_node_failures=node_fault_tolerance,
+                target_stripe_config=target_stripe_config,
+                nodes_to_replace=nodes_to_replace,
+            )
+
+        # We'll just let the API decide what to do by default if target_max_node_failures is
+        # omitted.
+        selected_nft_projection = dry_run_for_nft(target_max_node_failures)
+
+        result = CapacityProjections(
+            current=(
+                selected_nft_projection.current_capacity,
+                selected_nft_projection.current_max_node_failures,
+            ),
+            selected=(
+                selected_nft_projection.projected_capacity,
+                selected_nft_projection.projected_max_node_failures,
+            ),
+        )
+
+        try:
+            alternative_nft_projection = dry_run_for_nft(
+                selected_nft_projection.projected_max_node_failures + 1
+            )
+            result.alternative = (
+                alternative_nft_projection.projected_capacity,
+                alternative_nft_projection.projected_max_node_failures,
+            )
+        # It's fine if it's impossible to increase node fault tolerance further.
+        except RequestError:
+            pass
+
+        return result
+
+    def print_capacity_projections(
+        self, projections: CapacityProjections, batch: bool, operation_name: str
+    ) -> None:
+        self.ops.print('Current cluster:')
+        self.print_dry_run_info(projections.current)
+
+        self.ops.print(f'With the selected {operation_name}:')
+        self.print_dry_run_info(projections.selected)
+
+        alternative = projections.alternative
+        if not batch and alternative is not None:
+            self.ops.print('')
+            self.ops.print(
+                f'Note that there is an alternative {operation_name} that would provide higher node'
+                ' fault tolerance at the expense of usable capacity.'
+            )
+            self.ops.print(f'With the alternative {operation_name}:')
+            self.print_dry_run_info(alternative)
+
+            self.ops.print(
+                f'To perform the alternative {operation_name}, re-run this command with '
+                f'`--target-max-node-failures {alternative[1]}`.'
+            )
+
+    def print_nodes_from_plan(self, nodes_to_replace: List[int]) -> None:
+        # We'll fill ranges with a list of closed intervals of nodes to replace. For example,
+        # given nodes 1, 2, and 5, we'll end up with ranges of [(1, 2), (5, 5)]. We'll use this to
+        # render the node IDs in a readable format even if you're e.g. replacing a 50-node cluster
+        # all at once.
+        ranges: List[Tuple[int, int]] = []
+        # Caller should have checked for an empty list.
+        start_of_range = nodes_to_replace[0]
+        end_of_range = nodes_to_replace[0]
+        for node in nodes_to_replace[1:]:
+            if node == end_of_range + 1:
+                end_of_range = node
+            else:
+                ranges.append((start_of_range, end_of_range))
+                start_of_range = node
+                end_of_range = node
+        ranges.append((start_of_range, end_of_range))
+
+        rendered_ranges = ', '.join(
+            str(start) if start == end else f'{start}-{end}' for (start, end) in ranges
+        )
+
+        self.ops.print(f'Replacing node IDs {rendered_ranges}')
+        self.ops.print('')
+
+    def run(
+        self,
+        target_stripe_config: Optional[StripeConfig] = None,
+        do_planned_transcode: bool = False,
+        target_max_node_failures: Optional[int] = None,
+        node_uuids: Optional[Sequence[str]] = None,
+        node_ips: Optional[Sequence[str]] = None,
+        all_unconfigured: bool = False,
+        nodes_to_replace: Optional[Sequence[int]] = None,
+        replace_all: bool = False,
+        dry_run: bool = False,
+        batch: bool = False,
+    ) -> None:
+        interactive = not (dry_run or batch)
+
+        operation_name = 'node-add operation'
+        if nodes_to_replace:
+            assert not replace_all
+            operation_name = 'node replacement step'
+        if replace_all:
+            operation_name = 'node replacement step'
+            nodes_to_replace = self.ops.get_nodes_to_be_replaced_from_node_replacement_plan()
+            if nodes_to_replace == []:
+                raise NoNodeReplacementPlanError(
+                    '--replace-all specified but no node replacement plan found.'
+                )
+            self.print_nodes_from_plan(nodes_to_replace)
+
+        if target_stripe_config is not None:
+            assert not do_planned_transcode
+            operation_name += ' and data protection reconfiguration'
+        if do_planned_transcode:
+            operation_name += ' and data protection reconfiguration'
+            target_stripe_config = self.ops.get_target_stripe_config_from_node_replacement_plan()
+            if target_stripe_config is None:
+                raise NoPlannedReconfigError(
+                    'No data protection reconfiguration is present in the node replacement plan.'
+                )
+
+        if all_unconfigured:
+            unconfigured = self.ops.list_unconfigured_nodes()
+            nodes = unconfigured.data['nodes']
+            node_uuids = [n['uuid'] for n in nodes]
+            self.ops.print('Found unconfigured nodes to add:')
+            table = unconfigured_node_operations.fmt_unconfigured_nodes(unconfigured)
+            self.ops.print(table)
+            self.ops.print('')
+
+        projections = self.get_capacity_projections(
+            target_stripe_config, target_max_node_failures, node_uuids, node_ips, nodes_to_replace
+        )
+        self.print_capacity_projections(projections, batch, operation_name)
+
+        if not dry_run:
+            if node_uuids is not None and len(node_uuids) > 1 and target_stripe_config is not None:
+                self.ops.print('')
+                self.ops.print(
+                    'Important: Usable capacity does not increase until the data protection '
+                    'reconfiguration is complete. If you need additional capacity immediately, '
+                    'consider adding some of the nodes without data protection reconfiguration. '
+                    'You can reconfigure data protection at a later time.'
+                )
+
+            self.ops.print('')
+            if interactive:
+                self.ops.print(
+                    "Important: it isn't possible to reverse this operation. Before continuing, "
+                    'check that the above information is correct, and that the nodes are ordered '
+                    "correctly. It isn't possible to reorder nodes after you add them to the "
+                    'cluster.'
+                )
+                if not self.ops.are_you_sure(f'Continue with selected {operation_name}?'):
+                    return
+
+            self.ops.print(f'Initiating {operation_name}...')
+            self.ops.print(
+                self.ops.modify_nodes(
+                    node_uuids=node_uuids,
+                    node_ips=node_ips,
+                    target_max_node_failures=target_max_node_failures,
+                    target_stripe_config=target_stripe_config,
+                    nodes_to_replace=nodes_to_replace,
+                )
+            )
+            self.ops.print('Visit the above URI for progress information.')
+
+
+class AddNodesCommand(qumulo.lib.opts.Subcommand):
     NAME = 'add_nodes'
-    SYNOPSIS = 'Add unconfigured nodes to a Qumulo Cluster'
+    SYNOPSIS = 'Add unconfigured nodes to a Qumulo cluster'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
-        nodes_group = parser.add_mutually_exclusive_group(required=True)
-        nodes_group.add_argument(
-            '--node-uuids',
-            help='Unconfigured node uuids to add',
-            action='append',
-            nargs='+',
-            default=[],
+        set_up_node_add_parser(parser)
+
+    @staticmethod
+    def main(rest_client: RestClient, args: argparse.Namespace) -> None:
+        adapter = NodeAdderAdapter(rest_client)
+        node_adder = NodeAdder(adapter)
+        target_stripe_config = None
+        if args.target_stripe_config is not None:
+            target_blocks_per_stripe, target_data_blocks_per_stripe = args.target_stripe_config
+            target_stripe_config = StripeConfig(
+                target_blocks_per_stripe, target_data_blocks_per_stripe
+            )
+        node_adder.run(
+            node_uuids=args.node_uuids,
+            node_ips=args.node_ips,
+            all_unconfigured=args.all_unconfigured,
+            target_stripe_config=target_stripe_config,
+            target_max_node_failures=args.target_max_node_failures,
+            dry_run=args.dry_run,
+            batch=args.batch,
         )
-        nodes_group.add_argument(
-            '--node-ips',
-            help='Unconfigured node ips to add',
-            action='append',
-            nargs='+',
-            default=[],
+
+
+def set_up_register_plan_parser(register_plan_parser: argparse.ArgumentParser) -> None:
+    replace_group = register_plan_parser.add_mutually_exclusive_group(required=True)
+    replace_group.add_argument(
+        '--nodes-to-be-replaced',
+        '-n',
+        metavar='NODE_ID',
+        nargs='+',
+        default=[],
+        help='The configured nodes to replace',
+    )
+    replace_group.add_argument(
+        '--replace-all',
+        '-A',
+        action='store_true',
+        help='Replace all of the configured nodes in the cluster.',
+    )
+
+    register_plan_parser.add_argument(
+        '--target-stripe-config',
+        action='store',
+        type=int,
+        nargs=2,
+        metavar=('BLOCKS_PER_STRIPE', 'DATA_BLOCKS_PER_STRIPE'),
+        help='The final stripe configuration to use',
+    )
+
+
+def set_up_add_nodes_and_replace_parser(step_parser: argparse.ArgumentParser) -> None:
+    add_nodes_group(step_parser, required=False)
+
+    nodes_being_replaced_group = step_parser.add_mutually_exclusive_group(required=True)
+    nodes_being_replaced_group.add_argument(
+        '--nodes-being-replaced',
+        '-n',
+        metavar='NODE_ID',
+        nargs='+',
+        default=[],
+        help=(
+            'The configured nodes to replace. Note: These nodes must be a subset of the node'
+            ' replacement plan.'
+        ),
+    )
+    nodes_being_replaced_group.add_argument(
+        '--replace-all',
+        '-R',
+        action='store_true',
+        help='Replace all nodes in the node replacement plan.',
+    )
+    step_parser.add_argument(
+        '--reconfigure-data-protection',
+        action='store_true',
+        help=(
+            'Reconfigure data protection to use the stripe configuration from the node '
+            'replacement plan.'
+        ),
+    )
+    step_parser.add_argument(
+        '--target-max-node-failures',
+        action='store',
+        type=int,
+        help=(
+            'The minimum node fault tolerance level for the resulting cluster configuration. '
+            'Note: In certain cases, a lower node fault tolerance level can result in higher '
+            'usable capacity.'
+        ),
+    )
+    step_parser.add_argument(
+        '--dry-run',
+        action='store_true',
+        help=(
+            'Validate the node replacement step and calculate the resulting usable cluster'
+            ' capacity. When you use this flag, Qumulo Core does not add or replace nodes or'
+            ' begin to change data protection configuration'
+        ),
+    )
+    step_parser.add_argument(
+        '--batch',
+        action='store_true',
+        help='Begin the node replacement step without asking for confirmation.',
+    )
+
+
+class ReplaceNodesCommand(qumulo.lib.opts.Subcommand):
+    NAME = 'replace_nodes'
+    SYNOPSIS = 'Replace configured nodes by adding nodes to a Qumulo cluster.'
+
+    @staticmethod
+    def options(parser: argparse.ArgumentParser) -> None:
+        subparsers = parser.add_subparsers(title='subcommands', dest='command', required=True)
+
+        register_plan_parser = subparsers.add_parser(
+            'register_plan', help='Configure and store a node replacement plan.'
         )
+        register_plan_parser.set_defaults(run=ReplaceNodesCommand.register_plan)
+        set_up_register_plan_parser(register_plan_parser)
 
-        parser.add_argument(
-            '--optimize-node-fault-tolerance-over-usable-capacity',
+        step_parser = subparsers.add_parser(
+            'add_nodes_and_replace',
             help=(
-                'Explicitly allow trading off some of the increase in usable capacity for '
-                'increased node fault tolerance if necessary'
+                'Add unconfigured nodes to the cluster and replace the existing, configured nodes.'
             ),
-            default=False,
-            action='store_true',
         )
+        step_parser.set_defaults(run=ReplaceNodesCommand.add_nodes_and_replace)
+        set_up_add_nodes_and_replace_parser(step_parser)
+
+        get_plan_parser = subparsers.add_parser(
+            'get_plan', help='Show the details of the current node replacement plan.'
+        )
+        get_plan_parser.set_defaults(run=ReplaceNodesCommand.get_plan)
 
-        # Calculate and return changes to cluster usable capacity only
-        parser.add_argument('--dry-run', action='store_true')
+        cancel_parser = subparsers.add_parser(
+            'cancel_plan', help='Cancel the current node replacement plan.'
+        )
+        cancel_parser.set_defaults(run=ReplaceNodesCommand.cancel_plan)
+        cancel_parser.add_argument(
+            '--batch', action='store_true', help='Do not prompt for user confirmation.'
+        )
 
     @staticmethod
-    def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        # For backward compatibility, we support multiple instances of
-        # --node-uuids to append but we also would like to allow multiple node
-        # uuids give to each instance.  Flatten resulting list of lists.
-        args.node_uuids = [x for sublist in args.node_uuids for x in sublist]
-        args.node_ips = [x for sublist in args.node_ips for x in sublist]
+    def register_plan(rest_client: RestClient, args: argparse.Namespace) -> None:
+        nodes_to_be_replaced = args.nodes_to_be_replaced
+        if args.replace_all:
+            nodes_list = qumulo.rest.cluster.list_nodes(
+                rest_client.conninfo, rest_client.credentials
+            )
+            nodes_to_be_replaced = [n['id'] for n in nodes_list.data]
 
-        if args.dry_run:
-            print(
-                cluster.calculate_node_add_capacity(
-                    rest_client.conninfo,
-                    rest_client.credentials,
-                    node_uuids=args.node_uuids,
-                    node_ips=args.node_ips,
-                )
+        stripe_config = None
+        if args.target_stripe_config is not None:
+            stripe_config = StripeConfig(
+                blocks_per_stripe=args.target_stripe_config[0],
+                data_blocks_per_stripe=args.target_stripe_config[1],
             )
+
+        res = qumulo.rest.cluster.register_node_replacement_plan(
+            rest_client.conninfo,
+            rest_client.credentials,
+            nodes_to_be_replaced=nodes_to_be_replaced,
+            target_stripe_config=stripe_config,
+        )
+        if str(res) == 'null':
+            print('Node replacement plan registered.')
         else:
-            print(
-                cluster.add_node(
-                    rest_client.conninfo,
-                    rest_client.credentials,
-                    node_uuids=args.node_uuids,
-                    node_ips=args.node_ips,
-                    optimize_node_fault_tolerance_over_usable_capacity=args.optimize_node_fault_tolerance_over_usable_capacity,
-                )
+            print(res)
+
+    @staticmethod
+    def add_nodes_and_replace(rest_client: RestClient, args: argparse.Namespace) -> None:
+        adapter = NodeAdderAdapter(rest_client)
+        node_adder = NodeAdder(adapter)
+        node_adder.run(
+            do_planned_transcode=args.reconfigure_data_protection,
+            target_max_node_failures=args.target_max_node_failures,
+            node_uuids=args.node_uuids,
+            node_ips=args.node_ips,
+            all_unconfigured=args.all_unconfigured,
+            dry_run=args.dry_run,
+            batch=args.batch,
+            nodes_to_replace=args.nodes_being_replaced,
+            replace_all=args.replace_all,
+        )
+
+    @staticmethod
+    def get_plan(rest_client: RestClient, _args: argparse.Namespace) -> None:
+        print(
+            qumulo.rest.cluster.get_node_replacement_plan(
+                rest_client.conninfo, rest_client.credentials
             )
+        )
+
+    @staticmethod
+    def cancel_plan(rest_client: RestClient, args: argparse.Namespace) -> None:
+        interactive = not args.batch
+
+        print(
+            'WARNING: Canceling a node replacement plan after a step has already been executed'
+            ' might make it impossible to re-register and complete the plan.'
+        )
+        if interactive:
+            print('Do you confirm that you want to cancel the node replacement?')
+            if not are_you_sure():
+                return
+
+        res = qumulo.rest.cluster.register_node_replacement_plan(
+            rest_client.conninfo, rest_client.credentials, nodes_to_be_replaced=[]
+        )
+        if str(res) == 'null':
+            print('Node replacement plan canceled.')
+        else:
+            print(res)
+
+    @staticmethod
+    def main(rest_client: RestClient, args: argparse.Namespace) -> None:
+        args.run(rest_client, args)
```

## qumulo/commands/fs.py

```diff
@@ -1101,15 +1101,15 @@
           Then if the client reads /mnt/user_mount/sym1 it will look at the
           client's local /home/user/export directory and NOT qumulo's /home/user/export
 
         Incorrect usage: Unsuccessfully using the export-path (/user_export) instead of
         the fs-path (/home/user/export) for the directory in which to create the symlink:
 
           qq fs_create_symlink --path /user_export --target file0 --name sym0
-          > Error 404: fs_no_such_entry_error: user_export { ino=2 }
+          > Error 404: fs_no_such_entry_error: user_export
     """
     )
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
         group = parser.add_mutually_exclusive_group(required=True)
         group.add_argument('--path', help='Path to parent directory')
```

## qumulo/lib/util.py

```diff
@@ -250,15 +250,15 @@
 #   | |  __/>  <| |_ / ___ \| | | (_| | | | |  __/ |
 #   |_|\___/_/\_\\__/_/   \_\_|_|\__, |_| |_|\___|_|
 #                                |___/
 #  FIGLET: TextAligner
 #
 
 SINGLE_LEVEL_INDENT = ' ' * 4
-TextAlignerValueType = Union[int, float, bool, bytes, str, Sequence[str]]
+TextAlignerValueType = Union[int, float, bool, bytes, str, Sequence[str], None]
 
 
 class TextAligner:
     """
     Builds up a set of lines of text, with padding for named fields to have the
     same width in all lines where that field occurs.
     This makes it easy to build up complex text where there is interleaving of
@@ -353,15 +353,15 @@
         line = ''
         for i, item in enumerate(items):
             if i == 0:
                 line = str(item)
             elif len(line + sep + item) <= max_len:
                 line += f'{sep}{item}'
             else:
-                yield f'{line}{sep}'
+                yield f'{line}{sep}'.rstrip()
                 line = str(item)
         yield line
 
     def add_concatenated_lines(self, items: Iterable[str]) -> None:
         """
         Simple wrapper function that takes in a list and adds width-formatted lines.
         """
@@ -377,15 +377,15 @@
         """
         # Find the maximum left column length in characters
         max_col = max(len(a[0]) for a in table) + len(self.indent_val)
 
         for k, v in table:
             # Format the right column
             max_len = self.max_width - max_col
-            if isinstance(v, (int, float, bool, bytes)):
+            if isinstance(v, (int, float, bool, bytes)) or v is None:
                 v = str(v)
             if isinstance(v, str):
                 line_gen = self.format_list(v.split(' '), sep=' ', max_len=max_len)
             else:
                 line_gen = self.format_list(v, max_len=max_len)
             lines = list(line_gen)
```

## qumulo/rest/ad.py

```diff
@@ -7,15 +7,15 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
 
-from typing import Any, Dict, List, Optional
+from typing import Any, Dict, List, Optional, Union
 
 import qumulo.lib.request as request
 
 from qumulo.lib.uri import UriBuilder
 
 # Values for the advanced AD setting controlling DCERPC signing.
 VALID_SIGNING_CHOICES = ('NO_SIGNING', 'WANT_SIGNING', 'REQUIRE_SIGNING')
@@ -78,20 +78,30 @@
         }
         if search_trusted_domains is not None:
             config['search_trusted_domains'] = search_trusted_domains
 
         return self.client.send_request(method, uri, body=config).data
 
     def reconfigure_ad(
-        self, enable_ldap: bool, base_dn: str, search_trusted_domains: Optional[bool] = None
+        self,
+        enable_ldap: Optional[bool] = None,
+        base_dn: Optional[str] = None,
+        search_trusted_domains: Optional[bool] = None,
+        domain: Optional[str] = None,
     ) -> MonitorURI:
         method = 'POST'
         uri = '/v1/ad/reconfigure'
 
-        config = {'use_ad_posix_attributes': enable_ldap, 'base_dn': base_dn}
+        config: Dict[str, Union[str, bool]] = {}
+        if enable_ldap is not None:
+            config['use_ad_posix_attributes'] = enable_ldap
+        if base_dn is not None:
+            config['base_dn'] = base_dn
+        if domain is not None:
+            config['domain'] = domain
         if search_trusted_domains is not None:
             config['search_trusted_domains'] = search_trusted_domains
 
         return self.client.send_request(method, uri, body=config).data
 
     def leave_ad(self, domain: object, username: object, password: object) -> MonitorURI:
         method = 'POST'
```

## qumulo/rest/cluster.py

```diff
@@ -7,22 +7,28 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
 
-from typing import Optional, Sequence, Union
+from dataclasses import dataclass
+from typing import Any, Dict, Mapping, NamedTuple, Optional, Sequence, Union
 
 import qumulo.lib.request as request
 
 from qumulo.lib.auth import Credentials
 from qumulo.lib.request import Connection, RestResponse
 
 
+class StripeConfig(NamedTuple):
+    blocks_per_stripe: int
+    data_blocks_per_stripe: int
+
+
 @request.request
 def list_nodes(conninfo: Connection, _credentials: Optional[Credentials]) -> RestResponse:
     method = 'GET'
     uri = '/v1/cluster/nodes/'
 
     return conninfo.send_request(method, uri)
 
@@ -285,7 +291,122 @@
 
     req = {
         'node_uuids': [] if node_uuids is None else list(node_uuids),
         'node_ips': [] if node_ips is None else list(node_ips),
     }
 
     return conninfo.send_request(method, uri, body=req)
+
+
+@request.request
+def modify_nodes(
+    conninfo: Connection,
+    _credentials: Optional[Credentials],
+    node_uuids: Optional[Sequence[str]] = None,
+    node_ips: Optional[Sequence[str]] = None,
+    nodes_to_replace: Optional[Sequence[int]] = None,
+    blobs: Optional[Sequence[object]] = None,
+    target_max_node_failures: Optional[int] = None,
+    target_stripe_config: Optional[StripeConfig] = None,
+) -> RestResponse:
+    method = 'POST'
+    uri = '/v2/cluster/nodes/'
+
+    req = {
+        'node_uuids': [] if node_uuids is None else list(node_uuids),
+        'node_ips': [] if node_ips is None else list(node_ips),
+        'nodes_to_replace': [] if nodes_to_replace is None else list(nodes_to_replace),
+        'blobs': [] if blobs is None else list(blobs),
+    }
+
+    if target_max_node_failures:
+        req['target_max_node_failures'] = target_max_node_failures
+
+    if target_stripe_config:
+        req['target_stripe_config'] = {
+            'blocks_per_stripe': target_stripe_config.blocks_per_stripe,
+            'data_blocks_per_stripe': target_stripe_config.data_blocks_per_stripe,
+        }
+
+    return conninfo.send_request(method, uri, body=req)
+
+
+@dataclass
+class ModifyDryRunResponse:
+    current_capacity: int
+    current_max_node_failures: int
+    projected_capacity: int
+    projected_max_node_failures: int
+
+    @staticmethod
+    def from_dict(data: Mapping[str, Any]) -> 'ModifyDryRunResponse':
+        return ModifyDryRunResponse(
+            current_capacity=int(data['current_capacity']),
+            current_max_node_failures=int(data['current_max_node_failures']),
+            projected_capacity=int(data['projected_capacity']),
+            projected_max_node_failures=int(data['projected_max_node_failures']),
+        )
+
+
+@request.request
+def modify_nodes_dry_run(
+    conninfo: Connection,
+    _credentials: Optional[Credentials],
+    node_uuids: Optional[Sequence[str]] = None,
+    node_ips: Optional[Sequence[str]] = None,
+    nodes_to_replace: Optional[Sequence[int]] = None,
+    blobs: Optional[Sequence[object]] = None,
+    target_max_node_failures: Optional[int] = None,
+    target_stripe_config: Optional[StripeConfig] = None,
+) -> RestResponse:
+    method = 'POST'
+    uri = '/v2/cluster/nodes/dry-run'
+
+    req = {
+        'node_uuids': [] if node_uuids is None else list(node_uuids),
+        'node_ips': [] if node_ips is None else list(node_ips),
+        'nodes_to_replace': [] if nodes_to_replace is None else list(nodes_to_replace),
+        'blobs': [] if blobs is None else list(blobs),
+    }
+
+    if target_max_node_failures:
+        req['target_max_node_failures'] = target_max_node_failures
+
+    if target_stripe_config:
+        req['target_stripe_config'] = {
+            'blocks_per_stripe': target_stripe_config.blocks_per_stripe,
+            'data_blocks_per_stripe': target_stripe_config.data_blocks_per_stripe,
+        }
+
+    return conninfo.send_request(method, uri, body=req)
+
+
+@request.request
+def register_node_replacement_plan(
+    conninfo: Connection,
+    _credentials: Optional[Credentials],
+    nodes_to_be_replaced: Sequence[int],
+    target_stripe_config: Optional[StripeConfig] = None,
+) -> RestResponse:
+    method = 'POST'
+    uri = '/v1/cluster/node-replacement-plan/'
+
+    req: Dict[str, Any] = {'nodes_to_be_replaced': nodes_to_be_replaced}
+    if target_stripe_config:
+        req['target_stripe_config'] = {
+            'blocks_per_stripe': target_stripe_config.blocks_per_stripe,
+            'data_blocks_per_stripe': target_stripe_config.data_blocks_per_stripe,
+        }
+
+    return conninfo.send_request(method, uri, body=req)
+
+
+@request.request
+def get_node_replacement_plan(
+    conninfo: Connection, _credentials: Optional[Credentials]
+) -> RestResponse:
+    method = 'GET'
+    uri = '/v1/cluster/node-replacement-plan/'
+
+    resp = conninfo.send_request(method, uri)
+    del resp.data['target_compatibility_class']
+    return resp
```

## qumulo/rest/support.py

```diff
@@ -90,14 +90,22 @@
     method = 'PUT'
     uri = '/v1/support/status/local'
 
     return conninfo.send_request(method, uri, body=status)
 
 
 @request.request
+def generate_vpn_key(conninfo: Connection, credentials: Optional[Credentials]) -> RestResponse:
+    method = 'POST'
+    uri = '/v1/support/vpn/key/generate'
+
+    return conninfo.send_request(method, uri)
+
+
+@request.request
 def get_vpn_keys(conninfo: Connection, credentials: Optional[Credentials]) -> RestResponse:
     method = 'GET'
     uri = '/v1/support/vpn-keys'
 
     return conninfo.send_request(method, uri)
 
 
@@ -105,7 +113,17 @@
 def install_vpn_keys(
     conninfo: Connection, credentials: Optional[Credentials], vpn_keys: Mapping[str, str]
 ) -> RestResponse:
     method = 'PATCH'
     uri = '/v1/support/vpn-keys'
 
     return conninfo.send_request(method, uri, body=vpn_keys)
+
+
+@request.request
+def get_certificate_signing_request(
+    conninfo: Connection, credentials: Optional[Credentials]
+) -> RestResponse:
+    method = 'GET'
+    uri = '/v1/support/vpn/key/certificate-signing-request'
+
+    return conninfo.send_request(method, uri)
```

## Comparing `qumulo_api-6.1.1.dist-info/LICENSE` & `qumulo_api-6.1.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `qumulo_api-6.1.1.dist-info/METADATA` & `qumulo_api-6.1.2.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: qumulo-api
-Version: 6.1.1
+Version: 6.1.2
 Summary: Qumulo Python SDK
 Home-page: http://www.qumulo.com/
 Author: Qumulo, Inc.
 Author-email: python@qumulo.com
 License: UNKNOWN
 Keywords: Qumulo QFSD
 Platform: UNKNOWN
```

## Comparing `qumulo_api-6.1.1.dist-info/RECORD` & `qumulo_api-6.1.2.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-qumulo/__init__.py,sha256=TogwtvfScmmY5i06w1pmsYL28pcWyPETM_YMFRujQQY,22
+qumulo/__init__.py,sha256=YN8byPcjyQjphqvazTEzWioECzFuTCnjb_LQ7d7T_gw,22
 qumulo/rest_client.py,sha256=aq90iwIFpgnfiqTJYIlSvVtZJc_EoVVAodEfyDQRm0Y,11049
 qumulo/retry.py,sha256=u1hJFtqzIg89ShrWFcbsG1voSNHzbjuQiayb91UdlBE,5463
 qumulo/commands/__init__.py,sha256=JgiD4KhBsFJDY3Q_8l4cVHMBCEMXg20C2aCjhYY7IO0,1178
 qumulo/commands/access_tokens.py,sha256=6yTTZIIFzUrGTJbZBKb6L1icFGu5QML8FXaKNFblUrg,7430
-qumulo/commands/ad.py,sha256=qyVkBBHX1arhHCP477tJfn3u002NAOVoCZgO0rmLdNI,16853
+qumulo/commands/ad.py,sha256=f9k4IJ7YoliOxpcuRn76iwCglYWcgvqdzkwHHLX-ufM,16778
 qumulo/commands/analytics.py,sha256=oTV-iupk3n8VqnxXS2HzDxz2TwdWdVLSe50cs21RSCQ,5048
 qumulo/commands/audit.py,sha256=JI4TfZwqQqX88z6bgRi2ZHop0dHVFpmVJQ5bCCU2zJE,6531
 qumulo/commands/auth.py,sha256=vHKm-gNDPBEsU2M4X8fgt7wolrH7fmYLWu6LvY6jiQI,35605
 qumulo/commands/checksumming.py,sha256=3q3pltd1RS22a-PoJWyI6u_rL6H3j5xfY0Wgn2Snnc8,1045
-qumulo/commands/cluster.py,sha256=0s9Pf2LZbAPOQp23g3UKEUdEX6vZiQFe845U9JnAm4U,18172
+qumulo/commands/cluster.py,sha256=N0nVGZaFMsOxRLrEMSi6KpGTRnMGExF_oTE5FmP1YAo,40293
 qumulo/commands/dns.py,sha256=iwUEtLkGIIpmm0MLNavXiOtXB1Mmrmio9EwqNcMPXXs,4605
 qumulo/commands/encryption.py,sha256=gYO8SsBDDMPS-OP5pUyZdYfnNS91dJM9Yj9FM9ZY5FA,1506
 qumulo/commands/file_permissions_help.py,sha256=gWzBwYJEXURk2Dz3G-f9u3QDPX9WwK7lAfcOrfu_Gro,2843
-qumulo/commands/fs.py,sha256=RNmMRDYbPbHndrexQsLt4xgk-81KIFjI3sCE7rvR_Cg,129900
+qumulo/commands/fs.py,sha256=G-AkqKZw0eROBNtQMDzF6_9bN3LYUFGENJqq_Pxx-Wk,129890
 qumulo/commands/ftp.py,sha256=1rObDBzV_kHIbbNDEH8ZncxHmHy7UfEfLIrX4pEpNf8,3933
 qumulo/commands/kerberos.py,sha256=kpziy7Hew-eL8RDETmdNtMJ2bLOkYnEIXuOrUdTE1-E,3596
 qumulo/commands/key_store.py,sha256=sropAA4pDhbnNt64IVP5TUWYqbn_eOLLBrlNn59OkHw,18150
 qumulo/commands/ldap.py,sha256=M7TTecZJWHR8-qy2ZIwoCxhRa9t1DrcKTClUsYUcWw0,12310
 qumulo/commands/login.py,sha256=AeBwSfoRTDN6XL-FWO_UONPSYQuglVZH2pG7O7SyA1g,6846
 qumulo/commands/metrics.py,sha256=7gt0OGWfV_hE5ZH2B1i5xxOEIEt1-kIbUGJ9MtYPF9A,1070
 qumulo/commands/multitenancy.py,sha256=l-JjCkEiDhZ8CCNvatB3dSNFzhels8NYuVHHl9gi5ug,16823
@@ -52,23 +52,23 @@
 qumulo/lib/opts.py,sha256=jY5ToIjIX-xRIgi_evvU9I_k006K_pmHVX_nqUQLbcs,8901
 qumulo/lib/qq.py,sha256=hNkV13WKDVeeSh4WZdhau7-KhpGe0SDN6up3Eg47NS4,6063
 qumulo/lib/request.py,sha256=4y5S-mXx5t7WwavpXH9FEKqYJp5DXRh5vVyB2XwbWSU,25203
 qumulo/lib/rest_util.py,sha256=e8jHj2tvJCSljQFtVPw9GJpTuDTT6ECYbFN0K4dcTQQ,1058
 qumulo/lib/rfc3339.py,sha256=nldESt-PcUWaaGJY3yRtD4geTn35h0EvYoNsie2yP0I,926
 qumulo/lib/tenant.py,sha256=uvlW3bAZNT0CRF9CUXdRdwlJf7p14ENJA5cY_wXqqpU,2009
 qumulo/lib/uri.py,sha256=9zWsU20p6phHupk8dTEsbVmUYSwSpx4Kb0B9OZ2VEWQ,3350
-qumulo/lib/util.py,sha256=Ed4zFb2Q7Bl_lisTCopwHh8swnwahd2ijzNcn8ziuZE,14792
+qumulo/lib/util.py,sha256=ZUh6Sk01nCrR9m-D5Yqn_p_JwIU69rq9WWuPgL5QGG4,14820
 qumulo/rest/__init__.py,sha256=4T_T52X6NRTPg-Xmsf057SRhbz7RlWNDPSlVpKcg6_I,1167
 qumulo/rest/access_tokens.py,sha256=zDFQaTejK96LbpX37KufHt0q2SsOMs3OyU4SDjChdRY,4501
-qumulo/rest/ad.py,sha256=YdFGR_lWm-SFgoV7aygNRf8p-mZKrfiHHJaKci3fDyo,7046
+qumulo/rest/ad.py,sha256=Y-Z5oHYgyzIDjji-EN_018LyFqFlUVKAEz5N9CkhEgc,7358
 qumulo/rest/analytics.py,sha256=mh7-xa2HZIMNIn6v5jb7iFZEOquob40dzuiLUKc4Vfg,2204
 qumulo/rest/audit.py,sha256=WNfiXZIP7jGRIgsjfvfYBEeS1TLCdP-n2EY36Tup3v8,5909
 qumulo/rest/auth.py,sha256=5gGOwOmBvdsWNhOAgo9vz8SSGxDINvXvZMMgp8U3KL0,8419
 qumulo/rest/checksumming.py,sha256=kBlck-tQvDQNP-x8L24nxK1j90E_30hiVl6cCuAA0-o,914
-qumulo/rest/cluster.py,sha256=JroZ2QXo71acWsFNmpVj9F_J8n1dy_km7KB71bJEdgk,8793
+qumulo/rest/cluster.py,sha256=PYUfMx_6dFagzT8Xv3x2B3ncdCLnWhLrj0XH_3oKx5c,12868
 qumulo/rest/dns.py,sha256=SrRHt9ZlOezFK0fqpD9x0qcY_cMqaTM-YUWVn1lypUA,3056
 qumulo/rest/encryption.py,sha256=sDBrntJt2FozrOf4aq2gOntzzuxke-k70CZS8sis6h0,1148
 qumulo/rest/fs.py,sha256=-NO82G42cv4B3wlZRH5E6zO59bB-_vjSi01sLVVaYzo,49583
 qumulo/rest/ftp.py,sha256=1VxfZDzzvx50uw74m0sk8C-X_52x130bY2fW12IcBdk,4531
 qumulo/rest/groups.py,sha256=n4ZNfSzB7Q8AtQS5ZZqawS489i7X2l8uSUKetylhoaY,4410
 qumulo/rest/kerberos.py,sha256=cd1erooNDanAAq6FmVGeaemqmbloOfqKjy2mHQ9F7no,2897
 qumulo/rest/ldap.py,sha256=FWRVQhQ3mSXSFBWJDiZ9PSGWHfF-hosMcurrD0kROek,4490
@@ -84,24 +84,24 @@
 qumulo/rest/replication.py,sha256=SycnRrOhTAHDjgBkFLsLe9SBW4UqTqpmdbTXDPIOd0w,11002
 qumulo/rest/roles.py,sha256=5XlJmpXLzOsvPLYs-G4MNmsiRHgug-6h9QIQkdgjQtQ,6628
 qumulo/rest/s3.py,sha256=NyM2GUN3o9qL-aoY0eKSnwvkiDpMF2iOjdgpsvdDY5o,9857
 qumulo/rest/saml.py,sha256=gSqoD_FO-Jy9mgVMNBCYBTGTYGzUbKnX6c3z5IIXRk0,2687
 qumulo/rest/shutdown.py,sha256=f1rkzEJR1Hjm7hfF46RlowHxWkUW1cgOBLD1O6-1Nyg,1944
 qumulo/rest/smb.py,sha256=lMQvZTCMh4tkI9iSQBmZboRCebQ2kRkqHmGMgpFRrk8,11128
 qumulo/rest/snapshot.py,sha256=HtViqFjSOmZS_c3UxsHmY2PHchp5bF5fd9QAGYJqwwE,12759
-qumulo/rest/support.py,sha256=-_y13LELb58WG23trCHB_zwuXwEDI_xqIZV9opfUmwc,3265
+qumulo/rest/support.py,sha256=8fsg1FZoTgnNIvGbyALBswo-DDlPJgC0ddzu21oD2MY,3750
 qumulo/rest/time_config.py,sha256=Rg_XhzCjFwXTsa02ha8aEIMj9NFVCYYIaH8vC-lQEW0,1972
 qumulo/rest/tree_delete.py,sha256=t84-SU_E-SycSspgoIIO4UDKGySegDQyArAMWvav9P4,2706
 qumulo/rest/unconfigured_node_operations.py,sha256=lBaY05t5qLWrqBFpmL18a9mj12kd9TN_IMPQ6JRnWEE,1780
 qumulo/rest/upgrade.py,sha256=7jcUzT9tWxINn9B4RP4a1KuWB8DLY57RdE5uwWsUP60,1960
 qumulo/rest/upgrade_v2.py,sha256=P4LAIw378E-08SuXcpx0IlMsSMbOjqWY2zg55Zvlu6Q,2968
 qumulo/rest/upgrade_v3.py,sha256=0yqWSG05NZJhOOKwx5IJf4pwseM7V_Qj2E6xxmAtKfI,1234
 qumulo/rest/users.py,sha256=HW3SdpGLdo5DaWZCWTdLA4cgCwe8fBYk3tJwwuhKvlQ,4689
 qumulo/rest/version.py,sha256=0HOGMR9tQUMbXLyt94_cUn3s3ppwliRw9pN82YDJivI,1593
 qumulo/rest/web_ui.py,sha256=TnWXaZ0WDf3DAIo2ybj5kjQIVR0kvQFfbJepTf8_7H4,3679
-qumulo_api-6.1.1.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
-qumulo_api-6.1.1.dist-info/METADATA,sha256=Pvg5gVNPu0--atH3KICx2z_WIEbroeV4rDJik780o7E,3776
-qumulo_api-6.1.1.dist-info/NOTICE,sha256=2OJiVEfAyPpI5sXj3vRc_xi4T27O9QtT7r1KVRjASXo,290
-qumulo_api-6.1.1.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-qumulo_api-6.1.1.dist-info/entry_points.txt,sha256=Ygm2HVqVPjLgqJ48XZZSycDnmldDk_zXwCn0RVVQj44,68
-qumulo_api-6.1.1.dist-info/top_level.txt,sha256=ue_iyvfoYhuoCA8JzeMN3s2qu_G1MMtPwVzG6zsv_vE,7
-qumulo_api-6.1.1.dist-info/RECORD,,
+qumulo_api-6.1.2.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
+qumulo_api-6.1.2.dist-info/METADATA,sha256=9mO5HfilLZsKUWL8OEvSnb-wfwZjYLyQzt184RmzHGE,3776
+qumulo_api-6.1.2.dist-info/NOTICE,sha256=2OJiVEfAyPpI5sXj3vRc_xi4T27O9QtT7r1KVRjASXo,290
+qumulo_api-6.1.2.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
+qumulo_api-6.1.2.dist-info/entry_points.txt,sha256=Ygm2HVqVPjLgqJ48XZZSycDnmldDk_zXwCn0RVVQj44,68
+qumulo_api-6.1.2.dist-info/top_level.txt,sha256=ue_iyvfoYhuoCA8JzeMN3s2qu_G1MMtPwVzG6zsv_vE,7
+qumulo_api-6.1.2.dist-info/RECORD,,
```

